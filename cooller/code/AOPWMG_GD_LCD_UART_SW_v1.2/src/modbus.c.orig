#include "modbus.h"
#include "crc.h"
#include "sensor.h"
unsigned char Modbus_03_Solve(void);
unsigned char Modbus_06_Solve(void);
unsigned char Modbus_16_Solve(void);
void RS485_SendData(u8 *buff,u8 len,unsigned char flag);
modbus_stru modbus_usr;
#if CPU == ST
extern UART_HandleTypeDef huart6;
#endif
unsigned int startRegAddr;
unsigned int RegNum;
unsigned int calCRC;

//modbus_pack_stru  modbus_pack_usr;
unsigned char rxb;


void recovery_ORP_PH(unsigned char addr)
{

		
		unsigned char i;
	i = 0;

	 /*  modbus_usr.RS485_TX_BUFF[i++]= addr;
   modbus_usr.RS485_TX_BUFF[i++]= 0x06;
   modbus_usr.RS485_TX_BUFF[i++]= 0x00;
   modbus_usr.RS485_TX_BUFF[i++]= 0x19;
   modbus_usr.RS485_TX_BUFF[i++]= 0x00;
   modbus_usr.RS485_TX_BUFF[i++]= 0x02; */ 
   modbus_usr.RS485_TX_BUFF[i++]= addr;
   modbus_usr.RS485_TX_BUFF[i++]= 0x06;
   modbus_usr.RS485_TX_BUFF[i++]= 0x00;
   modbus_usr.RS485_TX_BUFF[i++]= 0x1b;
   modbus_usr.RS485_TX_BUFF[i++]= 0x00;
   modbus_usr.RS485_TX_BUFF[i++]= 0xff;  
   calCRC=CRC_Compute(modbus_usr.RS485_TX_BUFF,i);
  
   modbus_usr.RS485_TX_BUFF[i++]=(calCRC>>8)&0xFF;
	modbus_usr.RS485_TX_BUFF[i++]=(calCRC)&0xFF;
 RS485_SendData(modbus_usr.RS485_TX_BUFF,i,0);
}
void setAddr_ORP_PH(unsigned char addr)
{

		
		unsigned char i;
	i = 0;
   modbus_usr.RS485_TX_BUFF[i++]= 0x01;//出厂地址
   modbus_usr.RS485_TX_BUFF[i++]= 0x06;
   modbus_usr.RS485_TX_BUFF[i++]= 0x00;
   modbus_usr.RS485_TX_BUFF[i++]= 0x19;
   modbus_usr.RS485_TX_BUFF[i++]= 0x00;
   modbus_usr.RS485_TX_BUFF[i++]= addr;  
 
   calCRC=CRC_Compute(modbus_usr.RS485_TX_BUFF,i);
  
   modbus_usr.RS485_TX_BUFF[i++]=(calCRC>>8)&0xFF;
	modbus_usr.RS485_TX_BUFF[i++]=(calCRC)&0xFF;
 RS485_SendData(modbus_usr.RS485_TX_BUFF,i,0);
}

void RS485_Init()
{

   #if CPU == ST
    HAL_GPIO_WritePin(EN1_485_GPIO_Port, EN1_485_Pin, GPIO_PIN_RESET);
    modbus_usr.RS485_TX_EN=0;//默认为接收模式
    __HAL_UART_CLEAR_IDLEFLAG(&huart6);
    __HAL_UART_DISABLE_IT(&huart6, UART_IT_IDLE);	//使能空闲中断
    HAL_UART_DMAStop(&huart6);
    HAL_UART_DMAResume(&huart6);
    __HAL_UART_ENABLE_IT(&huart6, UART_IT_IDLE);	//使能空闲中断
    HAL_UART_Receive_DMA(&huart6,modbus_usr.RS485_RX_BUFF,MODBUS_BSIZE);
   #else	
	dma_single_data_parameter_struct dma_init_struct;

	  /* deinitialize DMA1 channel2 (USART0 rx) */
    dma_deinit(DMA1, DMA_CH2);
    dma_init_struct.direction = DMA_PERIPH_TO_MEMORY;
    dma_init_struct.memory0_addr = (uint32_t)(modbus_usr.RS485_RX_BUFF);
    dma_init_struct.memory_inc = DMA_MEMORY_INCREASE_ENABLE;
    dma_init_struct.number = MODBUS_BSIZE;
    dma_init_struct.periph_addr = (uint32_t)&USART_DATA(USART5);
    dma_init_struct.periph_inc = DMA_PERIPH_INCREASE_DISABLE;
    dma_init_struct.periph_memory_width = DMA_PERIPH_WIDTH_8BIT;
    dma_init_struct.priority = DMA_PRIORITY_ULTRA_HIGH;
    dma_single_data_mode_init(DMA1, DMA_CH2, &dma_init_struct);

    /* configure DMA mode */
    dma_circulation_disable(DMA1, DMA_CH2);
    dma_channel_subperipheral_select(DMA1, DMA_CH2, DMA_SUBPERI5);
    /* enable DMA1 channel2 transfer complete interrupt */
    dma_interrupt_enable(DMA1, DMA_CH2, DMA_CHXCTL_FTFIE);
    /* enable DMA1 channel2 */
    dma_channel_enable(DMA1, DMA_CH2);
	#endif
}
//////////////////////////////////////////////////////////////////////////////
//发送n个字节数据
//buff:发送区首地址
//len：发送的字节数
void RS485_SendData(u8 *buff,u8 len,unsigned char flag)
{
    unsigned int i;
   #if CPU == ST
    if(flag == 0)
        HAL_GPIO_WritePin(EN1_485_GPIO_Port, EN1_485_Pin, GPIO_PIN_SET);;
    modbus_usr.RS485_TX_EN=1;//切换为发送模式
       HAL_UART_Transmit(&huart6,buff,len,300);
    HAL_GPIO_WritePin(EN1_485_GPIO_Port, EN1_485_Pin, GPIO_PIN_RESET);
   #else
   if(flag == 0)
   	
   /*Configure GPIO pin Output Level */
	  gpio_bit_set(EN1_485_GPIO_Port, EN1_485_Pin);
	 
   modbus_usr.RS485_TX_EN=1;//切换为发送模式
   i=0;
   while(i<=len)
	 {
		 usart_data_transmit(USART5, buff[i++]);
	  while(RESET == usart_flag_get(USART5, USART_FLAG_TBE));
	 }
   
   gpio_bit_reset(EN1_485_GPIO_Port, EN1_485_Pin);
   #endif 
}
void Modbus_Pack(modbus_pack_stru p)
{
    unsigned char len;

    unsigned char index;
    index = 0;



    if(p.func == 0x03)
    {
        modbus_usr.RS485_TX_BUFF[index++]=p.RS485_Addr;
        modbus_usr.RS485_TX_BUFF[index++]=p.func;
        modbus_usr.RS485_TX_BUFF[index++]=(u8)(p.startaddr>>8);
        modbus_usr.RS485_TX_BUFF[index++]=(u8)(p.startaddr);
        modbus_usr.RS485_TX_BUFF[index++]=(u8)(p.regnum>>8);
        modbus_usr.RS485_TX_BUFF[index++]=(u8)(p.regnum);
    }
    else
    {
        if(p.datType == FLOAT_TYPE)
        {
            modbus_usr.RS485_TX_BUFF[index++]=p.RS485_Addr;
            modbus_usr.RS485_TX_BUFF[index++]=p.func;
            modbus_usr.RS485_TX_BUFF[index++]=(u8)(p.startaddr>>8);
            modbus_usr.RS485_TX_BUFF[index++]=(u8)(p.startaddr);
            modbus_usr.RS485_TX_BUFF[index++]=(u8)(p.regnum>>8);
            modbus_usr.RS485_TX_BUFF[index++]=(u8)(p.regnum);
        }
        else
        {
            modbus_usr.RS485_TX_BUFF[index++]=p.RS485_Addr;
            modbus_usr.RS485_TX_BUFF[index++]=p.func;
            modbus_usr.RS485_TX_BUFF[index++]=(u8)(p.startaddr>>8);
            modbus_usr.RS485_TX_BUFF[index++]=(u8)(p.startaddr);

        }
    }


    len = index;
    if(p.datcount)
    {
       // modbus_usr.RS485_TX_BUFF[index++]=(u8)(p.datcount);
        memcpy(&modbus_usr.RS485_TX_BUFF[index],p.modbus_txdata,p.datcount);
        len = len + p.datcount;
        calCRC=CRC_Compute(modbus_usr.RS485_TX_BUFF,len);
        modbus_usr.RS485_TX_BUFF[len++]=(calCRC>>8)&0xFF;
        modbus_usr.RS485_TX_BUFF[len++]=(calCRC)&0xFF;
			//len = len + 2;
    }
    else
    {
        //len = len + 2;
        calCRC=CRC_Compute(modbus_usr.RS485_TX_BUFF,len);
        modbus_usr.RS485_TX_BUFF[len++]=(calCRC>>8)&0xFF;
        modbus_usr.RS485_TX_BUFF[len++]=(calCRC)&0xFF;
    }


    RS485_SendData(modbus_usr.RS485_TX_BUFF,len,0);
}

/*************************************************************
485串口接收中断回调函数
*************************************************************/
void RS485_RxCpltCallback()
{dma_single_data_parameter_struct dma_init_struct;
    modbus_usr.RS485_FrameFlag=2;//置位帧结束标记
	#if CPU == ST
    HAL_UART_DMAStop(&huart6);
    HAL_UART_DMAResume(&huart6);
    HAL_UART_Receive_DMA(&huart6,modbus_usr.RS485_RX_BUFF,MODBUS_BSIZE);
	#else
	modbus_usr.RS485_FrameFlag=2;

	//*dma_channel_disable(DMA1, DMA_CH2); 					/* 关闭DMA传输 */

    /* configure DMA mode */
   // dma_circulation_disable(DMA1, DMA_CH2);
   // dma_channel_subperipheral_select(DMA1, DMA_CH2, DMA_SUBPERI5);
    /* enable DMA1 channel2 transfer complete interrupt */
   // dma_interrupt_enable(DMA1, DMA_CH2, DMA_CHXCTL_FTFIE);
    /* enable DMA1 channel2 */
   // dma_channel_enable(DMA1, DMA_CH2);*/

    /* deinitialize DMA1 channel2 (USART0 rx) */
    dma_deinit(DMA1, DMA_CH2);
    dma_init_struct.direction = DMA_PERIPH_TO_MEMORY;
    dma_init_struct.memory0_addr = (uint32_t)(modbus_usr.RS485_RX_BUFF);
    dma_init_struct.memory_inc = DMA_MEMORY_INCREASE_ENABLE;
    dma_init_struct.number = MODBUS_BSIZE;
    dma_init_struct.periph_addr = (uint32_t)&USART_DATA(USART5);
    dma_init_struct.periph_inc = DMA_PERIPH_INCREASE_DISABLE;
    dma_init_struct.periph_memory_width = DMA_PERIPH_WIDTH_8BIT;
    dma_init_struct.priority = DMA_PRIORITY_ULTRA_HIGH;
    dma_single_data_mode_init(DMA1, DMA_CH2, &dma_init_struct);

    /* configure DMA mode */
    dma_circulation_disable(DMA1, DMA_CH2);
    dma_channel_subperipheral_select(DMA1, DMA_CH2, DMA_SUBPERI5);
    /* enable DMA1 channel2 transfer complete interrupt */
    dma_interrupt_enable(DMA1, DMA_CH2, DMA_CHXCTL_FTFIE);
    /* enable DMA1 channel2 */
    dma_channel_enable(DMA1, DMA_CH2);

	#endif
}
/////////////////////////////////////////////////////////////////////////////////////
//RS485服务程序，用于处理接收到的数据(请在主函数中循环调用)

unsigned char RS485_Service(void)
{
    u16 recCRC;
	unsigned char result;
	result = 1;
    if(modbus_usr.RS485_FrameFlag==2)
    {
			  #if CPU == ST
        HAL_GPIO_WritePin(EN1_485_GPIO_Port, EN1_485_Pin, GPIO_PIN_RESET);
			#else
			 gpio_bit_write(EN1_485_GPIO_Port, EN1_485_Pin, RESET);
			#endif
        if(modbus_usr.RS485_RX_BUFF[0]>= MIN_ADDR &&
                modbus_usr.RS485_RX_BUFF[0]<= MAX_ADDR)//地址正确
        {
            if((modbus_usr.RS485_RX_BUFF[1]==03)||(modbus_usr.RS485_RX_BUFF[1]==06)||(modbus_usr.RS485_RX_BUFF[1]==16))//功能码正确
            {
                modbus_usr.RS485_RX_CNT = modbus_usr.RS485_RX_BUFF[2]+5;
                calCRC=CRC_Compute(modbus_usr.RS485_RX_BUFF,modbus_usr.RS485_RX_CNT-2);//计算所接收数据的CRC
                recCRC=modbus_usr.RS485_RX_BUFF[modbus_usr.RS485_RX_CNT-1]|(((u16)modbus_usr.RS485_RX_BUFF[modbus_usr.RS485_RX_CNT-2])<<8);//接收到的CRC(低字节在前，高字节在后)
                if(calCRC==recCRC)//CRC校验正确
                {
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    switch(modbus_usr.RS485_RX_BUFF[1])//根据不同的功能码进行处理
                    {
                    case 3: //读寄存器
                    {
                        result =Modbus_03_Solve();
                        break;
                    }
                    case 6: //读寄存器
                    {
                       result = Modbus_06_Solve();
                        break;
                    }

                    case 16: //读寄存器
                    {
                       result = Modbus_16_Solve();
                        break;
                    }



                    }
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                }

            }
        }
				modbus_usr.RS485_FrameFlag=0;
    }
    return result;

}
modbus_stru *getModbusPayload(void)
{
 return &modbus_usr;
}
//return  0                                  2             3
//       orp or ph or temperature      warn or adc
unsigned char Modbus_03_Solve()
{
    unsigned char result;


        if(modbus_usr.RS485_RX_BUFF[2] == 4)//float type
        {
            GetModbusPack()->datType = FLOAT_TYPE;
//            GetModbusPack()->modbus_data[0] = modbus_usr.RS485_RX_BUFF[5];
//            GetModbusPack()->modbus_data[1] = modbus_usr.RS485_RX_BUFF[6];
//            GetModbusPack()->modbus_data[2] = modbus_usr.RS485_RX_BUFF[3];
//            GetModbusPack()->modbus_data[3] = modbus_usr.RS485_RX_BUFF[4];
					
					
            GetModbusPack()->modbus_data[0] = modbus_usr.RS485_RX_BUFF[4];
            GetModbusPack()->modbus_data[1] = modbus_usr.RS485_RX_BUFF[3];
            GetModbusPack()->modbus_data[2] = modbus_usr.RS485_RX_BUFF[6];
            GetModbusPack()->modbus_data[3] = modbus_usr.RS485_RX_BUFF[5];	
            result = 0;
        }
   else   if(modbus_usr.RS485_RX_BUFF[2] == 2)//unsigned int type
   {     {
            GetModbusPack()->datType = UINT_TYPE;
            GetModbusPack()->modbus_data[0] = modbus_usr.RS485_RX_BUFF[3];
            GetModbusPack()->modbus_data[1] = modbus_usr.RS485_RX_BUFF[4];
            result = 2;
        }

    }  
	 else
            result = 1;
	 GetModbusPack()->RS485_Addr = modbus_usr.RS485_RX_BUFF[0];
    return result;

}

unsigned char Modbus_06_Solve()
{
	GetModbusPack()->RS485_Addr = modbus_usr.RS485_RX_BUFF[0];
    return 1;
}
unsigned char Modbus_16_Solve()
{
	GetModbusPack()->RS485_Addr = modbus_usr.RS485_RX_BUFF[0];
    return 1;

}
