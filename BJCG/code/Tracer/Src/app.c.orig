#include "app.h"
#include "sensors.h"
#include "LteHal.h"
#include "LteHardware.h"
#include  "MX25_CMD.h"
#include "EEPROM.h"
#include "stdlib.h"
#include "crc.h"
#include "rtc.h"
systemParams_stru systemParams_usr;
void payloadpack(unsigned char *p,uint32_t size);
extern float FilterData[SN];//æ»¤æ³¢åçš„imuæ•°æ®
void HardwareInit()
{
    //LteUartConfig();
if(DEBUG_MODE == 0)
{
#if ROLE == LTE_4G

LtePowerManage(LTE_4G,ON);
#else
LtePowerManage(LTE_NBIOT,ON);
#endif

}

    sensors_Init();
}

uint32_t CpuID[3];
uint32_t Lock_Code;
void GetLockCode(void)
{
//è·å–CPUå”¯ä¸€ID
    CpuID[0]=*(volatile uint32_t*)(0x1fff7590);
    CpuID[1]=*(volatile uint32_t*)(0x1fff7594);
    CpuID[2]=*(volatile uint32_t*)(0x1fff7598);
//åŠ å¯†ç®—æ³•,å¾ˆç®€å•çš„åŠ å¯†ç®—æ³•
    Lock_Code=(CpuID[0]>>1)+(CpuID[1]>>2)+(CpuID[2]>>3);
}


void ParamsInit(void)
{

    uint32_t p;
    uint32_t addr;
    FLashData_stru *FLashData_usr2;
    addr = 0;
    FLashData_usr2 = GetFLashStatus();
    if(DEBUG_MODE == 1)
    {
        FLashData_usr2->LastWriteAddr = 0x7000;
    }

    flash_read(addr++,&p,1);
    if(p!=0x5a)
    {
        systemParams_usr.period = 120000;
        p = 0x5a;  //å†™å…¥æ ‡å¿—
        flash_init(0);
        addr = 0;
        flash_write(addr++, &p,1);
        flash_write( addr++,&(FLashData_usr2->LastReadAddr),1);
        flash_write( addr++,&(FLashData_usr2->LastWriteAddr),1);
        flash_write( addr++,&(FLashData_usr2->SumLen),1);

        if(DEBUG_MODE == 0)
        {
            systemParams_usr.DayPeriod = 1;
            systemParams_usr.NightPeriod = 10;
            systemParams_usr.Dhours = 6;
            systemParams_usr.Nhours = 18;
        }

        uint32_t tmp;

        tmp = systemParams_usr.DayPeriod;
        flash_write( addr++,&(tmp),1);
        tmp = systemParams_usr.NightPeriod;
        flash_write( addr++,(uint32_t *)&(tmp),1);
        tmp = systemParams_usr.Dhours;
        flash_write( addr++,(uint32_t *)&(tmp),1);
        tmp = systemParams_usr.Nhours;
        flash_write( addr++,(uint32_t *)&(tmp),1);
        if(DEBUG_MODE == 0)
        {
            EraseChip();
        }




    }
    else
    {

        addr = 0;
        flash_read( addr++, &p,1);
        flash_read( addr++, &(FLashData_usr2->LastReadAddr),1);

        flash_read( addr++, &(FLashData_usr2->LastWriteAddr),1);
        flash_read( addr++,  &(FLashData_usr2->SumLen),1);
        uint32_t tmp;


        flash_read( addr++,&(tmp),1);
        systemParams_usr.DayPeriod=tmp;

        flash_read( addr++,(uint32_t *)&(tmp),1);
        systemParams_usr.NightPeriod=tmp ;

        flash_read( addr++,(uint32_t *)&(tmp),1);
        systemParams_usr.Dhours=tmp  ;

        flash_read( addr++,(uint32_t *)&(tmp),1);
        systemParams_usr.Nhours =tmp ;

    }
    GetLockCode();

}
void systmeReconfig()
{
    uint32_t p;
    uint32_t addr;
    p = 0x5a;  //å†™å…¥æ ‡å¿—
    flash_init(0);
    addr = 0;
    flash_write(addr++, &p,1);
    flash_write( addr++,&(GetFLashStatus()->LastReadAddr),1);

    flash_write( addr++,&(GetFLashStatus()->LastWriteAddr),1);
    flash_write( addr++,&(GetFLashStatus()->SumLen),1);

    uint32_t tmp;

    tmp = systemParams_usr.DayPeriod;
    flash_write( addr++,&(tmp),1);
    tmp = systemParams_usr.NightPeriod;
    flash_write( addr++,(uint32_t *)&(tmp),1);
    tmp = systemParams_usr.Dhours;
    flash_write( addr++,(uint32_t *)&(tmp),1);
    tmp = systemParams_usr.Nhours;
    flash_write( addr++,(uint32_t *)&(tmp),1);


}
unsigned char  LteAnaly(void)
{
    unsigned int recCRC,calCRC;
    uint32_t len;
    unsigned char result;
    uint8_t *pb;
    pb = malloc(GetLteStru()->rxSize);
    result = 0;
    if(GetLteStru()->lterxbuffer[0]==SERVER_HEADER)
    {
        memcpy(pb,&(GetLteStru()->lterxbuffer[1]),GetLteStru()->rxSize-HEADDER_LEN);
        len = *(uint32_t *)GetLteStru()->lterxbuffer[LENINDEX]+DEVID_LEN+PAYLOAD_LEN;
        calCRC=CRC_Compute(pb,len-2);//è®¡ç®—æ‰€æ¥æ”¶æ•°æ®çš„CRC
        recCRC=pb[len-1]|(((u16)pb[len-2])<<8);//æ¥æ”¶åˆ°çš„CRC(ä½å­—èŠ‚åœ¨å‰ï¼Œé«˜å­—èŠ‚åœ¨å?
        if(calCRC!=recCRC||(calCRC == 0))//CRCæ ¡éªŒé”™è¯¯
        {
            result = 1;
        }
        else
        {
            switch(pb[CMD_INDEX])
            {
            case 0x60:
            	{
				                memcpy(pb+len,getGPS(),GPS_COUNT);
                len = len +GPS_COUNT;
                memcpy(pb+len,FilterData,SENSORS_COUNT);
                payloadpack(pb,SUM_COUNT);
			}
                break;
            case 0x61:
                if(pb[PARAMS_INDEX] == 0x31)
                {
                    systemParams_usr.Dhours= pb[20];
                    systemParams_usr.DayPeriod = pb[21];
                    systemParams_usr.Nhours= pb[23];
                    systemParams_usr.NightPeriod= pb[24];
                    systmeReconfig();
                }
                break;
            }
            result = 0;
        }
    }
    free(pb);
    return result;
}


void payloadpack(unsigned char *p,uint32_t size)
{
    unsigned char *pb;
    unsigned int calCRC;
    uint32_t len;
    pb = malloc(size+HEADDER_LEN+DEVID_LEN+PAYLOAD_LEN+CRC_LEN);//id:12   len:4  crc: 2 header:1
    pb[0] = NODE_HEADER;
    len = 0;//header length is not included
    memcpy(&(pb[DEVID_INDEX]),CpuID,DEVID_LEN);//dev id
    len = len +DEVID_LEN;
    len = len +PAYLOAD_LEN;//paylaod len length
    memcpy(pb+len,p,size);//gps+imu
    len = len +size;
    len = len +CRC_LEN;//crc
    pb[LENINDEX] = (unsigned char)len;
    pb[LENINDEX+1] = (unsigned char)(len>>8);
    pb[LENINDEX+2] = (unsigned char)(len>>16);
    pb[LENINDEX+3] = (unsigned char)(len>>24);
    calCRC=CRC_Compute(pb+HEADDER_LEN,len);//è®¡ç®—æ‰€æ¥æ”¶æ•°æ®çš„CRC
    pb[len] = (unsigned char)calCRC;
    pb[len-1] = (unsigned char)(calCRC>>8);

    LteUart_SendByte(LTE_4G,pb,len+HEADDER_LEN);
    free(pb);

}
void powersleep(void)
{


    GPIO_InitTypeDef GPIO_InitStruct = {0};

    /* GPIO Ports Clock Enable */



    /*Configure GPIO pins : DTR_Pin EN_3_3V_Pin SIM_PWR_Pin CTRL3__Pin
    						 CTRL1__Pin */
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4|
                          GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|
                          GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_15;//CTRL1OUT11_Pin|MODE1_Pin|MODE2_Pin|CTRL1OUT21_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;//CTRL1OUT11_Pin|MODE1_Pin|MODE2_Pin|CTRL1OUT21_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);


    GPIO_InitStruct.Pin =GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);


    GPIO_InitStruct.Pin = GPIO_PIN_3;//CTRL1OUT11_Pin|MODE1_Pin|MODE2_Pin|CTRL1OUT21_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    GPIO_InitStruct.Pin = GPIO_PIN_9;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_9, GPIO_PIN_SET);

    GPIO_InitStruct.Pin =GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);


    GPIO_InitStruct.Pin = GPIO_PIN_10;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    GPIO_InitStruct.Pin = GPIO_PIN_11;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    HAL_GPIO_WritePin(GPIOC, GPIO_PIN_11, GPIO_PIN_SET);
    HAL_GPIO_WritePin(GPIOC, GPIO_PIN_11, GPIO_PIN_RESET);

    GPIO_InitStruct.Pin = GPIO_PIN_All;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

    GPIO_InitStruct.Pin = GPIO_PIN_11;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
    HAL_GPIO_WritePin(GPIOC, GPIO_PIN_11, GPIO_PIN_SET);







    GPIO_InitStruct.Pin =GPIO_PIN_All;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);


    //HAL_GPIO_WritePin(GPIOC, EN_3_3V_Pin, GPIO_PIN_RESET);
    //HAL_GPIO_WritePin(GPIOA, EN_5V_Pin, GPIO_PIN_RESET);



    __HAL_RCC_GPIOC_CLK_DISABLE();
    __HAL_RCC_GPIOH_CLK_DISABLE();
    __HAL_RCC_GPIOA_CLK_DISABLE();
    __HAL_RCC_GPIOB_CLK_DISABLE();
    __HAL_RCC_GPIOD_CLK_DISABLE();
    __HAL_RCC_DMA1_CLK_DISABLE();
    __HAL_RCC_DMA2_CLK_DISABLE();
    __HAL_RCC_USART1_CLK_DISABLE();
    __HAL_RCC_USART2_CLK_DISABLE();
    __HAL_RCC_USART3_CLK_DISABLE();


    RTC_WAKEUP_Init(systemParams_usr.period);
    __HAL_RCC_PWR_CLK_ENABLE();
    HAL_SuspendTick();
    __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG();
    __HAL_PWR_CLEAR_FLAG(PWR_FLAG_WU);
    //	 HAL_PWR_EnterSTOPMode(PWR_LOWPOWERREGULATOR_ON, PWR_STOPENTRY_WFI);
    HAL_PWR_EnterSTANDBYMode();
    __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG();
    __HAL_PWR_CLEAR_FLAG(PWR_FLAG_WU);
    HAL_ResumeTick();

}
void DataUploadPeriod()
{

    if(getRTCTime()->Hours < systemParams_usr.Nhours&&getRTCTime()->Hours>=systemParams_usr.Dhours)  //23.00-18.0
    {
        systemParams_usr.period = systemParams_usr.DayPeriod;
    }
    else
    {
        systemParams_usr.period = systemParams_usr.NightPeriod;
    }

}
void test()
{
    // SIMCOM_Register_Network();
    //DataUploadPeriod();//æ•°æ®ä¸Šä¼ å‘¨æœŸæ§åˆ¶
    HAL_GPIO_TogglePin(GPIOB, led_Pin);
//   HAL_GPIO_WritePin(GPIOA, EN_5V_Pin, GPIO_PIN_SET);
//
//	/*Configure GPIO pin Output Level */
//	HAL_GPIO_WritePin(GPIOB, EN_5V1_Pin, GPIO_PIN_SET);
//
//	/*Configure GPIO pin Output Level */
//	HAL_GPIO_WritePin(GPIOC, EN_5V2_Pin, GPIO_PIN_SET);
//   HAL_GPIO_WritePin(GPIOB, EN_3V8_Pin, GPIO_PIN_RESET);

//  HAL_Delay(1000);
    snesors_process();//imuå‚æ•°é‡‡é›†

    /*Configure GPIO pin Output Level */
    //HAL_GPIO_WritePin(GPIOB, EN_5V1_Pin|EN_3V8_Pin, GPIO_PIN_SET);
    // HAL_Delay(1000);

    flash_process();
}
uint32_t ledtick;
void ledBLink()
{


    HAL_GPIO_TogglePin(GPIOB, led_Pin);
 HAL_Delay(500);


}
void app_main()
{

    uint32_t tick;
    unsigned char pb[SUM_COUNT*PAYLOAD_COUNT];
    uint32_t len;
    SIMCOM_Register_Network();
    DataUploadPeriod();//æ•°æ®ä¸Šä¼ å‘¨æœŸæ§åˆ¶
    ledBLink();
    if(GetLteStru()->NetStatus == SIMCOM_NET_OK)//è§£ææœåŠ¡å™¨æŒ‡ä»¤
    {

        RTC_Calibration(GetLteTime());//æ—¶é—´æ ¡å‡†
        if(GetLteStru()->LteReceivedFlag)
        {
            GetLteStru()->LteReceivedFlag = 0;
            LteAnaly();//è§£ææœåŠ¡ç«¯å‘½ä»¤
        }
    }

    /***********************æ•°æ®ä¸ŠæŠ¥æœºåˆ¶*********************************/
    if((HAL_GetTick()-tick)>=(systemParams_usr.period*60000))//å‘¨æœŸä¸ŠæŠ¥æ•°æ®
    {
        tick = HAL_GetTick();
        snesors_process();//imuå‚æ•°é‡‡é›†
        if(GetLteStru()->RetryConnectCount>MAX_CONNECT_COUNT )//æ–­ç½‘æ•°æ®å­˜å‚¨
        {
            //test();
            // pb = malloc(GetFLashStatus()->SumLen);
            FlashDataStore(GetFLashStatus()->LastWriteAddr,(uint32_t *)getGPS(),GPS_COUNT/4);
            FlashDataStore(GetFLashStatus()->LastWriteAddr,(uint32_t *)FilterData,SENSORS_COUNT);
            if(DEBUG_MODE == 1)
            {
                FlashReadOnebytes((GetFLashStatus()->LastReadAddr ),pb,GetFLashStatus()->SumLen,1);
            }
            else
            {
                powersleep();

            }
            // free(pb);
            //
        }

        if(GetLteStru()->NetStatus == SIMCOM_NET_OK)
        {
            if(GetFLashStatus()->SumLen !=0)//æ•°æ®æ–­ç½‘ç»­ä¼ 
            {
                uint32_t i,len,len2,k;
                len = GetFLashStatus()->SumLen;
                if(len<=SUM_COUNT*PAYLOAD_COUNT)//æ•°æ®åˆ†åŒ…
                {
                    FlashReadOnebytes((GetFLashStatus()->LastReadAddr ),pb,GetFLashStatus()->SumLen,1);
                    payloadpack(pb,GetFLashStatus()->SumLen);
                    GetFLashStatus()->SumLen = 0;
                }
                else  //åˆ†åŒ…ç»­ä¼ 
                {
                    k = len/(SUM_COUNT*PAYLOAD_COUNT);
                    len2 = k *(SUM_COUNT*PAYLOAD_COUNT);
                    for(i=0; i<k; i++)
                    {
                        FlashReadOnebytes((GetFLashStatus()->LastReadAddr),pb,SUM_COUNT*PAYLOAD_COUNT,1);
                        payloadpack(pb,SUM_COUNT*PAYLOAD_COUNT);

                    }

                    FlashReadOnebytes((GetFLashStatus()->LastReadAddr),pb,len-len2,1);
                    payloadpack(pb,len-len2);
                    GetFLashStatus()->SumLen = 0;
                }
                systmeReconfig();
            }
            else //å®šæœŸä¸Šä¼ 
            {
                memcpy(pb+len,getGPS(),GPS_COUNT);
                len = len +GPS_COUNT;
                memcpy(pb+len,FilterData,SENSORS_COUNT);
                payloadpack(pb,SUM_COUNT);
            }
            powersleep();
        }
    }
    /***************************æ•°æ®ä¸ŠæŠ¥æœºåˆ¶ç»“æŸ***********************************/

}
