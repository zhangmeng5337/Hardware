---- Reset Matches (1653 in 174 files) ----
bsp_InitI2C in bsp.c (F:\projects\git\Hardware\magnetic\code\node\Src\Hardare) : 

	HAL_GPIO_WritePin(I2C_ADD0_GPIO_Port, I2C_ADD0_Pin, GPIO_PIN_RESET);	
	HAL_GPIO_WritePin(I2C_ADD1_GPIO_Port, I2C_ADD1_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(I2C_MODE_GPIO_Port, I2C_MODE_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(RM_POWER_GPIO_Port, RM_POWER_Pin, GPIO_PIN_SET);
	HAL_GPIO_WritePin(SDA_GPIO_Port, SDA_Pin, GPIO_PIN_SET);
	HAL_GPIO_WritePin(SCL_GPIO_Port, SCL_Pin, GPIO_PIN_SET);
led_ctrl in bsp.c (F:\projects\git\Hardware\magnetic\code\node\Src\Hardare) : 
	{
		case ON:HAL_GPIO_WritePin(GPIOE, LED_Pin, GPIO_PIN_RESET);break;
		case OFF:HAL_GPIO_WritePin(GPIOE, LED_Pin, GPIO_PIN_SET);break;
		case BLINK:HAL_GPIO_TogglePin(GPIOE, LED_Pin);break;
	}
UsartReceive_IDLE in bsp.c (F:\projects\git\Hardware\magnetic\code\node\Src\Hardare) : 
		temp=__HAL_UART_GET_FLAG(&huart1,UART_FLAG_IDLE);
		if((temp!=RESET))
		{
			__HAL_UART_CLEAR_IDLEFLAG(&huart1);

UsartReceive_IDLE in bsp.c (F:\projects\git\Hardware\magnetic\code\node\Src\Hardare) : 
		temp=__HAL_UART_GET_FLAG(&huart2,UART_FLAG_IDLE);
		if((temp!=RESET))
		{
			__HAL_UART_CLEAR_IDLEFLAG(&huart2);

bsp.h (F:\projects\git\Hardware\magnetic\code\node\Inc\Hardware) line 9 : 
#define I2C1_SCL_1()   HAL_GPIO_WritePin(SCL_GPIO_Port, SCL_Pin, GPIO_PIN_SET)				/* SCL = 1 */
#define I2C1_SCL_0()   HAL_GPIO_WritePin(SCL_GPIO_Port, SCL_Pin, GPIO_PIN_RESET)				/* SCL = 0 */

#define I2C1_SDA_1()   HAL_GPIO_WritePin(SDA_GPIO_Port, SDA_Pin, GPIO_PIN_SET);				/* SDA = 1 */
#define I2C1_SDA_0()   HAL_GPIO_WritePin(SDA_GPIO_Port, SDA_Pin, GPIO_PIN_RESET);				/* SDA = 0 */

#define I2C1_SDA_READ()  HAL_GPIO_ReadPin(SDA_GPIO_Port, SDA_Pin)	/* ??SDA?????? */
#define I2C1_SCL_READ()  HAL_GPIO_ReadPin(SCL_GPIO_Port, SCL_Pin)		/* ??SCL?????? */
mag3D3100.c (F:\projects\git\Hardware\magnetic\code\node\Src\Hardare) line 11 : 

#define CS_L			HAL_GPIO_WritePin(RM_CS_GPIO_Port, RM_CS_Pin, GPIO_PIN_RESET)
#define CS_H			HAL_GPIO_WritePin(RM_CS_GPIO_Port, RM_CS_Pin, GPIO_PIN_SET)

extern uint8_t Tx_Update_Enable;
SPI_WriteByte in mag3D3100.c (F:\projects\git\Hardware\magnetic\code\node\Src\Hardare) : 
  //Wait until the transmit buffer is empty 
  while(SPI_I2S_GetFlagStatus(SPIx,SPI_I2S_FLAG_TXE)==RESET); 
  // Send the byte  
  SPI_I2S_SendData(SPIx,data); 

  //Wait until a data is received 
  while(SPI_I2S_GetFlagStatus(SPIx,SPI_I2S_FLAG_RXNE)==RESET); 
  // Get the received data 
  Data = SPI_I2S_ReceiveData(SPIx); 

mag3D3100.h (F:\projects\git\Hardware\magnetic\code\node\Inc\Hardware) line 81 : 
#define M3D_DRDY  	HAL_GPIO_ReadPin(RM_DRY_GPIO_Port, RM_DRY_Pin)
//#define CS_L			GPIO_ResetBits(GPIOB, GPIO_Pin_12)
//#define CS_H			GPIO_SetBits(GPIOB, GPIO_Pin_12)

/// Configurations for Self test
main in main.c (F:\projects\git\Hardware\magnetic\code\node\Src) : 

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */
main in main.c (F:\projects\git\Hardware\magnetic\code\node\Src) : 
  SystemClock_Config();
  NVIC_SystemReset();


  /* USER CODE BEGIN SysInit */
main in main.c (F:\projects\git\Hardware\magnetic\code\node\Src) : 
	// Hardware_Init();
		HAL_GPIO_WritePin(I2C_MODE_GPIO_Port, I2C_MODE_Pin, GPIO_PIN_RESET);
  ThreeD3100_magic_init();
  MagneticInit();
	current_tick = HAL_GetTick();
MX_GPIO_Init in main.c (F:\projects\git\Hardware\magnetic\code\node\Src) : 
  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, RM_POWER_Pin|RM_CS_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(RM3100_MODE_EN_GPIO_Port, RM3100_MODE_EN_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LORA_A_GPIO_Port, LORA_A_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOE, LORA_B_Pin|LED_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pins : RM_POWER_Pin RM_CS_Pin */
  GPIO_InitStruct.Pin = RM_POWER_Pin|RM_CS_Pin;
node.htm (F:\projects\git\Hardware\magnetic\code\node\MDK-ARM\node) line 19 : 
</H3><UL>
 <LI><a href="#[1c]">ADC1_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[4]">BusFault_Handler</a> from stm32l4xx_it.o(i.BusFault_Handler) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[1e]">CAN1_RX0_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[1f]">CAN1_RX1_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[20]">CAN1_SCE_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[1d]">CAN1_TX_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[3b]">COMP_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[4b]">CRS_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[15]">DMA1_Channel1_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[16]">DMA1_Channel2_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[17]">DMA1_Channel3_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[18]">DMA1_Channel4_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[19]">DMA1_Channel5_IRQHandler</a> from stm32l4xx_it.o(i.DMA1_Channel5_IRQHandler) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[1a]">DMA1_Channel6_IRQHandler</a> from stm32l4xx_it.o(i.DMA1_Channel6_IRQHandler) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[1b]">DMA1_Channel7_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[36]">DMA2_Channel1_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[37]">DMA2_Channel2_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[38]">DMA2_Channel3_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[39]">DMA2_Channel4_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[3a]">DMA2_Channel5_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[3f]">DMA2_Channel6_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[40]">DMA2_Channel7_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[7]">DebugMon_Handler</a> from stm32l4xx_it.o(i.DebugMon_Handler) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[10]">EXTI0_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[30]">EXTI15_10_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[11]">EXTI1_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[12]">EXTI2_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[13]">EXTI3_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[14]">EXTI4_IRQHandler</a> from stm32l4xx_it.o(i.EXTI4_IRQHandler) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[21]">EXTI9_5_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[e]">FLASH_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[4a]">FPU_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[2]">HardFault_Handler</a> from stm32l4xx_it.o(i.HardFault_Handler) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[28]">I2C1_ER_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[27]">I2C1_EV_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[2a]">I2C2_ER_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[29]">I2C2_EV_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[44]">I2C3_ER_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[43]">I2C3_EV_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[48]">LCD_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[3c]">LPTIM1_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[3d]">LPTIM2_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[41]">LPUART1_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[3]">MemManage_Handler</a> from stm32l4xx_it.o(i.MemManage_Handler) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[1]">NMI_Handler</a> from stm32l4xx_it.o(i.NMI_Handler) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[b]">PVD_PVM_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[8]">PendSV_Handler</a> from stm32l4xx_it.o(i.PendSV_Handler) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[42]">QUADSPI_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[f]">RCC_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[49]">RNG_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[31]">RTC_Alarm_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[d]">RTC_WKUP_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[0]">Reset_Handler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[45]">SAI1_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[32]">SDMMC1_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[2b]">SPI1_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[2c]">SPI2_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[33]">SPI3_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[6]">SVC_Handler</a> from stm32l4xx_it.o(i.SVC_Handler) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[46]">SWPMI1_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[9]">SysTick_Handler</a> from stm32l4xx_it.o(i.SysTick_Handler) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[4d]">SystemInit</a> from system_stm32l4xx.o(i.SystemInit) referenced from startup_stm32l433xx.o(.text)
 <LI><a href="#[c]">TAMP_STAMP_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[22]">TIM1_BRK_TIM15_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[25]">TIM1_CC_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[24]">TIM1_TRG_COM_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[23]">TIM1_UP_TIM16_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[26]">TIM2_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[34]">TIM6_DAC_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[35]">TIM7_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[47]">TSC_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[4f]">UART_DMAAbortOnError</a> from stm32l4xx_hal_uart.o(i.UART_DMAAbortOnError) referenced from stm32l4xx_hal_uart.o(i.HAL_UART_IRQHandler)
 <LI><a href="#[52]">UART_DMAError</a> from stm32l4xx_hal_uart.o(i.UART_DMAError) referenced from stm32l4xx_hal_uart.o(i.HAL_UART_Receive_DMA)
 <LI><a href="#[50]">UART_DMAReceiveCplt</a> from stm32l4xx_hal_uart.o(i.UART_DMAReceiveCplt) referenced from stm32l4xx_hal_uart.o(i.HAL_UART_Receive_DMA)
 <LI><a href="#[51]">UART_DMARxHalfCplt</a> from stm32l4xx_hal_uart.o(i.UART_DMARxHalfCplt) referenced from stm32l4xx_hal_uart.o(i.HAL_UART_Receive_DMA)
 <LI><a href="#[2d]">USART1_IRQHandler</a> from stm32l4xx_it.o(i.USART1_IRQHandler) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[2e]">USART2_IRQHandler</a> from stm32l4xx_it.o(i.USART2_IRQHandler) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[2f]">USART3_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[3e]">USB_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[5]">UsageFault_Handler</a> from stm32l4xx_it.o(i.UsageFault_Handler) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[a]">WWDG_IRQHandler</a> from startup_stm32l433xx.o(.text) referenced from startup_stm32l433xx.o(RESET)
 <LI><a href="#[4e]">__main</a> from entry.o(.ARM.Collect$$$$00000000) referenced from startup_stm32l433xx.o(.text)
 <LI><a href="#[4c]">main</a> from main.o(i.main) referenced from entry9a.o(.ARM.Collect$$$$0000000B)
</UL>
node.htm (F:\projects\git\Hardware\magnetic\code\node\MDK-ARM\node) line 130 : 

<P><STRONG><a name="[0]"></a>Reset_Handler</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[1c]"></a>ADC1_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR><BR>[Calls]<UL><LI><a href="#[1c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ADC1_IRQHandler
node.htm (F:\projects\git\Hardware\magnetic\code\node\MDK-ARM\node) line 138 : 
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[1e]"></a>CAN1_RX0_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[1f]"></a>CAN1_RX1_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[20]"></a>CAN1_SCE_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[1d]"></a>CAN1_TX_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[3b]"></a>COMP_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[4b]"></a>CRS_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[15]"></a>DMA1_Channel1_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[16]"></a>DMA1_Channel2_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[17]"></a>DMA1_Channel3_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[18]"></a>DMA1_Channel4_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[1b]"></a>DMA1_Channel7_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[36]"></a>DMA2_Channel1_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[37]"></a>DMA2_Channel2_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[38]"></a>DMA2_Channel3_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[39]"></a>DMA2_Channel4_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[3a]"></a>DMA2_Channel5_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[3f]"></a>DMA2_Channel6_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[40]"></a>DMA2_Channel7_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[10]"></a>EXTI0_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[30]"></a>EXTI15_10_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[11]"></a>EXTI1_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[12]"></a>EXTI2_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[13]"></a>EXTI3_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[21]"></a>EXTI9_5_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[e]"></a>FLASH_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[4a]"></a>FPU_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[28]"></a>I2C1_ER_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[27]"></a>I2C1_EV_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[2a]"></a>I2C2_ER_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[29]"></a>I2C2_EV_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[44]"></a>I2C3_ER_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[43]"></a>I2C3_EV_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[48]"></a>LCD_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[3c]"></a>LPTIM1_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[3d]"></a>LPTIM2_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[41]"></a>LPUART1_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[b]"></a>PVD_PVM_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[42]"></a>QUADSPI_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[f]"></a>RCC_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[49]"></a>RNG_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[31]"></a>RTC_Alarm_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[d]"></a>RTC_WKUP_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[45]"></a>SAI1_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[32]"></a>SDMMC1_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[2b]"></a>SPI1_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[2c]"></a>SPI2_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[33]"></a>SPI3_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[46]"></a>SWPMI1_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[c]"></a>TAMP_STAMP_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[22]"></a>TIM1_BRK_TIM15_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[25]"></a>TIM1_CC_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[24]"></a>TIM1_TRG_COM_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[23]"></a>TIM1_UP_TIM16_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[26]"></a>TIM2_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[34]"></a>TIM6_DAC_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[35]"></a>TIM7_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[47]"></a>TSC_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[2f]"></a>USART3_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[3e]"></a>USB_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[a]"></a>WWDG_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32l433xx.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[55]"></a>__aeabi_uldivmod</STRONG> (Thumb, 98 bytes, Stack size 40 bytes, uldiv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = __aeabi_uldivmod
node.htm (F:\projects\git\Hardware\magnetic\code\node\MDK-ARM\node) line 429 : 
<P><STRONG><a name="[4]"></a>BusFault_Handler</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, stm32l4xx_it.o(i.BusFault_Handler))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[19]"></a>DMA1_Channel5_IRQHandler</STRONG> (Thumb, 10 bytes, Stack size 8 bytes, stm32l4xx_it.o(i.DMA1_Channel5_IRQHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = DMA1_Channel5_IRQHandler &rArr; HAL_DMA_IRQHandler
node.htm (F:\projects\git\Hardware\magnetic\code\node\MDK-ARM\node) line 436 : 
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[1a]"></a>DMA1_Channel6_IRQHandler</STRONG> (Thumb, 10 bytes, Stack size 8 bytes, stm32l4xx_it.o(i.DMA1_Channel6_IRQHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = DMA1_Channel6_IRQHandler &rArr; HAL_DMA_IRQHandler
node.htm (F:\projects\git\Hardware\magnetic\code\node\MDK-ARM\node) line 443 : 
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[7]"></a>DebugMon_Handler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, stm32l4xx_it.o(i.DebugMon_Handler))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[14]"></a>EXTI4_IRQHandler</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, stm32l4xx_it.o(i.EXTI4_IRQHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = EXTI4_IRQHandler &rArr; HAL_GPIO_EXTI_IRQHandler
node.htm (F:\projects\git\Hardware\magnetic\code\node\MDK-ARM\node) line 453 : 
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[97]"></a>Error_Handler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, main.o(i.Error_Handler))
<BR><BR>[Called By]<UL><LI><a href="#[92]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HAL_UART_MspInit
node.htm (F:\projects\git\Hardware\magnetic\code\node\MDK-ARM\node) line 822 : 
<P><STRONG><a name="[2]"></a>HardFault_Handler</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, stm32l4xx_it.o(i.HardFault_Handler))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[a3]"></a>MagneticGet</STRONG> (Thumb, 78 bytes, Stack size 8 bytes, filter.o(i.MagneticGet))
<BR><BR>[Stack]<UL><LI>Max Depth = 232<LI>Call Chain = MagneticGet &rArr; ThreeD3100_magic_GetData &rArr; SPI_Read_M3D3100 &rArr; SPI_WriteByte &rArr; HAL_SPI_TransmitReceive &rArr; SPI_EndRxTxTransaction &rArr; SPI_WaitFlagStateUntilTimeout
node.htm (F:\projects\git\Hardware\magnetic\code\node\MDK-ARM\node) line 841 : 
<P><STRONG><a name="[3]"></a>MemManage_Handler</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, stm32l4xx_it.o(i.MemManage_Handler))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[1]"></a>NMI_Handler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, stm32l4xx_it.o(i.NMI_Handler))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[8]"></a>PendSV_Handler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, stm32l4xx_it.o(i.PendSV_Handler))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[b0]"></a>SPI2_Init</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, mag3d3100.o(i.SPI2_Init))
<BR><BR>[Called By]<UL><LI><a href="#[af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ThreeD3100_magic_init
node.htm (F:\projects\git\Hardware\magnetic\code\node\MDK-ARM\node) line 885 : 
<P><STRONG><a name="[6]"></a>SVC_Handler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, stm32l4xx_it.o(i.SVC_Handler))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[9]"></a>SysTick_Handler</STRONG> (Thumb, 8 bytes, Stack size 8 bytes, stm32l4xx_it.o(i.SysTick_Handler))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = SysTick_Handler
node.htm (F:\projects\git\Hardware\magnetic\code\node\MDK-ARM\node) line 892 : 
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[ad]"></a>SystemClock_Config</STRONG> (Thumb, 162 bytes, Stack size 192 bytes, main.o(i.SystemClock_Config))
<BR><BR>[Stack]<UL><LI>Max Depth = 288<LI>Call Chain = SystemClock_Config &rArr; HAL_RCC_OscConfig &rArr; HAL_InitTick &rArr; HAL_NVIC_SetPriority &rArr; __NVIC_SetPriority
node.htm (F:\projects\git\Hardware\magnetic\code\node\MDK-ARM\node) line 974 : 
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[2e]"></a>USART2_IRQHandler</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, stm32l4xx_it.o(i.USART2_IRQHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 76<LI>Call Chain = USART2_IRQHandler &rArr; UsartReceive_IDLE &rArr; HAL_UART_Receive_DMA &rArr; HAL_DMA_Start_IT &rArr; DMA_SetConfig
node.htm (F:\projects\git\Hardware\magnetic\code\node\MDK-ARM\node) line 982 : 
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[5]"></a>UsageFault_Handler</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, stm32l4xx_it.o(i.UsageFault_Handler))
<BR>[Address Reference Count : 1]<UL><LI> startup_stm32l433xx.o(RESET)
</UL>
<P><STRONG><a name="[b8]"></a>UsartReceive_IDLE</STRONG> (Thumb, 238 bytes, Stack size 16 bytes, bsp.o(i.UsartReceive_IDLE))
<BR><BR>[Stack]<UL><LI>Max Depth = 68<LI>Call Chain = UsartReceive_IDLE &rArr; HAL_UART_Receive_DMA &rArr; HAL_DMA_Start_IT &rArr; DMA_SetConfig
sensor.c (F:\projects\git\Hardware\magnetic\code\node\Src\Driver) line 27 : 

void reset_timer (void)
{
   flag = 0;
   temptime = HAL_GetTick();
sensor_process in sensor.c (F:\projects\git\Hardware\magnetic\code\node\Src\Driver) : 
//            //time_to_send = cycle_time;
//            reset_timer();
//            requestSingleMeasurement ();
//        }

stm32l4xx_hal.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 121 : 
        (++) Time base configuration function (HAL_InitTick ()) is called automatically
             at the beginning of the program after reset by HAL_Init() or at any time
             when clock is configured, by HAL_RCC_ClockConfig().
        (++) Source of time base is configured  to generate interrupts at regular
             time intervals. Care must be taken if HAL_Delay() is called from a
stm32l4xx_hal.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 140 : 
  *
  * @note   HAL_Init() function is called at the beginning of program after reset and before
  *         the clock configuration.
  *
  * @note   In the default implementation the System Timer (Systick) is used as source of time base.
  *         The Systick configuration is based on MSI clock, as MSI is the clock
  *         used after a system Reset and the NVIC configuration is set to Priority group 4.
  *         Once done, time base tick starts incrementing: the tick variable counter is incremented
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
HAL_Init in stm32l4xx_hal.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Configure Flash prefetch, Instruction cache, Data cache */
  /* Default configuration at reset is:                      */
  /* - Prefetch disabled                                     */
  /* - Instruction cache enabled                             */
  /* - Data cache enabled                                    */
HAL_Init in stm32l4xx_hal.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
  {
    status = HAL_ERROR;
HAL_DeInit in stm32l4xx_hal.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
{
  /* Reset of all peripherals */
  __HAL_RCC_APB1_FORCE_RESET();
  __HAL_RCC_APB1_RELEASE_RESET();

  __HAL_RCC_APB2_FORCE_RESET();
  __HAL_RCC_APB2_RELEASE_RESET();

  __HAL_RCC_AHB1_FORCE_RESET();
  __HAL_RCC_AHB1_RELEASE_RESET();

  __HAL_RCC_AHB2_FORCE_RESET();
  __HAL_RCC_AHB2_RELEASE_RESET();

  __HAL_RCC_AHB3_FORCE_RESET();
  __HAL_RCC_AHB3_RELEASE_RESET();

  /* De-Init the low level hardware */
  HAL_MspDeInit();
stm32l4xx_hal.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 247 : 
  * @note This function is called  automatically at the beginning of program after
  *       reset by HAL_Init() or at any time when clock is reconfigured  by HAL_RCC_ClockConfig().
  * @note In the default implementation, SysTick timer is the source of time base.
  *       It is used to generate interrupts at regular time intervals.
  *       Care must be taken if HAL_Delay() is called from a peripheral ISR process,
stm32l4xx_hal.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 594 : 
  * @note   As long as SRAM2 is not erased the SRAM2ER bit will be set.
  *         This bit is automatically reset at the end of the SRAM2 erase operation.
  * @retval None
  */
void HAL_SYSCFG_SRAM2Erase(void)
stm32l4xx_hal.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 428 : 
  * @param  __SRAM2WRP__  This parameter can be a combination of values of @ref SYSCFG_SRAM2WRP
  * @note   Write protection can only be disabled by a system reset
  */
#define __HAL_SYSCFG_SRAM2_WRP_1_31_ENABLE(__SRAM2WRP__)    do {assert_param(IS_SYSCFG_SRAM2WRP_PAGE((__SRAM2WRP__)));\
                                                                SET_BIT(SYSCFG->SWPR, (__SRAM2WRP__));\
stm32l4xx_hal.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 437 : 
  * @param  __SRAM2WRP__  This parameter can be a combination of values of @ref SYSCFG_SRAM2WRP_32_63
  * @note   Write protection can only be disabled by a system reset
  */
#define __HAL_SYSCFG_SRAM2_WRP_32_63_ENABLE(__SRAM2WRP__)   do {assert_param(IS_SYSCFG_SRAM2WRP_PAGE((__SRAM2WRP__)));\
                                                                SET_BIT(SYSCFG->SWPR2, (__SRAM2WRP__));\
stm32l4xx_hal.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 469 : 
  *         Enable and lock the connection of Flash ECC error connection to TIM1/8/15/16/17 Break input.
  * @note   The selected configuration is locked and can be unlocked only by system reset.
  */
#define __HAL_SYSCFG_BREAK_ECC_LOCK()        SET_BIT(SYSCFG->CFGR2, SYSCFG_CFGR2_ECCL)

stm32l4xx_hal.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 475 : 
  *         Enable and lock the connection of Cortex-M4 LOCKUP (Hardfault) output to TIM1/8/15/16/17 Break input.
  * @note   The selected configuration is locked and can be unlocked only by system reset.
  */
#define __HAL_SYSCFG_BREAK_LOCKUP_LOCK()     SET_BIT(SYSCFG->CFGR2, SYSCFG_CFGR2_CLL)

stm32l4xx_hal.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 481 : 
  *         Enable and lock the PVD connection to Timer1/8/15/16/17 Break input, as well as the PVDE and PLS[2:0] in the PWR_CR2 register.
  * @note   The selected configuration is locked and can be unlocked only by system reset.
  */
#define __HAL_SYSCFG_BREAK_PVD_LOCK()        SET_BIT(SYSCFG->CFGR2, SYSCFG_CFGR2_PVDL)

stm32l4xx_hal.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 487 : 
  *         Enable and lock the SRAM2 parity error signal connection to TIM1/8/15/16/17 Break input.
  * @note   The selected configuration is locked and can be unlocked by system reset.
  */
#define __HAL_SYSCFG_BREAK_SRAM2PARITY_LOCK()  SET_BIT(SYSCFG->CFGR2, SYSCFG_CFGR2_SPL)

stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 185 : 
    (#) Disable the ADC interface
      (++) ADC clock can be hard reset and disabled at RCC top level.
        (++) Hard reset of ADC peripherals
             using macro __ADCx_FORCE_RESET(), __ADCx_RELEASE_RESET().
        (++) ADC clock disable
             using the equivalent macro/functions as configuration step.
             (+++) Example:
stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 239 : 

     Use function @ref HAL_ADC_UnRegisterCallback to reset a callback to the default
     weak function.
    [..]

stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 245 : 
     and the Callback ID.
     This function allows to reset following callbacks:
       (+) ConvCpltCallback               : ADC conversion complete callback
       (+) ConvHalfCpltCallback           : ADC conversion DMA half-transfer callback
       (+) LevelOutOfWindowCallback       : ADC analog watchdog 1 callback
stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 259 : 

     By default, after the @ref HAL_ADC_Init() and when the state is @ref HAL_ADC_STATE_RESET
     all callbacks are set to the corresponding weak functions:
     examples @ref HAL_ADC_ConvCpltCallback(), @ref HAL_ADC_ErrorCallback().
     Exception done for MspInit and MspDeInit functions that are
     reset to the legacy weak functions in the @ref HAL_ADC_Init()/ @ref HAL_ADC_DeInit() only when
     these callbacks are null (not registered beforehand).
    [..]

stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 273 : 
     Exception done MspInit/MspDeInit functions that can be registered/unregistered
     in @ref HAL_ADC_STATE_READY or @ref HAL_ADC_STATE_RESET state,
     thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
    [..]

stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 381 : 
  *         This function initializes the ADC MSP (HAL_ADC_MspInit()) only when
  *         coming from ADC state reset. Following calls to this function can
  *         be used to reconfigure some parameters of ADC_InitTypeDef
  *         structure on the fly, without modifying MSP configuration. If ADC
  *         MSP has to be modified again, HAL_ADC_DeInit() must be called
HAL_ADC_Init in stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
  {
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    /* Init the ADC Callback settings */
HAL_ADC_Init in stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Verification that ADC voltage regulator is correctly enabled, whether    */
  /* or not ADC is coming from state reset (if any potential problem of       */
  /* clocking, voltage regulator would not be enabled).                       */
  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
  {
HAL_ADC_Init in stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      {
        /* Reset configuration of ADC common register CCR:                      */
        /*                                                                      */
        /*   - ADC clock mode and ACC prescaler (CKMODE and PRESC bits)are set  */
        /*     according to adc->Init.ClockPrescaler. It selects the clock      */
HAL_ADC_Init in stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
        /*                                                                      */
        /* Some parameters of this register are not reset, since they are set   */
        /* by other functions and must be kept in case of usage of this         */
        /* function on the fly (update of a parameter of ADC_InitTypeDef        */
        /* without needing to reconfigure all other ADC groups/channels         */
HAL_ADC_Init in stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
        assert_param(IS_ADC_TRIGGERED_OVERSAMPLING_MODE(hadc->Init.Oversampling.TriggeredMode));
        assert_param(IS_ADC_REGOVERSAMPLING_MODE(hadc->Init.Oversampling.OversamplingStopReset));

        /* Configuration of Oversampler:                                      */
        /*  - Oversampling Ratio                                              */
HAL_ADC_Init in stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
                   hadc->Init.Oversampling.TriggeredMode |
                   hadc->Init.Oversampling.OversamplingStopReset
                  );
      }
      else
stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 689 : 
/**
  * @brief  Deinitialize the ADC peripheral registers to their default reset
  *         values, with deinitialization of the ADC MSP.
  * @note   For devices with several ADCs: reset of ADC common registers is done
  *         only if all ADCs sharing the same common group are disabled.
  *         (function "HAL_ADC_MspDeInit()" is also called under the same conditions:
  *         all ADC instances use the same core clock at RCC level, disabling
  *         the core clock reset all ADC instances).
  *         If this is not the case, reset of these common parameters reset is
  *         bypassed without error reporting: it can be the intended behavior in
  *         case of reset of a single ADC while the other ADCs sharing the same
  *         common group is still running.
  * @note   By default, HAL_ADC_DeInit() set ADC in mode deep power-down:
  *         this saves more power by reducing leakage currents
HAL_ADC_DeInit in stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Disable ADC peripheral if conversions are effectively stopped            */
  /* Flush register JSQR: reset the queue sequencer when injected             */
  /* queue sequencer is enabled and ADC disabled.                             */
  /* The software and hardware triggers of the injected sequence are both     */
  /* internally disabled just after the completion of the last valid          */
HAL_ADC_DeInit in stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /*       perform deinitialization anyway and it is up user code in          */
  /*       in HAL_ADC_MspDeInit() to reset the ADC peripheral using           */
  /*       system RCC hard reset.                                             */

  /* ========== Reset ADC registers ========== */
  /* Reset register IER */
  __HAL_ADC_DISABLE_IT(hadc, (ADC_IT_AWD3  | ADC_IT_AWD2 | ADC_IT_AWD1 |
                              ADC_IT_JQOVF | ADC_IT_OVR  |
                              ADC_IT_JEOS  | ADC_IT_JEOC |
HAL_ADC_DeInit in stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset register ISR */
  __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_AWD3  | ADC_FLAG_AWD2 | ADC_FLAG_AWD1 |
                              ADC_FLAG_JQOVF | ADC_FLAG_OVR  |
                              ADC_FLAG_JEOS  | ADC_FLAG_JEOC |
HAL_ADC_DeInit in stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset register CR */
  /* Bits ADC_CR_JADSTP, ADC_CR_ADSTP, ADC_CR_JADSTART, ADC_CR_ADSTART,
     ADC_CR_ADCAL, ADC_CR_ADDIS and ADC_CR_ADEN are in access mode "read-set":
     no direct reset applicable.
     Update CR register to reset value where doable by software */
  CLEAR_BIT(hadc->Instance->CR, ADC_CR_ADVREGEN | ADC_CR_ADCALDIF);
  SET_BIT(hadc->Instance->CR, ADC_CR_DEEPPWD);

  /* Reset register CFGR */
  CLEAR_BIT(hadc->Instance->CFGR, ADC_CFGR_FIELDS);
  SET_BIT(hadc->Instance->CFGR, ADC_CFGR_JQDIS);

  /* Reset register CFGR2 */
  CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSM  | ADC_CFGR2_TROVS   | ADC_CFGR2_OVSS |
            ADC_CFGR2_OVSR  | ADC_CFGR2_JOVSE | ADC_CFGR2_ROVSE);

  /* Reset register SMPR1 */
  CLEAR_BIT(hadc->Instance->SMPR1, ADC_SMPR1_FIELDS);

  /* Reset register SMPR2 */
  CLEAR_BIT(hadc->Instance->SMPR2, ADC_SMPR2_SMP18 | ADC_SMPR2_SMP17 | ADC_SMPR2_SMP16 |
            ADC_SMPR2_SMP15 | ADC_SMPR2_SMP14 | ADC_SMPR2_SMP13 |
            ADC_SMPR2_SMP12 | ADC_SMPR2_SMP11 | ADC_SMPR2_SMP10);

  /* Reset register TR1 */
  CLEAR_BIT(hadc->Instance->TR1, ADC_TR1_HT1 | ADC_TR1_LT1);

  /* Reset register TR2 */
  CLEAR_BIT(hadc->Instance->TR2, ADC_TR2_HT2 | ADC_TR2_LT2);

  /* Reset register TR3 */
  CLEAR_BIT(hadc->Instance->TR3, ADC_TR3_HT3 | ADC_TR3_LT3);

  /* Reset register SQR1 */
  CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_SQ4 | ADC_SQR1_SQ3 | ADC_SQR1_SQ2 |
            ADC_SQR1_SQ1 | ADC_SQR1_L);

  /* Reset register SQR2 */
  CLEAR_BIT(hadc->Instance->SQR2, ADC_SQR2_SQ9 | ADC_SQR2_SQ8 | ADC_SQR2_SQ7 |
            ADC_SQR2_SQ6 | ADC_SQR2_SQ5);

  /* Reset register SQR3 */
  CLEAR_BIT(hadc->Instance->SQR3, ADC_SQR3_SQ14 | ADC_SQR3_SQ13 | ADC_SQR3_SQ12 |
            ADC_SQR3_SQ11 | ADC_SQR3_SQ10);

  /* Reset register SQR4 */
  CLEAR_BIT(hadc->Instance->SQR4, ADC_SQR4_SQ16 | ADC_SQR4_SQ15);

  /* Register JSQR was reset when the ADC was disabled */

  /* Reset register DR */
  /* bits in access mode read only, no direct reset applicable*/

  /* Reset register OFR1 */
  CLEAR_BIT(hadc->Instance->OFR1, ADC_OFR1_OFFSET1_EN | ADC_OFR1_OFFSET1_CH | ADC_OFR1_OFFSET1);
  /* Reset register OFR2 */
  CLEAR_BIT(hadc->Instance->OFR2, ADC_OFR2_OFFSET2_EN | ADC_OFR2_OFFSET2_CH | ADC_OFR2_OFFSET2);
  /* Reset register OFR3 */
  CLEAR_BIT(hadc->Instance->OFR3, ADC_OFR3_OFFSET3_EN | ADC_OFR3_OFFSET3_CH | ADC_OFR3_OFFSET3);
  /* Reset register OFR4 */
  CLEAR_BIT(hadc->Instance->OFR4, ADC_OFR4_OFFSET4_EN | ADC_OFR4_OFFSET4_CH | ADC_OFR4_OFFSET4);

  /* Reset registers JDR1, JDR2, JDR3, JDR4 */
  /* bits in access mode read only, no direct reset applicable*/

  /* Reset register AWD2CR */
  CLEAR_BIT(hadc->Instance->AWD2CR, ADC_AWD2CR_AWD2CH);

  /* Reset register AWD3CR */
  CLEAR_BIT(hadc->Instance->AWD3CR, ADC_AWD3CR_AWD3CH);

  /* Reset register DIFSEL */
  CLEAR_BIT(hadc->Instance->DIFSEL, ADC_DIFSEL_DIFSEL);

  /* Reset register CALFACT */
  CLEAR_BIT(hadc->Instance->CALFACT, ADC_CALFACT_CALFACT_D | ADC_CALFACT_CALFACT_S);


  /* ========== Reset common ADC registers ========== */

  /* Software is allowed to change common parameters only when all the other
     ADCs are disabled.   */
HAL_ADC_DeInit in stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Reset configuration of ADC common register CCR:
      - clock mode: CKMODE, PRESCEN
      - multimode related parameters (when this feature is available): MDMA,
        DMACFG, DELAY, DUAL (set by HAL_ADCEx_MultiModeConfigChannel() API)
HAL_ADC_DeInit in stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
     For example:
    __HAL_RCC_ADC_FORCE_RESET();
    __HAL_RCC_ADC_RELEASE_RESET();
    __HAL_RCC_ADC_CLK_DISABLE();

    Keep in mind that all ADCs use the same clock: disabling
    the clock will reset all ADCs.

  */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
HAL_ADC_DeInit in stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset injected channel configuration parameters */
  hadc->InjectionConfig.ContextQueue = 0;
  hadc->InjectionConfig.ChannelCount = 0;

  /* Set ADC state */
  hadc->State = HAL_ADC_STATE_RESET;

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 922 : 
  * @note   All ADC instances use the same core clock at RCC level, disabling
  *         the core clock reset all ADC instances).
  * @retval None
  */
__weak void HAL_ADC_MspDeInit(ADC_HandleTypeDef *hadc)
HAL_ADC_RegisterCallback in stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (HAL_ADC_STATE_RESET == hadc->State)
  {
    switch (CallbackID)
    {
HAL_ADC_UnRegisterCallback in stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (HAL_ADC_STATE_RESET == hadc->State)
  {
    switch (CallbackID)
    {
HAL_ADC_Start in stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if defined(ADC_MULTIMODE_SUPPORT)
      /* Reset HAL_ADC_STATE_MULTIMODE_SLAVE bit
        - if ADC instance is master or if multimode feature is not available
        - if multimode setting is disabled (ADC instance slave in independent mode) */
      if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
HAL_ADC_Start in stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      {
        /* Reset ADC error code fields related to regular conversions only */
        CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));
      }
      else
      {
        /* Reset all ADC error code fields */
        ADC_CLEAR_ERRORCODE(hadc);
      }

HAL_ADC_Start in stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
        /* if Master ADC JAUTO bit is set, update Slave State in setting
           HAL_ADC_STATE_INJ_BUSY bit and in resetting HAL_ADC_STATE_INJ_EOC bit */
        tmpADC_Master = __LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance);
        if (READ_BIT(tmpADC_Master->CFGR, ADC_CFGR_JAUTO) != 0UL)
        {
stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 1395 : 
  *         parameter "EOCSelection" set to ADC_EOC_SINGLE_CONV).
  *         In this case, DMA resets the flag EOC and polling cannot be
  *         performed on each conversion. Nevertheless, polling can still
  *         be performed on the complete sequence (ADC init
  *         parameter "EOCSelection" set to ADC_EOC_SEQ_CONV).
stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 1575 : 
  * @note   The relevant flag is cleared if found to be set, except for ADC_FLAG_OVR.
  *         Indeed, the latter is reset only if hadc->Init.Overrun field is set
  *         to ADC_OVR_DATA_OVERWRITTEN. Otherwise, data register may be potentially overwritten
  *         by a new converted data as soon as OVR is cleared.
  *         To reset OVR flag once the preserved data is retrieved, the user can resort
  *         to macro __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
  * @retval HAL status
  */
stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 1715 : 
  *         For ADC Master, ADC is enabled and multimode conversion is started.
  * @note   To guarantee a proper reset of all interruptions once all the needed
  *         conversions are obtained, HAL_ADC_Stop_IT() must be called to ensure
  *         a correct stop of the IT-based conversions.
  * @note   By default, HAL_ADC_Start_IT() does not enable the End Of Sampling
HAL_ADC_Start_IT in stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if defined(ADC_MULTIMODE_SUPPORT)
      /* Reset HAL_ADC_STATE_MULTIMODE_SLAVE bit
        - if ADC instance is master or if multimode feature is not available
        - if multimode setting is disabled (ADC instance slave in independent mode) */
      if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
HAL_ADC_Start_IT in stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      {
        /* Reset ADC error code fields related to regular conversions only */
        CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));
      }
      else
      {
        /* Reset all ADC error code fields */
        ADC_CLEAR_ERRORCODE(hadc);
      }

HAL_ADC_Start_IT in stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
          /* First, update Slave State in setting HAL_ADC_STATE_INJ_BUSY bit
             and in resetting HAL_ADC_STATE_INJ_EOC bit */
          ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
          /* Next, set Slave injected interruptions */
          switch (hadc->Init.EOCSelection)
HAL_ADC_Start_DMA in stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if defined(ADC_MULTIMODE_SUPPORT)
        /* Reset HAL_ADC_STATE_MULTIMODE_SLAVE bit
          - if ADC instance is master or if multimode feature is not available
          - if multimode setting is disabled (ADC instance slave in independent mode) */
        if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
HAL_ADC_Start_DMA in stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
        {
          /* Reset ADC error code fields related to regular conversions only */
          CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));
        }
        else
        {
          /* Reset all ADC error code fields */
          ADC_CLEAR_ERRORCODE(hadc);
        }

HAL_ADC_IRQHandler in stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
        /* Particular case if injected contexts queue is enabled:             */
        /* when the last context has been fully processed, JSQR is reset      */
        /* by the hardware. Even if no injected conversion is planned to come */
        /* (queue empty, triggers are ignored), it can start again            */
        /* immediately after setting a new context (JADSTART is still set).   */
HAL_ADC_IRQHandler in stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      /* Note: In case of overrun, ADC conversion data is preserved until     */
      /*       flag OVR is reset.                                             */
      /*       Therefore, old ADC conversion data can be retrieved in         */
      /*       function "HAL_ADC_ErrorCallback()".                            */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 2691 : 
  *         some parameters of structure "ADC_ChannelConfTypeDef" on the fly,
  *         without resetting the ADC.
  *         The setting of these parameters is conditioned to ADC state:
  *         Refer to comments of structure "ADC_ChannelConfTypeDef".
  * @param hadc ADC handle
HAL_ADC_ConfigChannel in stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* if ROVSE is set, the value of the OFFSETy_EN bit in ADCx_OFRy register is
     ignored (considered as reset) */
  assert_param(!((sConfig->OffsetNumber != ADC_OFFSET_NONE) && (hadc->Init.OversamplingMode == ENABLE)));

  /* Verification of channel number */
stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 2929 : 
  *         calls to this function can be used to reconfigure some parameters
  *         of structure "ADC_AnalogWDGConfTypeDef" on the fly, without resetting
  *         the ADC.
  *         The setting of these parameters is conditioned to ADC state.
  *         For parameters constraints, see comments of structure
ADC_Enable in stm32l4xx_hal_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      /*  If ADEN bit is set less than 4 ADC clock cycles after the ADCAL bit
          has been cleared (after a calibration), ADEN bit is reset by the
          calibration logic.
          The workaround is to continue setting ADEN until ADRDY is becomes 1.
          Additionally, ADC_ENABLE_TIMEOUT is defined to encompass this
{anonADC_OversamplingTypeDef} in stm32l4xx_hal_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) : 

  uint32_t OversamplingStopReset;         /*!< Selects the regular oversampling mode.
                                               The oversampling is either temporary stopped or reset upon an injected
                                               sequence interruption.
                                               If oversampling is enabled on both regular and injected groups, this parameter
                                               is discarded and forced to setting "ADC_REGOVERSAMPLING_RESUMED_MODE"
stm32l4xx_hal_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 320 : 
/* States of ADC global scope */
#define HAL_ADC_STATE_RESET             (0x00000000UL)   /*!< ADC not yet initialized or disabled */
#define HAL_ADC_STATE_READY             (0x00000001UL)   /*!< ADC peripheral ready for use */
#define HAL_ADC_STATE_BUSY_INTERNAL     (0x00000002UL)   /*!< ADC is busy due to an internal process (initialization, calibration) */
#define HAL_ADC_STATE_TIMEOUT           (0x00000004UL)   /*!< TimeOut occurrence */
stm32l4xx_hal_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 797 : 
  * @param __HANDLE__ ADC handle
  * @retval SET (ADC enabled) or RESET (ADC disabled)
  */
#define ADC_IS_ENABLE(__HANDLE__)                                                    \
       (( ((((__HANDLE__)->Instance->CR) & (ADC_CR_ADEN | ADC_CR_ADDIS)) == ADC_CR_ADEN) && \
          ((((__HANDLE__)->Instance->ISR) & ADC_FLAG_RDY) == ADC_FLAG_RDY)                  \
        ) ? SET : RESET)

/**
  * @brief Check if conversion is on going on regular group.
stm32l4xx_hal_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 825 : 
  * @param __ADC_VALUE__ value checked against the resolution.
  * @retval SET (__ADC_VALUE__ in line with __RESOLUTION__) or RESET (__ADC_VALUE__ not in line with __RESOLUTION__)
  */
#define IS_ADC_RANGE(__RESOLUTION__, __ADC_VALUE__) \
  ((__ADC_VALUE__) <= __LL_ADC_DIGITAL_SCALE(__RESOLUTION__))
stm32l4xx_hal_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 833 : 
  * @param __LENGTH__ number of programmed conversions.
  * @retval SET (__LENGTH__ is within the maximum number of possible programmable regular conversions) or RESET (__LENGTH__ is null or too large)
  */
#define IS_ADC_REGULAR_NB_CONV(__LENGTH__) (((__LENGTH__) >= (1UL)) && ((__LENGTH__) <= (16UL)))

stm32l4xx_hal_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 841 : 
  * @param NUMBER number of scheduled regular conversions in discontinuous mode.
  * @retval SET (NUMBER is within the maximum number of regular conversions in discontinuous mode) or RESET (NUMBER is null or too large)
  */
#define IS_ADC_REGULAR_DISCONT_NUMBER(NUMBER) (((NUMBER) >= (1UL)) && ((NUMBER) <= (8UL)))

stm32l4xx_hal_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 849 : 
  * @param __ADC_CLOCK__ programmed ADC clock.
  * @retval SET (__ADC_CLOCK__ is a valid value) or RESET (__ADC_CLOCK__ is invalid)
  */
#define IS_ADC_CLOCKPRESCALER(__ADC_CLOCK__) (((__ADC_CLOCK__) == ADC_CLOCK_SYNC_PCLK_DIV1) || \
                                              ((__ADC_CLOCK__) == ADC_CLOCK_SYNC_PCLK_DIV2) || \
stm32l4xx_hal_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 870 : 
  * @param __RESOLUTION__ programmed ADC resolution.
  * @retval SET (__RESOLUTION__ is a valid value) or RESET (__RESOLUTION__ is invalid)
  */
#define IS_ADC_RESOLUTION(__RESOLUTION__) (((__RESOLUTION__) == ADC_RESOLUTION_12B) || \
                                           ((__RESOLUTION__) == ADC_RESOLUTION_10B) || \
stm32l4xx_hal_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 880 : 
  * @param __RESOLUTION__ programmed ADC resolution when limited to 6 or 8 bits.
  * @retval SET (__RESOLUTION__ is a valid value) or RESET (__RESOLUTION__ is invalid)
  */
#define IS_ADC_RESOLUTION_8_6_BITS(__RESOLUTION__) (((__RESOLUTION__) == ADC_RESOLUTION_8B) || \
                                                    ((__RESOLUTION__) == ADC_RESOLUTION_6B)   )
stm32l4xx_hal_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 888 : 
  * @param __ALIGN__ programmed ADC converted data alignment.
  * @retval SET (__ALIGN__ is a valid value) or RESET (__ALIGN__ is invalid)
  */
#define IS_ADC_DATA_ALIGN(__ALIGN__) (((__ALIGN__) == ADC_DATAALIGN_RIGHT) || \
                                      ((__ALIGN__) == ADC_DATAALIGN_LEFT)    )
stm32l4xx_hal_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 896 : 
  * @param __SCAN_MODE__ programmed ADC scan mode.
  * @retval SET (__SCAN_MODE__ is valid) or RESET (__SCAN_MODE__ is invalid)
  */
#define IS_ADC_SCAN_MODE(__SCAN_MODE__) (((__SCAN_MODE__) == ADC_SCAN_DISABLE) || \
                                         ((__SCAN_MODE__) == ADC_SCAN_ENABLE)    )
stm32l4xx_hal_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 904 : 
  * @param __EDGE__ programmed ADC edge trigger setting.
  * @retval SET (__EDGE__ is a valid value) or RESET (__EDGE__ is invalid)
  */
#define IS_ADC_EXTTRIG_EDGE(__EDGE__) (((__EDGE__) == ADC_EXTERNALTRIGCONVEDGE_NONE)         || \
                                       ((__EDGE__) == ADC_EXTERNALTRIGCONVEDGE_RISING)       || \
stm32l4xx_hal_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 915 : 
  * @param __REGTRIG__ programmed ADC regular conversions external trigger.
  * @retval SET (__REGTRIG__ is a valid value) or RESET (__REGTRIG__ is invalid)
  */
#define IS_ADC_EXTTRIG(__HANDLE__, __REGTRIG__) (((__REGTRIG__) == ADC_EXTERNALTRIG_T1_CC1)   || \
                                                 ((__REGTRIG__) == ADC_EXTERNALTRIG_T1_CC2)   || \
stm32l4xx_hal_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 938 : 
  * @param __EOC_SELECTION__ converted data availability check.
  * @retval SET (__EOC_SELECTION__ is a valid value) or RESET (__EOC_SELECTION__ is invalid)
  */
#define IS_ADC_EOC_SELECTION(__EOC_SELECTION__) (((__EOC_SELECTION__) == ADC_EOC_SINGLE_CONV)    || \
                                                 ((__EOC_SELECTION__) == ADC_EOC_SEQ_CONV)  )
stm32l4xx_hal_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 946 : 
  * @param __OVR__ ADC regular conversions overrun handling.
  * @retval SET (__OVR__ is a valid value) or RESET (__OVR__ is invalid)
  */
#define IS_ADC_OVERRUN(__OVR__) (((__OVR__) == ADC_OVR_DATA_PRESERVED)  || \
                                 ((__OVR__) == ADC_OVR_DATA_OVERWRITTEN)  )
stm32l4xx_hal_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 954 : 
  * @param __TIME__ ADC conversions sampling time.
  * @retval SET (__TIME__ is a valid value) or RESET (__TIME__ is invalid)
  */
#if defined(ADC_SMPR1_SMPPLUS)
#define IS_ADC_SAMPLE_TIME(__TIME__) (((__TIME__) == ADC_SAMPLETIME_2CYCLES_5)   || \
stm32l4xx_hal_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 980 : 
  * @param  __CHANNEL__ programmed ADC regular channel.
  * @retval SET (__CHANNEL__ is valid) or RESET (__CHANNEL__ is invalid)
  */
#define IS_ADC_REGULAR_RANK(__CHANNEL__) (((__CHANNEL__) == ADC_REGULAR_RANK_1 ) || \
                                          ((__CHANNEL__) == ADC_REGULAR_RANK_2 ) || \
stm32l4xx_hal_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1040 : 

/** @brief  Reset ADC handle state.
  * @param __HANDLE__ ADC handle
  * @retval None
  */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
#define __HAL_ADC_RESET_HANDLE_STATE(__HANDLE__)                               \
  do{                                                                          \
    (__HANDLE__)->State = HAL_ADC_STATE_RESET;                                 \
    (__HANDLE__)->MspInitCallback = NULL;                                      \
    (__HANDLE__)->MspDeInitCallback = NULL;                                    \
  } while(0)
#else
#define __HAL_ADC_RESET_HANDLE_STATE(__HANDLE__)                               \
  ((__HANDLE__)->State = HAL_ADC_STATE_RESET)
#endif

/**
stm32l4xx_hal_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1113 : 
  *            @arg @ref ADC_IT_JQOVF  ADC Injected Context Queue Overflow interrupt source.
  * @retval State of interruption (SET or RESET)
  */
#define __HAL_ADC_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)                     \
  (((__HANDLE__)->Instance->IER & (__INTERRUPT__)) == (__INTERRUPT__))
HAL_ADCEx_InjectedStart in stm32l4xx_hal_adc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
       resort to HAL_ADCEx_DisableInjectedQueue() API to set JQDIS.
       - or (if JQDIS is intentionally reset) since JEXTEN = 0 which means
         the queue is empty */
    tmp_config_injected_queue = READ_BIT(hadc->Instance->CFGR, ADC_CFGR_JQDIS);

HAL_ADCEx_InjectedStart in stm32l4xx_hal_adc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      {
        /* Reset ADC error code field related to injected conversions only */
        CLEAR_BIT(hadc->ErrorCode, HAL_ADC_ERROR_JQOVF);
      }
      else
HAL_ADCEx_InjectedStart in stm32l4xx_hal_adc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if defined(ADC_MULTIMODE_SUPPORT)
      /* Reset HAL_ADC_STATE_MULTIMODE_SLAVE bit
        - if ADC instance is master or if multimode feature is not available
        - if multimode setting is disabled (ADC instance slave in independent mode) */
      if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
HAL_ADCEx_InjectedPollForConversion in stm32l4xx_hal_adc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      /* Particular case if injected contexts queue is enabled:             */
      /* when the last context has been fully processed, JSQR is reset      */
      /* by the hardware. Even if no injected conversion is planned to come */
      /* (queue empty, triggers are ignored), it can start again            */
      /* immediately after setting a new context (JADSTART is still set).   */
HAL_ADCEx_InjectedStart_IT in stm32l4xx_hal_adc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
       resort to HAL_ADCEx_DisableInjectedQueue() API to set JQDIS.
       - or (if JQDIS is intentionally reset) since JEXTEN = 0 which means
         the queue is empty */
    tmp_config_injected_queue = READ_BIT(hadc->Instance->CFGR, ADC_CFGR_JQDIS);

HAL_ADCEx_InjectedStart_IT in stm32l4xx_hal_adc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      {
        /* Reset ADC error code field related to injected conversions only */
        CLEAR_BIT(hadc->ErrorCode, HAL_ADC_ERROR_JQOVF);
      }
      else
HAL_ADCEx_InjectedStart_IT in stm32l4xx_hal_adc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if defined(ADC_MULTIMODE_SUPPORT)
      /* Reset HAL_ADC_STATE_MULTIMODE_SLAVE bit
        - if ADC instance is master or if multimode feature is not available
        - if multimode setting is disabled (ADC instance slave in independent mode) */
      if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
stm32l4xx_hal_adc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 1601 : 
  *         function can be used to reconfigure some parameters of structure
  *         "ADC_InjectionConfTypeDef" on the fly, without resetting the ADC.
  *         The setting of these parameters is conditioned to ADC state:
  *         Refer to comments of structure "ADC_InjectionConfTypeDef".
  * @note   In case of usage of internal measurement channels:
HAL_ADCEx_InjectedConfigChannel in stm32l4xx_hal_adc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* if JOVSE is set, the value of the OFFSETy_EN bit in ADCx_OFRy register is
     ignored (considered as reset) */
  assert_param(!((sConfigInjected->InjectedOffsetNumber != ADC_OFFSET_NONE) && (sConfigInjected->InjecOversamplingMode == ENABLE)));

  /* JDISCEN and JAUTO bits can't be set at the same time  */
HAL_ADCEx_InjectedConfigChannel in stm32l4xx_hal_adc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
         call, this context will be written in JSQR register at the last call.
         At this point, the context is merely reset  */
      hadc->InjectionConfig.ContextQueue = 0x00000000U;

      /* Configuration of context register JSQR:                              */
HAL_ADCEx_InjectedConfigChannel in stm32l4xx_hal_adc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

      /*  JOVSE must be reset in case of triggered regular mode  */
      assert_param(!(READ_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE | ADC_CFGR2_TROVS) == (ADC_CFGR2_ROVSE | ADC_CFGR2_TROVS)));

      /* Configuration of Injected Oversampler:                                 */
stm32l4xx_hal_adc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 2058 : 
  *         calls to this function can be used to reconfigure some parameters
  *         of structure "ADC_MultiModeTypeDef" on the fly, without resetting
  *         the ADCs.
  *         The setting of these parameters is conditioned to ADC state.
  *         For parameters constraints, see comments of structure
stm32l4xx_hal_adc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 2064 : 
  * @note   To move back configuration from multimode to single mode, ADC must
  *         be reset (using function HAL_ADC_Init() ).
  * @param hadc Master ADC handle
  * @param multimode Structure of ADC multimode configuration
  * @retval HAL status
HAL_ADCEx_MultiModeConfigChannel in stm32l4xx_hal_adc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* If multimode is selected, configure all multimode parameters.          */
    /* Otherwise, reset multimode parameters (can be used in case of          */
    /* transition from multimode to independent mode).                        */
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
    {
stm32l4xx_hal_adc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 2175 : 
  * @brief  Enable Injected Queue
  * @note   This function resets CFGR register JQDIS bit in order to enable the
  *         Injected Queue. JQDIS can be written only when ADSTART and JDSTART
  *         are both equal to 0 to ensure that no regular nor injected
  *         conversion is ongoing.
stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 441 : 
  * @param __HANDLE__ ADC handle.
  * @retval SET (software start) or RESET (external trigger).
  */
#define ADC_IS_SOFTWARE_START_INJECTED(__HANDLE__)                             \
  (((__HANDLE__)->Instance->JSQR & ADC_JSQR_JEXTEN) == 0UL)
stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 449 : 
  * @param __HANDLE__ ADC handle.
  * @retval SET (conversion is on going) or RESET (no conversion is on going).
  */
#define ADC_IS_CONVERSION_ONGOING_REGULAR_INJECTED(__HANDLE__)                       \
       (( (((__HANDLE__)->Instance->CR) & (ADC_CR_ADSTART | ADC_CR_JADSTART)) == 0UL \
        ) ? RESET : SET)

/**
  * @brief Check if conversion is on going on injected group.
stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 467 : 
  * @note  When multimode feature is not available, the macro always returns SET.
  * @retval SET (ADC is independent) or RESET (ADC is not).
  */
#if defined (STM32L471xx) || defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx) || defined (STM32L496xx) || defined (STM32L4A6xx)
#define ADC_IS_INDEPENDENT(__HANDLE__)    \
ADC_IS_INDEPENDENT in stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) : 
     :                                    \
     RESET                                \
  )
#elif defined (STM32L431xx) || defined (STM32L432xx) || defined (STM32L433xx) || defined (STM32L442xx) || defined (STM32L443xx) || defined (STM32L451xx) || defined (STM32L452xx) || defined (STM32L462xx) || defined (STM32L4R5xx) || defined (STM32L4R7xx) || defined (STM32L4R9xx) || defined (STM32L4S5xx) || defined (STM32L4S7xx) || defined (STM32L4S9xx)
#define ADC_IS_INDEPENDENT(__HANDLE__)   (SET)
#elif defined (STM32L412xx) || defined (STM32L422xx)
#define ADC_IS_INDEPENDENT(__HANDLE__)   (RESET)
#endif

/**
stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 673 : 
  * @param __HANDLE__ ADC handle.
  * @retval SET (ADC instance is valid) or RESET (ADC instance is invalid)
  */
#if defined (STM32L412xx) || defined (STM32L422xx) || defined (STM32L431xx) || defined (STM32L432xx) || defined (STM32L433xx) || defined (STM32L442xx) || defined (STM32L443xx) || defined (STM32L451xx) || defined (STM32L452xx) || defined (STM32L462xx) || defined (STM32L4R5xx) || defined (STM32L4R7xx) || defined (STM32L4R9xx) || defined (STM32L4S5xx) || defined (STM32L4S7xx) || defined (STM32L4S9xx)
/*  The temperature sensor measurement path (channel 17) is available on ADC1 */
stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 686 : 
  * @param __HANDLE__ ADC handle.
  * @retval SET (ADC instance is valid) or RESET (ADC instance is invalid)
  */
#if defined (STM32L412xx) || defined (STM32L422xx) || defined (STM32L431xx) || defined (STM32L432xx) || defined (STM32L433xx) || defined (STM32L442xx) || defined (STM32L443xx) || defined (STM32L451xx) || defined (STM32L452xx) || defined (STM32L462xx) || defined (STM32L4R5xx) || defined (STM32L4R7xx) || defined (STM32L4R9xx) || defined (STM32L4S5xx) || defined (STM32L4S7xx) || defined (STM32L4S9xx)
/*  The battery voltage measurement path (channel 18) is available on ADC1 */
stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 699 : 
  * @param __HANDLE__ ADC handle.
  * @retval SET (ADC instance is valid) or RESET (ADC instance is invalid)
  */
/*  The internal voltage reference  VREFINT measurement path (channel 0) is available on ADC1 */
#define ADC_VREFINT_INSTANCE(__HANDLE__)  (((__HANDLE__)->Instance) == ADC1)
stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 707 : 
  * @param __LENGTH__ number of programmed conversions.
  * @retval SET (__LENGTH__ is within the maximum number of possible programmable injected conversions) or RESET (__LENGTH__ is null or too large)
  */
#define IS_ADC_INJECTED_NB_CONV(__LENGTH__) (((__LENGTH__) >= (1U)) && ((__LENGTH__) <= (4U)))

stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 714 : 
  * @param __CALIBRATION_FACTOR__ Calibration factor value.
  * @retval SET (__CALIBRATION_FACTOR__ is within the authorized size) or RESET (__CALIBRATION_FACTOR__ is too large)
  */
#define IS_ADC_CALFACT(__CALIBRATION_FACTOR__) ((__CALIBRATION_FACTOR__) <= (0x7FU))

stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 723 : 
  * @param __CHANNEL__ programmed ADC channel.
  * @retval SET (__CHANNEL__ is valid) or RESET (__CHANNEL__ is invalid)
  */
#if defined (STM32L431xx) || defined (STM32L432xx) || defined (STM32L433xx) || defined (STM32L442xx) || defined (STM32L443xx) || defined (STM32L451xx) || defined (STM32L452xx) || defined (STM32L462xx) || defined (STM32L4R5xx) || defined (STM32L4R7xx) || defined (STM32L4R9xx) || defined (STM32L4S5xx) || defined (STM32L4S7xx) || defined (STM32L4S9xx)
#define IS_ADC_CHANNEL(__HANDLE__, __CHANNEL__) ((((__HANDLE__)->Instance) == ADC1)  && \
stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 853 : 
  * @param __CHANNEL__ programmed ADC channel.
  * @retval SET (__CHANNEL__ is valid) or RESET (__CHANNEL__ is invalid)
  */
#if defined (STM32L412xx) || defined (STM32L422xx) || defined (STM32L431xx) || defined (STM32L432xx) || defined (STM32L433xx) || defined (STM32L442xx) || defined (STM32L443xx) || defined (STM32L451xx) || defined (STM32L452xx) || defined (STM32L462xx) || defined (STM32L4R5xx) || defined (STM32L4R7xx) || defined (STM32L4R9xx) || defined (STM32L4S5xx) || defined (STM32L4S7xx) || defined (STM32L4S9xx)
#define IS_ADC_DIFF_CHANNEL(__HANDLE__, __CHANNEL__) (((__CHANNEL__) == ADC_CHANNEL_1)      || \
stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 909 : 
  * @param __SING_DIFF__ programmed channel setting.
  * @retval SET (__SING_DIFF__ is valid) or RESET (__SING_DIFF__ is invalid)
  */
#define IS_ADC_SINGLE_DIFFERENTIAL(__SING_DIFF__) (((__SING_DIFF__) == ADC_SINGLE_ENDED)      || \
                                                   ((__SING_DIFF__) == ADC_DIFFERENTIAL_ENDED)  )
stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 917 : 
  * @param __OFFSET_NUMBER__ ADC offset management.
  * @retval SET (__OFFSET_NUMBER__ is valid) or RESET (__OFFSET_NUMBER__ is invalid)
  */
#define IS_ADC_OFFSET_NUMBER(__OFFSET_NUMBER__) (((__OFFSET_NUMBER__) == ADC_OFFSET_NONE) || \
                                                 ((__OFFSET_NUMBER__) == ADC_OFFSET_1)    || \
stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 928 : 
  * @param __CHANNEL__ programmed ADC injected channel.
  * @retval SET (__CHANNEL__ is valid) or RESET (__CHANNEL__ is invalid)
  */
#define IS_ADC_INJECTED_RANK(__CHANNEL__) (((__CHANNEL__) == ADC_INJECTED_RANK_1) || \
                                           ((__CHANNEL__) == ADC_INJECTED_RANK_2) || \
stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 939 : 
  * @param __INJTRIG__ programmed ADC injected conversions external trigger.
  * @retval SET (__INJTRIG__ is a valid value) or RESET (__INJTRIG__ is invalid)
  */
#define IS_ADC_EXTTRIGINJEC(__HANDLE__, __INJTRIG__) (((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_T1_TRGO)     || \
                                                      ((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_T1_CC4)      || \
stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 962 : 
  * @param __EDGE__ programmed ADC edge trigger setting.
  * @retval SET (__EDGE__ is a valid value) or RESET (__EDGE__ is invalid)
  */
#define IS_ADC_EXTTRIGINJEC_EDGE(__EDGE__) (((__EDGE__) == ADC_EXTERNALTRIGINJECCONV_EDGE_NONE)         || \
                                            ((__EDGE__) == ADC_EXTERNALTRIGINJECCONV_EDGE_RISING)       || \
stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 973 : 
  * @param __MODE__ programmed ADC multimode setting.
  * @retval SET (__MODE__ is valid) or RESET (__MODE__ is invalid)
  */
#define IS_ADC_MULTIMODE(__MODE__) (((__MODE__) == ADC_MODE_INDEPENDENT)               || \
                                    ((__MODE__) == ADC_DUALMODE_REGSIMULT_INJECSIMULT) || \
stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 987 : 
  * @param __MODE__ programmed ADC multimode DMA access setting.
  * @retval SET (__MODE__ is valid) or RESET (__MODE__ is invalid)
  */
#define IS_ADC_DMA_ACCESS_MULTIMODE(__MODE__) (((__MODE__) == ADC_DMAACCESSMODE_DISABLED)   || \
                                               ((__MODE__) == ADC_DMAACCESSMODE_12_10_BITS) || \
stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 996 : 
  * @param __DELAY__ programmed ADC multimode delay setting.
  * @retval SET (__DELAY__ is a valid value) or RESET (__DELAY__ is invalid)
  */
#define IS_ADC_SAMPLING_DELAY(__DELAY__) (((__DELAY__) == ADC_TWOSAMPLINGDELAY_1CYCLE)   || \
                                          ((__DELAY__) == ADC_TWOSAMPLINGDELAY_2CYCLES)  || \
stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1015 : 
  * @param __WATCHDOG__ programmed ADC analog watchdog setting.
  * @retval SET (__WATCHDOG__ is valid) or RESET (__WATCHDOG__ is invalid)
  */
#define IS_ADC_ANALOG_WATCHDOG_NUMBER(__WATCHDOG__) (((__WATCHDOG__) == ADC_ANALOGWATCHDOG_1) || \
                                                     ((__WATCHDOG__) == ADC_ANALOGWATCHDOG_2) || \
stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1024 : 
  * @param __WATCHDOG_MODE__ programmed ADC analog watchdog mode setting.
  * @retval SET (__WATCHDOG_MODE__ is valid) or RESET (__WATCHDOG_MODE__ is invalid)
  */
#define IS_ADC_ANALOG_WATCHDOG_MODE(__WATCHDOG_MODE__) (((__WATCHDOG_MODE__) == ADC_ANALOGWATCHDOG_NONE)             || \
                                                        ((__WATCHDOG_MODE__) == ADC_ANALOGWATCHDOG_SINGLE_REG)       || \
stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1037 : 
  * @param __CONVERSION__ ADC conversion group.
  * @retval SET (__CONVERSION__ is valid) or RESET (__CONVERSION__ is invalid)
  */
#define IS_ADC_CONVERSION_GROUP(__CONVERSION__) (((__CONVERSION__) == ADC_REGULAR_GROUP)         || \
                                                 ((__CONVERSION__) == ADC_INJECTED_GROUP)        || \
stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1046 : 
  * @param __EVENT__ ADC event.
  * @retval SET (__EVENT__ is valid) or RESET (__EVENT__ is invalid)
  */
#define IS_ADC_EVENT_TYPE(__EVENT__) (((__EVENT__) == ADC_EOSMP_EVENT)  || \
                                      ((__EVENT__) == ADC_AWD_EVENT)    || \
stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1058 : 
  * @param __RATIO__ programmed ADC oversampling ratio.
  * @retval SET (__RATIO__ is a valid value) or RESET (__RATIO__ is invalid)
  */
#define IS_ADC_OVERSAMPLING_RATIO(__RATIO__)      (((__RATIO__) == ADC_OVERSAMPLING_RATIO_2   ) || \
                                                   ((__RATIO__) == ADC_OVERSAMPLING_RATIO_4   ) || \
stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1072 : 
  * @param __SHIFT__ programmed ADC oversampling shift.
  * @retval SET (__SHIFT__ is a valid value) or RESET (__SHIFT__ is invalid)
  */
#define IS_ADC_RIGHT_BIT_SHIFT(__SHIFT__)        (((__SHIFT__) == ADC_RIGHTBITSHIFT_NONE) || \
                                                  ((__SHIFT__) == ADC_RIGHTBITSHIFT_1   ) || \
stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1087 : 
  * @param __MODE__ programmed ADC oversampling triggered mode.
  * @retval SET (__MODE__ is valid) or RESET (__MODE__ is invalid)
  */
#define IS_ADC_TRIGGERED_OVERSAMPLING_MODE(__MODE__) (((__MODE__) == ADC_TRIGGEREDMODE_SINGLE_TRIGGER) || \
                                                      ((__MODE__) == ADC_TRIGGEREDMODE_MULTI_TRIGGER) )
stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1095 : 
  * @param __MODE__ programmed ADC oversampling regular conversion resumed or continued mode.
  * @retval SET (__MODE__ is valid) or RESET (__MODE__ is invalid)
  */
#define IS_ADC_REGOVERSAMPLING_MODE(__MODE__) (((__MODE__) == ADC_REGOVERSAMPLING_CONTINUED_MODE) || \
                                               ((__MODE__) == ADC_REGOVERSAMPLING_RESUMED_MODE) )
stm32l4xx_hal_adc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1106 : 
  *      directly.
  * @retval SET (DFSDM mode configuration is valid) or RESET (DFSDM mode configuration is invalid)
  */
#if defined(ADC_CFGR_DFSDMCFG) &&defined(DFSDM1_Channel0)
#define IS_ADC_DFSDMCFG_MODE(__HANDLE__) (((__HANDLE__)->Init.DFSDMConfig == ADC_DFSDM_MODE_DISABLE) || \
stm32l4xx_hal_can.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 154 : 

  Use function @ref HAL_CAN_UnRegisterCallback() to reset a callback to the default
  weak function.
  @ref HAL_CAN_UnRegisterCallback takes as parameters the HAL peripheral handle,
  and the Callback ID.
  This function allows to reset following callbacks:
    (+) TxMailbox0CompleteCallback   : Tx Mailbox 0 Complete Callback.
    (+) TxMailbox1CompleteCallback   : Tx Mailbox 1 Complete Callback.
    (+) TxMailbox2CompleteCallback   : Tx Mailbox 2 Complete Callback.
stm32l4xx_hal_can.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 175 : 

  By default, after the @ref HAL_CAN_Init() and when the state is HAL_CAN_STATE_RESET,
  all callbacks are set to the corresponding weak functions:
  example @ref HAL_CAN_ErrorCallback().
  Exception done for MspInit and MspDeInit functions that are
  reset to the legacy weak function in the @ref HAL_CAN_Init()/ @ref HAL_CAN_DeInit() only when
  these callbacks are null (not registered beforehand).
  if not, MspInit or MspDeInit are not null, the @ref HAL_CAN_Init()/ @ref HAL_CAN_DeInit()
  keep and use the user MspInit/MspDeInit callbacks (registered beforehand)
stm32l4xx_hal_can.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 186 : 
  Exception done MspInit/MspDeInit that can be registered/unregistered
  in HAL_CAN_STATE_READY or HAL_CAN_STATE_RESET state,
  thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
  In that case first register the MspInit/MspDeInit user callbacks
  using @ref HAL_CAN_RegisterCallback() before calling @ref HAL_CAN_DeInit()
HAL_CAN_Init in stm32l4xx_hal_can.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
  if (hcan->State == HAL_CAN_STATE_RESET)
  {
    /* Reset callbacks to legacy functions */
    hcan->RxFifo0MsgPendingCallback  =  HAL_CAN_RxFifo0MsgPendingCallback;  /* Legacy weak RxFifo0MsgPendingCallback  */
    hcan->RxFifo0FullCallback        =  HAL_CAN_RxFifo0FullCallback;        /* Legacy weak RxFifo0FullCallback        */
    hcan->RxFifo1MsgPendingCallback  =  HAL_CAN_RxFifo1MsgPendingCallback;  /* Legacy weak RxFifo1MsgPendingCallback  */
HAL_CAN_Init in stm32l4xx_hal_can.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#else
  if (hcan->State == HAL_CAN_STATE_RESET)
  {
    /* Init the low level hardware: CLOCK, NVIC */
    HAL_CAN_MspInit(hcan);
stm32l4xx_hal_can.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 453 : 
  * @brief  Deinitializes the CAN peripheral registers to their default
  *         reset values.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval HAL status
HAL_CAN_DeInit in stm32l4xx_hal_can.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset the CAN peripheral */
  SET_BIT(hcan->Instance->MCR, CAN_MCR_RESET);

  /* Reset the CAN ErrorCode */
  hcan->ErrorCode = HAL_CAN_ERROR_NONE;

  /* Change CAN state */
  hcan->State = HAL_CAN_STATE_RESET;

  /* Return function status */
  return HAL_OK;
HAL_CAN_RegisterCallback in stm32l4xx_hal_can.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (hcan->State == HAL_CAN_STATE_RESET)
  {
    switch (CallbackID)
    {
HAL_CAN_UnRegisterCallback in stm32l4xx_hal_can.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (hcan->State == HAL_CAN_STATE_RESET)
  {
    switch (CallbackID)
    {
HAL_CAN_Start in stm32l4xx_hal_can.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset the CAN ErrorCode */
    hcan->ErrorCode = HAL_CAN_ERROR_NONE;

    /* Return function status */
stm32l4xx_hal_can.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 2333 : 
      (+) HAL_CAN_GetError()  : Return the CAN error codes if any.
      (+) HAL_CAN_ResetError(): Reset the CAN error codes if any.

@endverbatim
  * @{
stm32l4xx_hal_can.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 2387 : 
/**
  * @brief  Reset the CAN error code.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_ResetError(CAN_HandleTypeDef *hcan)
{
  HAL_StatusTypeDef status = HAL_OK;
  HAL_CAN_StateTypeDef state = hcan->State;
HAL_CAN_ResetError in stm32l4xx_hal_can.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Reset CAN error code */
    hcan->ErrorCode = 0U;
  }
  else
stm32l4xx_hal_can.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 48 : 
{
  HAL_CAN_STATE_RESET             = 0x00U,  /*!< CAN not yet initialized or disabled */
  HAL_CAN_STATE_READY             = 0x01U,  /*!< CAN initialized and ready for use   */
  HAL_CAN_STATE_LISTENING         = 0x02U,  /*!< CAN receive process is ongoing      */
  HAL_CAN_STATE_SLEEP_PENDING     = 0x03U,  /*!< CAN sleep request is pending        */
stm32l4xx_hal_can.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 542 : 

/** @brief  Reset CAN handle state
  * @param  __HANDLE__ CAN handle.
  * @retval None
  */
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
#define __HAL_CAN_RESET_HANDLE_STATE(__HANDLE__) do{                                              \
                                                     (__HANDLE__)->State = HAL_CAN_STATE_RESET;   \
                                                     (__HANDLE__)->MspInitCallback = NULL;        \
                                                     (__HANDLE__)->MspDeInitCallback = NULL;      \
                                                   } while(0)
#else
#define __HAL_CAN_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_CAN_STATE_RESET)
#endif /*USE_HAL_CAN_REGISTER_CALLBACKS */

/**
stm32l4xx_hal_can.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 734 : 
uint32_t HAL_CAN_GetError(CAN_HandleTypeDef *hcan);
HAL_StatusTypeDef HAL_CAN_ResetError(CAN_HandleTypeDef *hcan);

/**
 * @}
stm32l4xx_hal_can_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 49 : 
{
  HAL_CAN_STATE_RESET             = 0x00,  /*!< CAN not yet initialized or disabled */
  HAL_CAN_STATE_READY             = 0x01,  /*!< CAN initialized and ready for use   */
  HAL_CAN_STATE_BUSY              = 0x02,  /*!< CAN process is ongoing              */
  HAL_CAN_STATE_BUSY_TX           = 0x12,  /*!< CAN process is ongoing              */
stm32l4xx_hal_can_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 456 : 

/** @brief  Reset CAN handle state.
  * @param  __HANDLE__: CAN handle.
  * @retval None
  */
#define __HAL_CAN_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_CAN_STATE_RESET)

/**
  * @brief  Enable the specified CAN interrupt.
stm32l4xx_hal_can_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 560 : 
  */
#define __HAL_CAN_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((((__HANDLE__)->Instance->IER & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)

/**
  * @brief  Check the transmission status of a CAN Frame.
stm32l4xx_hal_comp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 88 : 
      (#) For safety purpose, comparator configuration can be locked using HAL_COMP_Lock() function.
          The only way to unlock the comparator is a device hardware reset.

    *** Callback registration ***
    =============================================
stm32l4xx_hal_comp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 108 : 

     Use function @ref HAL_COMP_UnRegisterCallback to reset a callback to the default
     weak function.
    [..]

stm32l4xx_hal_comp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 114 : 
     and the Callback ID.
     This function allows to reset following callbacks:
       (+) TriggerCallback       : callback for COMP trigger.
       (+) MspInitCallback       : callback for Msp Init.
       (+) MspDeInitCallback     : callback for Msp DeInit.
stm32l4xx_hal_comp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 120 : 

     By default, after the @ref HAL_COMP_Init() and when the state is @ref HAL_COMP_STATE_RESET
     all callbacks are set to the corresponding weak functions:
     example @ref HAL_COMP_TriggerCallback().
     Exception done for MspInit and MspDeInit functions that are
     reset to the legacy weak functions in the @ref HAL_COMP_Init()/ @ref HAL_COMP_DeInit() only when
     these callbacks are null (not registered beforehand).
    [..]

stm32l4xx_hal_comp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 134 : 
     Exception done MspInit/MspDeInit functions that can be registered/unregistered
     in @ref HAL_COMP_STATE_READY or @ref HAL_COMP_STATE_RESET state,
     thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
    [..]

stm32l4xx_hal_comp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 260 : 
  * @note   If the selected comparator is locked, initialization can't be performed.
  *         To unlock the configuration, perform a system reset.
  * @param  hcomp  COMP handle
  * @retval HAL status
  */
HAL_COMP_Init in stm32l4xx_hal_comp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    if(hcomp->State == HAL_COMP_STATE_RESET)
    {
      /* Allocate lock resource and initialize it */
      hcomp->Lock = HAL_UNLOCKED;
HAL_COMP_Init in stm32l4xx_hal_comp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Set HAL COMP handle state */
    /* Note: Transition from state reset to state ready,                      */
    /*       otherwise (coming from state ready or busy) no state update.     */
    if (hcomp->State == HAL_COMP_STATE_RESET)
    {
      hcomp->State = HAL_COMP_STATE_READY;
    }
stm32l4xx_hal_comp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 475 : 
  * @note   Deinitialization cannot be performed if the COMP configuration is locked.
  *         To unlock the configuration, perform a system reset.
  * @param  hcomp  COMP handle
  * @retval HAL status
  */
HAL_COMP_DeInit in stm32l4xx_hal_comp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Set COMP_CSR register to reset value */
    WRITE_REG(hcomp->Instance->CSR, 0x00000000UL);

#if (USE_HAL_COMP_REGISTER_CALLBACKS == 1)
HAL_COMP_DeInit in stm32l4xx_hal_comp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Set HAL COMP handle state */
    hcomp->State = HAL_COMP_STATE_RESET;

    /* Release Lock */
    __HAL_UNLOCK(hcomp);
HAL_COMP_RegisterCallback in stm32l4xx_hal_comp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (HAL_COMP_STATE_RESET == hcomp->State)
  {
    switch (CallbackID)
    {
HAL_COMP_UnRegisterCallback in stm32l4xx_hal_comp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (HAL_COMP_STATE_RESET == hcomp->State)
  {
    switch (CallbackID)
    {
HAL_COMP_Stop in stm32l4xx_hal_comp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Check compliant states: HAL_COMP_STATE_READY or HAL_COMP_STATE_BUSY    */
    /* (all states except HAL_COMP_STATE_RESET and except locked status.      */
    if(hcomp->State != HAL_COMP_STATE_RESET)
    {
      /* Disable the selected comparator */
      CLEAR_BIT(hcomp->Instance->CSR, COMP_CSR_EN);
HAL_COMP_IRQHandler in stm32l4xx_hal_comp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Check whether comparator is in independent or window mode */
    if(READ_BIT(COMP12_COMMON->CSR, COMP_CSR_WINMODE) != RESET)
    {
      /* Clear COMP EXTI line pending bit of the pair of comparators          */
      /* in window mode.                                                      */
stm32l4xx_hal_comp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 888 : 
  * @brief  Lock the selected comparator configuration.
  * @note   A system reset is required to unlock the comparator configuration.
  * @note   Locking the comparator from reset state is possible
  *         if __HAL_RCC_SYSCFG_CLK_ENABLE() is being called before.
  * @param  hcomp  COMP handle
  * @retval HAL status
HAL_COMP_Lock in stm32l4xx_hal_comp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    {
      case HAL_COMP_STATE_RESET:
        hcomp->State = HAL_COMP_STATE_RESET_LOCKED;
        break;
      case HAL_COMP_STATE_READY:
        hcomp->State = HAL_COMP_STATE_READY_LOCKED;
HAL_COMP_GetState in stm32l4xx_hal_comp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    return HAL_COMP_STATE_RESET;
  }

  /* Check the parameter */
stm32l4xx_hal_comp.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 89 : 
{
  HAL_COMP_STATE_RESET             = 0x00U,                                             /*!< COMP not yet initialized                             */
  HAL_COMP_STATE_RESET_LOCKED      = (HAL_COMP_STATE_RESET | COMP_STATE_BITFIELD_LOCK), /*!< COMP not yet initialized and configuration is locked */
  HAL_COMP_STATE_READY             = 0x01U,                                             /*!< COMP initialized and ready for use                   */
  HAL_COMP_STATE_READY_LOCKED      = (HAL_COMP_STATE_READY | COMP_STATE_BITFIELD_LOCK), /*!< COMP initialized but configuration is locked         */
  HAL_COMP_STATE_BUSY              = 0x02U,                                             /*!< COMP is running                                      */
stm32l4xx_hal_comp.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 292 : 

/** @brief  Reset COMP handle state.
  * @param  __HANDLE__  COMP handle
  * @retval None
  */
#if (USE_HAL_COMP_REGISTER_CALLBACKS == 1)
#define __HAL_COMP_RESET_HANDLE_STATE(__HANDLE__) do{                                                  \
                                                      (__HANDLE__)->State = HAL_COMP_STATE_RESET;      \
                                                      (__HANDLE__)->MspInitCallback = NULL;            \
                                                      (__HANDLE__)->MspDeInitCallback = NULL;          \
                                                    } while(0)
#else
#define __HAL_COMP_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_COMP_STATE_RESET)
#endif

/**
stm32l4xx_hal_comp.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 427 : 
  * @brief  Check whether the COMP1 EXTI line flag is set.
  * @retval RESET or SET
  */
#define __HAL_COMP_COMP1_EXTI_GET_FLAG()              LL_EXTI_IsActiveFlag_0_31(COMP_EXTI_LINE_COMP1)

stm32l4xx_hal_comp.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 512 : 
  * @brief  Check whether the COMP2 EXTI line flag is set.
  * @retval RESET or SET
  */
#define __HAL_COMP_COMP2_EXTI_GET_FLAG()              LL_EXTI_IsActiveFlag_0_31(COMP_EXTI_LINE_COMP2)

stm32l4xx_hal_conf.h (F:\projects\git\Hardware\magnetic\code\node\Inc) line 121 : 
  * @brief Internal Multiple Speed oscillator (MSI) default value.
  *        This value is the default MSI range value after Reset.
  */
#if !defined  (MSI_VALUE)
  #define MSI_VALUE    ((uint32_t)48000000U) /*!< Value of the Internal oscillator in Hz*/
stm32l4xx_hal_conf_template.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 104 : 
  * @brief Internal Multiple Speed oscillator (MSI) default value.
  *        This value is the default MSI range value after Reset.
  */
#if !defined  (MSI_VALUE)
  #define MSI_VALUE    4000000U /*!< Value of the Internal oscillator in Hz*/
stm32l4xx_hal_cortex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 44 : 
        (++) Configures the SysTick IRQ priority to the lowest value (0x0F).
        (++) Resets the SysTick Counter register.
        (++) Configures the SysTick Counter clock source to be Core Clock Source (HCLK).
        (++) Enables the SysTick Interrupt.
        (++) Starts the SysTick Counter.
stm32l4xx_hal_cortex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 233 : 
/**
  * @brief  Initiate a system reset request to reset the MCU.
  * @retval None
  */
void HAL_NVIC_SystemReset(void)
{
  /* System Reset */
  NVIC_SystemReset();
}

/**
HAL_MPU_ConfigRegion in stm32l4xx_hal_cortex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if ((MPU_Init->Enable) != RESET)
  {
    /* Check the parameters */
    assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));
stm32l4xx_hal_cortex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 270 : 
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn);
void HAL_NVIC_SystemReset(void);
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb);

/**
HAL_CRC_Init in stm32l4xx_hal_crc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (hcrc->State == HAL_CRC_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hcrc->Lock = HAL_UNLOCKED;
HAL_CRC_DeInit in stm32l4xx_hal_crc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset CRC calculation unit */
  __HAL_CRC_DR_RESET(hcrc);

  /* Reset IDR register content */
  CLEAR_BIT(hcrc->Instance->IDR, CRC_IDR_IDR);

  /* DeInit the low level hardware */
HAL_CRC_DeInit in stm32l4xx_hal_crc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Change CRC peripheral state */
  hcrc->State = HAL_CRC_STATE_RESET;

  /* Process unlocked */
  __HAL_UNLOCK(hcrc);
HAL_CRC_Calculate in stm32l4xx_hal_crc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset CRC Calculation Unit (hcrc->Instance->INIT is
  *  written in hcrc->Instance->DR) */
  __HAL_CRC_DR_RESET(hcrc);

  switch (hcrc->InputDataFormat)
  {
stm32l4xx_hal_crc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 48 : 
{
  HAL_CRC_STATE_RESET     = 0x00U,  /*!< CRC not yet initialized or disabled */
  HAL_CRC_STATE_READY     = 0x01U,  /*!< CRC initialized and ready for use   */
  HAL_CRC_STATE_BUSY      = 0x02U,  /*!< CRC internal process is ongoing     */
  HAL_CRC_STATE_TIMEOUT   = 0x03U,  /*!< CRC timeout state                   */
stm32l4xx_hal_crc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 219 : 

/** @brief Reset CRC handle state.
  * @param  __HANDLE__ CRC handle.
  * @retval None
  */
#define __HAL_CRC_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_CRC_STATE_RESET)

/**
  * @brief  Reset CRC Data Register.
  * @param  __HANDLE__ CRC handle
  * @retval None
  */
#define __HAL_CRC_DR_RESET(__HANDLE__) ((__HANDLE__)->Instance->CR |= CRC_CR_RESET)

/**
  * @brief  Set CRC INIT non-default value
stm32l4xx_hal_cryp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 73 : 

      (#) Use function @ref HAL_CRYP_UnRegisterCallback() to reset a callback to the default
          weak (surcharged) function.
          @ref HAL_CRYP_UnRegisterCallback() takes as parameters the HAL peripheral handle,
          and the Callback ID.
          This function allows to reset following callbacks:
            (+) InCpltCallback : callback for input DMA transfer completion.
            (+) OutCpltCallback : callback for output DMA transfer completion.
            (+) CompCpltCallback : callback for computation completion.
stm32l4xx_hal_cryp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 85 : 

      (#) By default, after the @ref HAL_CRYP_Init and if the state is HAL_CRYP_STATE_RESET
          all callbacks are reset to the corresponding legacy weak (surcharged) functions:
          examples @ref HAL_CRYP_InCpltCallback(), @ref HAL_CRYP_ErrorCallback()
          Exception done for MspInit and MspDeInit callbacks that are respectively
          reset to the legacy weak (surcharged) functions in the @ref HAL_CRYP_Init
          and @ref HAL_CRYP_DeInit only when these callbacks are null (not registered beforehand)
          If not, MspInit or MspDeInit are not null, the @ref HAL_CRYP_Init and @ref HAL_CRYP_DeInit
          keep and use the user MspInit/MspDeInit callbacks (registered beforehand).
stm32l4xx_hal_cryp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 96 : 
          Exception done for MspInit/MspDeInit callbacks that can be registered/unregistered
          in READY or RESET state, thus registered (user) MspInit/DeInit callbacks can be used
          during the Init/DeInit.
          In that case first register the MspInit/MspDeInit user callbacks
          using @ref HAL_CRYP_RegisterCallback before calling @ref HAL_CRYP_DeInit
HAL_CRYP_Init in stm32l4xx_hal_cryp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_HAL_CRYP_REGISTER_CALLBACKS == 1)
  if (hcryp->State == HAL_CRYP_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hcryp->Lock = HAL_UNLOCKED;

    /* Reset Callback pointers in HAL_CRYP_STATE_RESET only */
    hcryp->InCpltCallback   =  HAL_CRYP_InCpltCallback;            /* Legacy weak (surcharged) input DMA transfer completion callback */
    hcryp->OutCpltCallback   =  HAL_CRYP_OutCpltCallback;           /* Legacy weak (surcharged) output DMA transfer completion callback */
    hcryp->CompCpltCallback =  HAL_CRYPEx_ComputationCpltCallback; /* Legacy weak (surcharged) computation completion callback */
HAL_CRYP_Init in stm32l4xx_hal_cryp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#else
  if(hcryp->State == HAL_CRYP_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hcryp->Lock = HAL_UNLOCKED;
HAL_CRYP_Init in stm32l4xx_hal_cryp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset CrypInCount and CrypOutCount */
  hcryp->CrypInCount = 0;
  hcryp->CrypOutCount = 0;

  /* Reset ErrorCode field */
  hcryp->ErrorCode = HAL_CRYP_ERROR_NONE;

  /* Reset Mode suspension request */
  hcryp->SuspendRequest = HAL_CRYP_SUSPEND_NONE;

  /* Change the CRYP state */
HAL_CRYP_DeInit in stm32l4xx_hal_cryp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset CrypInCount and CrypOutCount */
  hcryp->CrypInCount = 0;
  hcryp->CrypOutCount = 0;

HAL_CRYP_DeInit in stm32l4xx_hal_cryp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Change the CRYP state */
  hcryp->State = HAL_CRYP_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(hcryp);
HAL_CRYP_RegisterCallback in stm32l4xx_hal_cryp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if(HAL_CRYP_STATE_RESET == hcryp->State)
  {
    switch (CallbackID)
    {
HAL_CRYP_UnRegisterCallback in stm32l4xx_hal_cryp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if(HAL_CRYP_STATE_RESET == hcryp->State)
  {
    switch (CallbackID)
    {
HAL_CRYP_IRQHandler in stm32l4xx_hal_cryp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Check if error occurred */
  if (__HAL_CRYP_GET_IT_SOURCE(hcryp, CRYP_IT_ERRIE) != RESET)
  {
    /* If Write Error occurred */
    if (__HAL_CRYP_GET_FLAG(hcryp, CRYP_IT_WRERR) != RESET)
    {
      hcryp->ErrorCode |= HAL_CRYP_WRITE_ERROR;
      hcryp->State = HAL_CRYP_STATE_ERROR;
HAL_CRYP_IRQHandler in stm32l4xx_hal_cryp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* If Read Error occurred */
    if (__HAL_CRYP_GET_FLAG(hcryp, CRYP_IT_RDERR) != RESET)
    {
      hcryp->ErrorCode |= HAL_CRYP_READ_ERROR;
      hcryp->State = HAL_CRYP_STATE_ERROR;
HAL_CRYP_IRQHandler in stm32l4xx_hal_cryp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
     and if the computation complete flag is raised */
  if (__HAL_CRYP_GET_FLAG(hcryp, CRYP_IT_CCF) != RESET)
  {
    if (__HAL_CRYP_GET_IT_SOURCE(hcryp, CRYP_IT_CCFIE) != RESET)
    {
#if defined(AES_CR_NPBLB)
      if ((hcryp->Init.ChainingMode == CRYP_CHAINMODE_AES_GCM_GMAC)
HAL_CRYP_IRQHandler in stm32l4xx_hal_cryp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
       /* To ensure proper suspension requests management, CCF flag
          is reset in CRYP_AES_Auth_IT() according to the current
          phase under handling */
        if (CRYP_AES_Auth_IT(hcryp) !=  HAL_OK)
        {
CRYP_AES_IT in stm32l4xx_hal_cryp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    {
      /* reset ModeSuspend */
      hcryp->SuspendRequest = HAL_CRYP_SUSPEND_NONE;

      /* Disable Computation Complete Flag and Errors Interrupts */
stm32l4xx_hal_cryp.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 87 : 
{
  HAL_CRYP_STATE_RESET             = 0x00,  /*!< CRYP not yet initialized or disabled  */
  HAL_CRYP_STATE_READY             = 0x01,  /*!< CRYP initialized and ready for use    */
  HAL_CRYP_STATE_BUSY              = 0x02,  /*!< CRYP internal processing is ongoing   */
  HAL_CRYP_STATE_TIMEOUT           = 0x03,  /*!< CRYP timeout state                    */
stm32l4xx_hal_cryp.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 370 : 

/** @brief Reset CRYP handle state.
  * @param  __HANDLE__: specifies the CRYP handle.
  * @retval None
  */
#if (USE_HAL_CRYP_REGISTER_CALLBACKS == 1)
#define __HAL_CRYP_RESET_HANDLE_STATE(__HANDLE__) do{\
                                                      (__HANDLE__)->State = HAL_CRYP_STATE_RESET;\
                                                      (__HANDLE__)->MspInitCallback = NULL;      \
                                                      (__HANDLE__)->MspDeInitCallback = NULL;    \
                                                     }while(0)
#else
#define __HAL_CRYP_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_CRYP_STATE_RESET)
#endif /* USE_HAL_CRYP_REGISTER_CALLBACKS */

/**
stm32l4xx_hal_cryp.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 523 : 
  * @param __KEYSIZE__: Ciphering/deciphering algorithm key size.
  * @retval SET (__KEYSIZE__ is a valid value) or RESET (__KEYSIZE__ is invalid)
  */
#define IS_CRYP_KEYSIZE(__KEYSIZE__)  (((__KEYSIZE__) == CRYP_KEYSIZE_128B)  || \
                                       ((__KEYSIZE__) == CRYP_KEYSIZE_256B))
stm32l4xx_hal_cryp.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 531 : 
  * @param __DATATYPE__: Ciphering/deciphering algorithm input data type.
  * @retval SET (__DATATYPE__ is valid) or RESET (__DATATYPE__ is invalid)
  */
#define IS_CRYP_DATATYPE(__DATATYPE__) (((__DATATYPE__) == CRYP_DATATYPE_32B) || \
                                        ((__DATATYPE__) == CRYP_DATATYPE_16B) || \
stm32l4xx_hal_cryp.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 541 : 
  * @param __MODE__: CRYP AES IP running mode.
  * @retval SET (__MODE__ is valid) or RESET (__MODE__ is invalid)
  */
#define IS_CRYP_AES(__MODE__) (((__MODE__) == CRYP_AES_DISABLE) || \
                               ((__MODE__) == CRYP_AES_ENABLE))
stm32l4xx_hal_cryp.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 549 : 
  * @param __ALGOMODE__: Selected CRYP algorithm (ciphering, deciphering, key derivation or a combination of the latter).
  * @retval SET (__ALGOMODE__ is valid) or RESET (__ALGOMODE__ is invalid)
  */
#define IS_CRYP_ALGOMODE(__ALGOMODE__) (((__ALGOMODE__) == CRYP_ALGOMODE_ENCRYPT)        || \
                                        ((__ALGOMODE__) == CRYP_ALGOMODE_KEYDERIVATION)  || \
stm32l4xx_hal_cryp.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 560 : 
  * @param __CHAINMODE__: Selected CRYP chaining algorithm.
  * @retval SET (__CHAINMODE__ is valid) or RESET (__CHAINMODE__ is invalid)
  */
#if defined(AES_CR_NPBLB)
#define IS_CRYP_CHAINMODE(__CHAINMODE__) (((__CHAINMODE__) == CRYP_CHAINMODE_AES_ECB)     || \
stm32l4xx_hal_cryp.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 579 : 
  * @param __WRITE__: deciphering key write option.
  * @retval SET (__WRITE__ is valid) or RESET (__WRITE__ is invalid)
  */
#define IS_CRYP_WRITE(__WRITE__)   (((__WRITE__) == CRYP_KEY_WRITE_ENABLE)      || \
                                    ((__WRITE__) == CRYP_KEY_WRITE_DISABLE))
stm32l4xx_hal_cryp.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 587 : 
  * @param __MODE__: CRYP input data DMA mode.
  * @retval SET (__MODE__ is valid) or RESET (__MODE__ is invalid)
  */
#define IS_CRYP_DMAIN(__MODE__) (((__MODE__) == CRYP_DMAIN_DISABLE) || \
                                 ((__MODE__) == CRYP_DMAIN_ENABLE))
stm32l4xx_hal_cryp.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 595 : 
  * @param __MODE__: CRYP output data DMA mode.
  * @retval SET (__MODE__ is valid) or RESET (__MODE__ is invalid)
  */
#define IS_CRYP_DMAOUT(__MODE__) (((__MODE__) == CRYP_DMAOUT_DISABLE) || \
                                  ((__MODE__) == CRYP_DMAOUT_ENABLE))
stm32l4xx_hal_cryp.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 603 : 
  * @param __PHASE__: CRYP AES ciphering/deciphering/authentication algorithm phase.
  * @retval SET (__PHASE__ is valid) or RESET (__PHASE__ is invalid)
  */
#define IS_CRYP_GCMCMAC_PHASE(__PHASE__) (((__PHASE__) == CRYP_INIT_PHASE)    || \
                                          ((__PHASE__) == CRYP_HEADER_PHASE)  || \
stm32l4xx_hal_cryp_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 44 : 
#define CRYP_CCF_TIMEOUTVALUE                      22000  /*!< CCF flag raising time-out value */
#define CRYP_BUSY_TIMEOUTVALUE                     22000  /*!< BUSY flag reset time-out value  */

#define CRYP_POLLING_OFF                             0x0  /*!< No polling when padding */
#define CRYP_POLLING_ON                              0x1  /*!< Polling when padding    */
stm32l4xx_hal_cryp_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 70 : 
static HAL_StatusTypeDef CRYP_WaitOnCCFlag(CRYP_HandleTypeDef const * const hcryp, uint32_t Timeout);
static HAL_StatusTypeDef CRYP_WaitOnBusyFlagReset(CRYP_HandleTypeDef const * const hcryp, uint32_t Timeout);
static void CRYP_DMAInCplt(DMA_HandleTypeDef *hdma);
static void CRYP_DMAOutCplt(DMA_HandleTypeDef *hdma);
static void CRYP_DMAError(DMA_HandleTypeDef *hdma);
HAL_CRYPEx_AES_Auth in stm32l4xx_hal_cryp_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
          {
            /* reset SuspendRequest */
            hcryp->SuspendRequest = HAL_CRYP_SUSPEND_NONE;
            /* Change the CRYP state */
            hcryp->State = HAL_CRYP_STATE_SUSPENDED;
HAL_CRYPEx_AES_Auth in stm32l4xx_hal_cryp_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
        {
          /* reset SuspendRequest */
          hcryp->SuspendRequest = HAL_CRYP_SUSPEND_NONE;
          /* Change the CRYP state */
          hcryp->State = HAL_CRYP_STATE_SUSPENDED;
HAL_CRYPEx_AES_Auth in stm32l4xx_hal_cryp_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
          {
            /* Ensure that Busy flag is reset */
            if(CRYP_WaitOnBusyFlagReset(hcryp, CRYP_BUSY_TIMEOUTVALUE) != HAL_OK)
            {
              hcryp->State = HAL_CRYP_STATE_READY;
              __HAL_UNLOCK(hcryp);
HAL_CRYPEx_AES_Auth in stm32l4xx_hal_cryp_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
          }
          /* reset SuspendRequest */
          hcryp->SuspendRequest = HAL_CRYP_SUSPEND_NONE;
          /* Change the CRYP state */
          hcryp->State = HAL_CRYP_STATE_SUSPENDED;
stm32l4xx_hal_cryp_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 1860 : 
  *         Applicable to all chaining modes.
  * @note   AES must be disabled when reading or resetting the IV values.
  * @retval None
  */
void HAL_CRYPEx_Read_IVRegisters(CRYP_HandleTypeDef *hcryp, uint8_t* Output)
stm32l4xx_hal_cryp_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 1884 : 
  * @note   Applicable to all chaining modes.
  * @note   AES must be disabled when reading or resetting the IV values.
  * @retval None
  */
void HAL_CRYPEx_Write_IVRegisters(CRYP_HandleTypeDef *hcryp, uint8_t* Input)
HAL_CRYPEx_Read_SuspendRegisters in stm32l4xx_hal_cryp_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Ensure that Busy flag is reset */
    if(CRYP_WaitOnBusyFlagReset(hcryp, CRYP_BUSY_TIMEOUTVALUE) != HAL_OK)
    {
      hcryp->ErrorCode |= HAL_CRYP_BUSY_ERROR;
      hcryp->State = HAL_CRYP_STATE_ERROR;
CRYP_AES_Auth_IT in stm32l4xx_hal_cryp_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

        /* reset SuspendRequest */
        hcryp->SuspendRequest = HAL_CRYP_SUSPEND_NONE;
        /* Disable Computation Complete Flag and Errors Interrupts */
        __HAL_CRYP_DISABLE_IT(hcryp, CRYP_IT_CCFIE|CRYP_IT_ERRIE);
CRYP_AES_Auth_IT in stm32l4xx_hal_cryp_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

        /* reset SuspendRequest */
        hcryp->SuspendRequest = HAL_CRYP_SUSPEND_NONE;
        /* Disable Computation Complete Flag and Errors Interrupts */
        __HAL_CRYP_DISABLE_IT(hcryp, CRYP_IT_CCFIE|CRYP_IT_ERRIE);
CRYP_ProcessData in stm32l4xx_hal_cryp_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    {
      /* Reset SuspendRequest */
      hcryp->SuspendRequest = HAL_CRYP_SUSPEND_NONE;

      /* Save current reading and writing locations of Input and Output buffers */
stm32l4xx_hal_cryp_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 2976 : 
/**
  * @brief  Wait for Busy Flag to be reset during a GCM payload encryption process suspension.
  * @param  hcryp: pointer to a CRYP_HandleTypeDef structure that contains
  *         the configuration information for CRYP module.
  * @param  Timeout: Timeout duration.
stm32l4xx_hal_cryp_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 2982 : 
  */
static HAL_StatusTypeDef CRYP_WaitOnBusyFlagReset(CRYP_HandleTypeDef const * const hcryp, uint32_t Timeout)
{
  uint32_t tickstart;

stm32l4xx_hal_dac.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 254 : 

    Use function @ref HAL_DAC_UnRegisterCallback() to reset a callback to the default
      weak (surcharged) function. It allows to reset following callbacks:
      (+) ConvCpltCallbackCh1     : callback when a half transfer is completed on Ch1.
      (+) ConvHalfCpltCallbackCh1 : callback when a transfer is completed on Ch1.
      (+) ErrorCallbackCh1        : callback when an error occurs on Ch1.
stm32l4xx_hal_dac.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 269 : 

      By default, after the @ref HAL_DAC_Init and if the state is HAL_DAC_STATE_RESET
      all callbacks are reset to the corresponding legacy weak (surcharged) functions.
      Exception done for MspInit and MspDeInit callbacks that are respectively
      reset to the legacy weak (surcharged) functions in the @ref HAL_DAC_Init
      and @ref  HAL_DAC_DeInit only when these callbacks are null (not registered beforehand).
      If not, MspInit or MspDeInit are not null, the @ref HAL_DAC_Init and @ref HAL_DAC_DeInit
      keep and use the user MspInit/MspDeInit callbacks (registered beforehand)
stm32l4xx_hal_dac.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 279 : 
      Exception done for MspInit/MspDeInit callbacks that can be registered/unregistered
      in READY or RESET state, thus registered (user) MspInit/DeInit callbacks can be used
      during the Init/DeInit.
      In that case first register the MspInit/MspDeInit user callbacks
      using @ref HAL_DAC_RegisterCallback before calling @ref HAL_DAC_DeInit
HAL_DAC_Init in stm32l4xx_hal_dac.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (hdac->State == HAL_DAC_STATE_RESET)
  {
#if (USE_HAL_DAC_REGISTER_CALLBACKS == 1)
    /* Init the DAC Callback settings */
stm32l4xx_hal_dac.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 432 : 
/**
  * @brief  Deinitialize the DAC peripheral registers to their default reset values.
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval HAL status
HAL_DAC_DeInit in stm32l4xx_hal_dac.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Change DAC state */
  hdac->State = HAL_DAC_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(hdac);
HAL_DAC_ConfigChannel in stm32l4xx_hal_dac.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  /* else factory trimming is used (factory setting are available at reset)*/
  /* SW Nothing has nothing to do */

  /* Get the DAC MCR value */
HAL_DAC_RegisterCallback in stm32l4xx_hal_dac.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (hdac->State == HAL_DAC_STATE_RESET)
  {
    switch (CallbackID)
    {
HAL_DAC_UnRegisterCallback in stm32l4xx_hal_dac.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (hdac->State == HAL_DAC_STATE_RESET)
  {
    switch (CallbackID)
    {
stm32l4xx_hal_dac.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 51 : 
{
  HAL_DAC_STATE_RESET             = 0x00U,  /*!< DAC not yet initialized or disabled  */
  HAL_DAC_STATE_READY             = 0x01U,  /*!< DAC initialized and ready for use    */
  HAL_DAC_STATE_BUSY              = 0x02U,  /*!< DAC internal processing is ongoing   */
  HAL_DAC_STATE_TIMEOUT           = 0x03U,  /*!< DAC timeout state                    */
stm32l4xx_hal_dac.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 367 : 

/** @brief Reset DAC handle state.
  * @param  __HANDLE__ specifies the DAC handle.
  * @retval None
  */
#if (USE_HAL_DAC_REGISTER_CALLBACKS == 1)
#define __HAL_DAC_RESET_HANDLE_STATE(__HANDLE__) do {                                                        \
                                                      (__HANDLE__)->State             = HAL_DAC_STATE_RESET; \
                                                      (__HANDLE__)->MspInitCallback   = NULL;                \
                                                      (__HANDLE__)->MspDeInitCallback = NULL;                \
                                                               } while(0)
#else
#define __HAL_DAC_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_DAC_STATE_RESET)
#endif /* USE_HAL_DAC_REGISTER_CALLBACKS */

/** @brief Enable the DAC channel.
stm32l4xx_hal_dac.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 441 : 
  *            @arg DAC_IT_DMAUDR2: DAC channel 2 DMA underrun interrupt
  * @retval State of interruption (SET or RESET)
  */
#define __HAL_DAC_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) (((__HANDLE__)->Instance->CR & (__INTERRUPT__)) == (__INTERRUPT__))

stm32l4xx_hal_dac_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 29 : 
      (+) HAL_DACEx_GetTrimOffset to retrieve trimming value (factory setting
          after reset, user setting if HAL_DACEx_SetUserTrimming have been used
          at least one time after reset).

 @endverbatim
  ******************************************************************************
stm32l4xx_hal_dcmi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 112 : 

    Use function @ref HAL_DCMI_UnRegisterCallback() to reset a callback to the default
    weak (surcharged) function.
    @ref HAL_DCMI_UnRegisterCallback() takes as parameters the HAL peripheral handle,
    and the callback ID.
    This function allows to reset following callbacks:
      (+) FrameEventCallback : DCMI Frame Event.
      (+) VsyncEventCallback : DCMI Vsync Event.
      (+) LineEventCallback  : DCMI Line Event.
stm32l4xx_hal_dcmi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 124 : 

    By default, after the @ref HAL_DCMI_Init and if the state is HAL_DCMI_STATE_RESET
    all callbacks are reset to the corresponding legacy weak (surcharged) functions:
    examples @ref FrameEventCallback(), @ref HAL_DCMI_ErrorCallback().
    Exception done for MspInit and MspDeInit callbacks that are respectively
    reset to the legacy weak (surcharged) functions in the @ref HAL_DCMI_Init
    and @ref  HAL_DCMI_DeInit only when these callbacks are null (not registered beforehand).
    If not, MspInit or MspDeInit are not null, the @ref HAL_DCMI_Init and @ref HAL_DCMI_DeInit
    keep and use the user MspInit/MspDeInit callbacks (registered beforehand).
stm32l4xx_hal_dcmi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 135 : 
    Exception done for MspInit/MspDeInit callbacks that can be registered/unregistered
    in READY or RESET state, thus registered (user) MspInit/DeInit callbacks can be used
    during the Init/DeInit.
    In that case first register the MspInit/MspDeInit user callbacks
    using @ref HAL_DCMI_RegisterCallback before calling @ref HAL_DCMI_DeInit
HAL_DCMI_Init in stm32l4xx_hal_dcmi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if(hdcmi->State == HAL_DCMI_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hdcmi->Lock = HAL_UNLOCKED;
HAL_DCMI_Init in stm32l4xx_hal_dcmi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Byte select mode must be programmed to the reset value if the extended mode
      is not set to 8-bit data capture on every pixel clock */
    hdcmi->Init.ByteSelectMode = DCMI_BSM_ALL;
  }
stm32l4xx_hal_dcmi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 338 : 
/**
  * @brief  De-initialize the DCMI peripheral, reset control registers to
  *         their default values.
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *               the configuration information for DCMI.
HAL_DCMI_DeInit in stm32l4xx_hal_dcmi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset DCMI control register */
  hdcmi->Instance->CR = 0;

#if (USE_HAL_DCMI_REGISTER_CALLBACKS == 1)
HAL_DCMI_DeInit in stm32l4xx_hal_dcmi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Initialize the DCMI state*/
  hdcmi->State = HAL_DCMI_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(hdcmi);
HAL_DCMI_RegisterCallback in stm32l4xx_hal_dcmi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    }
    else if(hdcmi->State == HAL_DCMI_STATE_RESET)
    {
      switch (CallbackID)
      {
HAL_DCMI_UnRegisterCallback in stm32l4xx_hal_dcmi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if(hdcmi->State == HAL_DCMI_STATE_RESET)
  {
    switch (CallbackID)
    {
stm32l4xx_hal_dcmi.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 117 : 
{
  HAL_DCMI_STATE_RESET             = 0x00U,  /*!< DCMI not yet initialized or disabled  */
  HAL_DCMI_STATE_READY             = 0x01U,  /*!< DCMI initialized and ready for use    */
  HAL_DCMI_STATE_BUSY              = 0x02U,  /*!< DCMI internal processing is ongoing   */
  HAL_DCMI_STATE_TIMEOUT           = 0x03U,  /*!< DCMI timeout state                    */
stm32l4xx_hal_dcmi.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 388 : 

/** @brief Reset DCMI handle state
  * @param  __HANDLE__ specifies the DCMI handle.
  * @retval None
  */
#if (USE_HAL_DCMI_REGISTER_CALLBACKS == 1)
#define __HAL_DCMI_RESET_HANDLE_STATE(__HANDLE__) do{                                            \
                                                     (__HANDLE__)->State = HAL_DCMI_STATE_RESET; \
                                                     (__HANDLE__)->MspInitCallback = NULL;      \
                                                     (__HANDLE__)->MspDeInitCallback = NULL;    \
                                                   } while(0)
#else
#define __HAL_DCMI_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_DCMI_STATE_RESET)
#endif /* USE_HAL_DCMI_REGISTER_CALLBACKS */

/**
stm32l4xx_hal_def.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 70 : 

/** @brief Reset the Handle's State field.
  * @param __HANDLE__: specifies the Peripheral Handle.
  * @note  This macro can be used for the following purpose:
  *          - When the Handle is declared as local variable; before passing it as parameter
stm32l4xx_hal_def.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 85 : 
  */
#define __HAL_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = 0)

#if (USE_RTOS == 1)
  /* Reserved for future use */
stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 197 : 
    Use functions HAL_DFSDM_Channel_UnRegisterCallback() or
    HAL_DFSDM_Filter_UnRegisterCallback() to reset a callback to the default
    weak function.

    [..]
stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 204 : 
    [..]
    This function allows to reset following callbacks:
      (+) CkabCallback      : DFSDM channel clock absence detection callback.
      (+) ScdCallback       : DFSDM channel short circuit detection callback.
      (+) MspInitCallback   : DFSDM channel MSP init callback.
stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 214 : 
    [..]
    This function allows to reset following callbacks:
      (+) RegConvCpltCallback     : DFSDM filter regular conversion complete callback.
      (+) RegConvHalfCpltCallback : DFSDM filter half regular conversion complete callback.
      (+) InjConvCpltCallback     : DFSDM filter injected conversion complete callback.
stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 228 : 
    [..]
    By default, after the call of init function and if the state is RESET
    all callbacks are reset to the corresponding legacy weak functions:
    examples HAL_DFSDM_ChannelScdCallback(), HAL_DFSDM_FilterErrorCallback().
    Exception done for MspInit and MspDeInit callbacks that are respectively
    reset to the legacy weak functions in the init and de-init only when these
    callbacks are null (not registered beforehand).
    If not, MspInit or MspDeInit are not null, the init and de-init keep and use
    the user MspInit/MspDeInit callbacks (registered beforehand)
stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 240 : 
    Exception done for MspInit/MspDeInit callbacks that can be registered/unregistered
    in READY or RESET state, thus registered (user) MspInit/DeInit callbacks can be used
    during the init/de-init.
    In that case first register the MspInit/MspDeInit user callbacks using
    HAL_DFSDM_Channel_RegisterCallback() or
HAL_DFSDM_ChannelInit in stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_HAL_DFSDM_REGISTER_CALLBACKS == 1)
  /* Reset callback pointers to the weak predefined callbacks */
  hdfsdm_channel->CkabCallback = HAL_DFSDM_ChannelCkabCallback;
  hdfsdm_channel->ScdCallback  = HAL_DFSDM_ChannelScdCallback;

HAL_DFSDM_ChannelInit in stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset clock divider */
    DFSDM1_Channel0->CHCFGR1 &= ~(DFSDM_CHCFGR1_CKOUTDIV);
    if (hdfsdm_channel->Init.OutputClock.Activation == ENABLE)
    {
HAL_DFSDM_ChannelDeInit in stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Set DFSDM Channel in reset state */
  hdfsdm_channel->State = HAL_DFSDM_CHANNEL_STATE_RESET;

  /* Reset channel handle in DFSDM channel handle table */
  a_dfsdm1ChannelHandle[DFSDM_GetChannelFromInstance(hdfsdm_channel->Instance)] = (DFSDM_Channel_HandleTypeDef *) NULL;

  return HAL_OK;
HAL_DFSDM_Channel_RegisterCallback in stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    }
    else if (HAL_DFSDM_CHANNEL_STATE_RESET == hdfsdm_channel->State)
    {
      switch (CallbackID)
      {
HAL_DFSDM_Channel_UnRegisterCallback in stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (HAL_DFSDM_CHANNEL_STATE_RESET == hdfsdm_channel->State)
  {
    switch (CallbackID)
    {
HAL_DFSDM_FilterInit in stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_HAL_DFSDM_REGISTER_CALLBACKS == 1)
  /* Reset callback pointers to the weak predefined callbacks */
  hdfsdm_filter->AwdCallback             = HAL_DFSDM_FilterAwdCallback;
  hdfsdm_filter->RegConvCpltCallback     = HAL_DFSDM_FilterRegConvCpltCallback;
  hdfsdm_filter->RegConvHalfCpltCallback = HAL_DFSDM_FilterRegConvHalfCpltCallback;
HAL_DFSDM_FilterDeInit in stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Set DFSDM filter in reset state */
  hdfsdm_filter->State = HAL_DFSDM_FILTER_STATE_RESET;

  return HAL_OK;
}
HAL_DFSDM_Filter_RegisterCallback in stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    }
    else if (HAL_DFSDM_FILTER_STATE_RESET == hdfsdm_filter->State)
    {
      switch (CallbackID)
      {
HAL_DFSDM_Filter_UnRegisterCallback in stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (HAL_DFSDM_FILTER_STATE_RESET == hdfsdm_filter->State)
  {
    switch (CallbackID)
    {
HAL_DFSDM_FilterConfigRegChannel in stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Check DFSDM filter state */
  if ((hdfsdm_filter->State != HAL_DFSDM_FILTER_STATE_RESET) &&
      (hdfsdm_filter->State != HAL_DFSDM_FILTER_STATE_ERROR))
  {
    /* Configure channel and continuous mode for regular conversion */
HAL_DFSDM_FilterConfigInjChannel in stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Check DFSDM filter state */
  if ((hdfsdm_filter->State != HAL_DFSDM_FILTER_STATE_RESET) &&
      (hdfsdm_filter->State != HAL_DFSDM_FILTER_STATE_ERROR))
  {
    /* Configure channel for injected conversion */
HAL_DFSDM_FilterPollForInjConversion in stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

      /* end of injected sequence, reset the value */
      hdfsdm_filter->InjConvRemaining = (hdfsdm_filter->InjectedScanMode == ENABLE) ? \
                                        hdfsdm_filter->InjectedChannelsNbr : 1U;
    }
HAL_DFSDM_FilterAwdStart_IT in stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Check DFSDM filter state */
  if ((hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_RESET) || \
      (hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_ERROR))
  {
    /* Return error status */
HAL_DFSDM_FilterAwdStop_IT in stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Check DFSDM filter state */
  if ((hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_RESET) || \
      (hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_ERROR))
  {
    /* Return error status */
HAL_DFSDM_FilterAwdStop_IT in stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Reset channels for analog watchdog and deactivate interrupt */
    hdfsdm_filter->Instance->FLTCR2 &= ~(DFSDM_FLTCR2_AWDCH | DFSDM_FLTCR2_AWDIE);

    /* Clear all analog watchdog flags */
HAL_DFSDM_FilterAwdStop_IT in stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset thresholds and break signals */
    hdfsdm_filter->Instance->FLTAWHTR &= ~(DFSDM_FLTAWHTR_AWHT | DFSDM_FLTAWHTR_BKAWH);
    hdfsdm_filter->Instance->FLTAWLTR &= ~(DFSDM_FLTAWLTR_AWLT | DFSDM_FLTAWLTR_BKAWL);

    /* Reset analog watchdog data source */
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_AWFSEL);
  }
  /* Return function status */
HAL_DFSDM_FilterExdStart in stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Check DFSDM filter state */
  if ((hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_RESET) || \
      (hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_ERROR))
  {
    /* Return error status */
HAL_DFSDM_FilterExdStop in stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Check DFSDM filter state */
  if ((hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_RESET) || \
      (hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_ERROR))
  {
    /* Return error status */
HAL_DFSDM_FilterExdStop in stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Reset channels for extreme detector */
    hdfsdm_filter->Instance->FLTCR2 &= ~(DFSDM_FLTCR2_EXCH);

    /* Clear extreme detector values */
HAL_DFSDM_IRQHandler in stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      }
      /* end of injected sequence, reset the value */
      hdfsdm_filter->InjConvRemaining = (hdfsdm_filter->InjectedScanMode == ENABLE) ? \
                                        hdfsdm_filter->InjectedChannelsNbr : 1U;
    }
DFSDM_RegConvStop in stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* If regular trigger was synchronous, reset RSYNC bit in DFSDM_FLTCR1 register */
  if (hdfsdm_filter->RegularTrigger == DFSDM_FILTER_SYNC_TRIGGER)
  {
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_RSYNC);
DFSDM_InjConvStop in stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* If injected trigger was synchronous, reset JSYNC bit in DFSDM_FLTCR1 register */
  if (hdfsdm_filter->InjectedTrigger == DFSDM_FILTER_SYNC_TRIGGER)
  {
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_JSYNC);
DFSDM_InjConvStop in stm32l4xx_hal_dfsdm.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Reset JEXTEN[1:0] bits in DFSDM_FLTCR1 register */
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_JEXTEN);
  }
  else
stm32l4xx_hal_dfsdm.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 53 : 
{
  HAL_DFSDM_CHANNEL_STATE_RESET = 0x00U, /*!< DFSDM channel not initialized */
  HAL_DFSDM_CHANNEL_STATE_READY = 0x01U, /*!< DFSDM channel initialized and ready for use */
  HAL_DFSDM_CHANNEL_STATE_ERROR = 0xFFU  /*!< DFSDM channel state error */
} HAL_DFSDM_Channel_StateTypeDef;
stm32l4xx_hal_dfsdm.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 166 : 
{
  HAL_DFSDM_FILTER_STATE_RESET   = 0x00U, /*!< DFSDM filter not initialized */
  HAL_DFSDM_FILTER_STATE_READY   = 0x01U, /*!< DFSDM filter initialized and ready for use */
  HAL_DFSDM_FILTER_STATE_REG     = 0x02U, /*!< DFSDM filter regular conversion in progress */
  HAL_DFSDM_FILTER_STATE_INJ     = 0x03U, /*!< DFSDM filter injected conversion in progress */
stm32l4xx_hal_dfsdm.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 554 : 

/** @brief  Reset DFSDM channel handle state.
  * @param  __HANDLE__ DFSDM channel handle.
  * @retval None
  */
#if (USE_HAL_DFSDM_REGISTER_CALLBACKS == 1)
#define __HAL_DFSDM_CHANNEL_RESET_HANDLE_STATE(__HANDLE__) do{                                                      \
                                                               (__HANDLE__)->State = HAL_DFSDM_CHANNEL_STATE_RESET; \
                                                               (__HANDLE__)->MspInitCallback = NULL;                \
                                                               (__HANDLE__)->MspDeInitCallback = NULL;              \
                                                             } while(0)
#else
#define __HAL_DFSDM_CHANNEL_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_DFSDM_CHANNEL_STATE_RESET)
#endif

/** @brief  Reset DFSDM filter handle state.
  * @param  __HANDLE__ DFSDM filter handle.
  * @retval None
  */
#if (USE_HAL_DFSDM_REGISTER_CALLBACKS == 1)
#define __HAL_DFSDM_FILTER_RESET_HANDLE_STATE(__HANDLE__) do{                                                     \
                                                              (__HANDLE__)->State = HAL_DFSDM_FILTER_STATE_RESET; \
                                                              (__HANDLE__)->MspInitCallback = NULL;               \
                                                              (__HANDLE__)->MspDeInitCallback = NULL;             \
                                                            } while(0)
#else
#define __HAL_DFSDM_FILTER_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_DFSDM_FILTER_STATE_RESET)
#endif

/**
HAL_DMA_Init in stm32l4xx_hal_dma.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset the DMAMUX request generator register*/
    hdma->DMAmuxRequestGen->RGCR = 0U;

    /* Clear the DMAMUX request generator overrun flag */
HAL_DMA_Init in stm32l4xx_hal_dma.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    {
      /* Reset request selection for DMA1 Channelx */
      DMA1_CSELR->CSELR &= ~(DMA_CSELR_C1S << (hdma->ChannelIndex & 0x1cU));

      /* Configure request selection for DMA1 Channelx */
HAL_DMA_Init in stm32l4xx_hal_dma.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    {
      /* Reset request selection for DMA2 Channelx */
      DMA2_CSELR->CSELR &= ~(DMA_CSELR_C1S << (hdma->ChannelIndex & 0x1cU));

      /* Configure request selection for DMA2 Channelx */
HAL_DMA_DeInit in stm32l4xx_hal_dma.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset DMA Channel control register */
  hdma->Instance->CCR = 0U;

  /* Clear all flags */
HAL_DMA_DeInit in stm32l4xx_hal_dma.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset DMA channel selection register */
  if (DMA1 == hdma->DmaBaseAddress)
  {
    /* DMA1 */
HAL_DMA_DeInit in stm32l4xx_hal_dma.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset the DMAMUX channel that corresponds to the DMA channel */
  hdma->DMAmuxChannel->CCR = 0U;

  /* Clear the DMAMUX synchro overrun flag */
HAL_DMA_DeInit in stm32l4xx_hal_dma.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset Request generator parameters if any */
  if(((hdma->Init.Request >  0U) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
  {
    /* Initialize parameters for DMAMUX request generator :
HAL_DMA_DeInit in stm32l4xx_hal_dma.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset the DMAMUX request generator register*/
    hdma->DMAmuxRequestGen->RGCR = 0U;

    /* Clear the DMAMUX request generator overrun flag */
HAL_DMA_DeInit in stm32l4xx_hal_dma.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(hdma);
stm32l4xx_hal_dma.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 81 : 
{
  HAL_DMA_STATE_RESET             = 0x00U,  /*!< DMA not yet initialized or disabled    */
  HAL_DMA_STATE_READY             = 0x01U,  /*!< DMA initialized and ready for use      */
  HAL_DMA_STATE_BUSY              = 0x02U,  /*!< DMA process is ongoing                 */
  HAL_DMA_STATE_TIMEOUT           = 0x03U,  /*!< DMA timeout state                      */
stm32l4xx_hal_dma.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 444 : 

/** @brief  Reset DMA handle state.
  * @param  __HANDLE__ DMA handle
  * @retval None
  */
#define __HAL_DMA_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_DMA_STATE_RESET)

/**
  * @brief  Enable the specified DMA Channel.
stm32l4xx_hal_dma.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 558 : 
  *         Where x can be from 1 to 7 to select the DMA Channel x flag.
  * @retval The state of FLAG (SET or RESET).
  */
#define __HAL_DMA_GET_FLAG(__HANDLE__, __FLAG__) (((uint32_t)((__HANDLE__)->Instance) > ((uint32_t)DMA1_Channel7))? \
 (DMA2->ISR & (__FLAG__)) : (DMA1->ISR & (__FLAG__)))
stm32l4xx_hal_dma.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 610 : 
  *            @arg DMA_IT_TE:  Transfer error interrupt mask
  * @retval The state of DMA_IT (SET or RESET).
  */
#define __HAL_DMA_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)  (((__HANDLE__)->Instance->CCR & (__INTERRUPT__)))

stm32l4xx_hal_dma2d.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 108 : 

      (#) Use function @ref HAL_DMA2D_UnRegisterCallback() to reset a callback to the default
          weak (surcharged) function.
          @ref HAL_DMA2D_UnRegisterCallback() takes as parameters the HAL peripheral handle,
          and the Callback ID.
          This function allows to reset following callbacks:
            (+) XferCpltCallback : callback for transfer complete.
            (+) XferErrorCallback : callback for transfer error.
            (+) LineEventCallback : callback for line event.
stm32l4xx_hal_dma2d.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 120 : 

      (#) By default, after the @ref HAL_DMA2D_Init and if the state is HAL_DMA2D_STATE_RESET
          all callbacks are reset to the corresponding legacy weak (surcharged) functions:
          examples @ref HAL_DMA2D_LineEventCallback(), @ref HAL_DMA2D_CLUTLoadingCpltCallback()
          Exception done for MspInit and MspDeInit callbacks that are respectively
          reset to the legacy weak (surcharged) functions in the @ref HAL_DMA2D_Init
          and @ref HAL_DMA2D_DeInit only when these callbacks are null (not registered beforehand)
          If not, MspInit or MspDeInit are not null, the @ref HAL_DMA2D_Init and @ref HAL_DMA2D_DeInit
          keep and use the user MspInit/MspDeInit callbacks (registered beforehand).
stm32l4xx_hal_dma2d.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 134 : 
          Exception done for MspInit/MspDeInit callbacks that can be registered/unregistered
          in READY or RESET state, thus registered (user) MspInit/DeInit callbacks can be used
          during the Init/DeInit.
          In that case first register the MspInit/MspDeInit user callbacks
          using @ref HAL_DMA2D_RegisterCallback before calling @ref HAL_DMA2D_DeInit
HAL_DMA2D_Init in stm32l4xx_hal_dma2d.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_HAL_DMA2D_REGISTER_CALLBACKS == 1)
  if (hdma2d->State == HAL_DMA2D_STATE_RESET)
  {
    /* Reset Callback pointers in HAL_DMA2D_STATE_RESET only */
    hdma2d->LineEventCallback       = HAL_DMA2D_LineEventCallback;
    hdma2d->CLUTLoadingCpltCallback = HAL_DMA2D_CLUTLoadingCpltCallback;
    if(hdma2d->MspInitCallback == NULL)
HAL_DMA2D_Init in stm32l4xx_hal_dma2d.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#else
  if(hdma2d->State == HAL_DMA2D_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hdma2d->Lock = HAL_UNLOCKED;
stm32l4xx_hal_dma2d.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 315 : 
/**
  * @brief  Deinitializes the DMA2D peripheral registers to their default reset
  *         values.
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
HAL_DMA2D_DeInit in stm32l4xx_hal_dma2d.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset DMA2D control registers*/
  hdma2d->Instance->CR       =    0U;
  hdma2d->Instance->IFCR     = 0x3FU;
  hdma2d->Instance->FGOR     =    0U;
HAL_DMA2D_DeInit in stm32l4xx_hal_dma2d.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Initialize the DMA2D state*/
  hdma2d->State  = HAL_DMA2D_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(hdma2d);
HAL_DMA2D_RegisterCallback in stm32l4xx_hal_dma2d.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if(HAL_DMA2D_STATE_RESET == hdma2d->State)
  {
    switch (CallbackID)
    {
HAL_DMA2D_UnRegisterCallback in stm32l4xx_hal_dma2d.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if(HAL_DMA2D_STATE_RESET == hdma2d->State)
  {
    switch (CallbackID)
    {
HAL_DMA2D_Abort in stm32l4xx_hal_dma2d.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Abort the DMA2D transfer */
  /* START bit is reset to make sure not to set it again, in the event the HW clears it
     between the register read and the register write by the CPU (writing 0 has no
     effect on START bitvalue) */
   MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_ABORT|DMA2D_CR_START, DMA2D_CR_ABORT);
HAL_DMA2D_Suspend in stm32l4xx_hal_dma2d.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Suspend the DMA2D transfer */
  /* START bit is reset to make sure not to set it again, in the event the HW clears it
     between the register read and the register write by the CPU (writing 0 has no
     effect on START bitvalue). */
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_SUSP|DMA2D_CR_START, DMA2D_CR_SUSP);
HAL_DMA2D_Resume in stm32l4xx_hal_dma2d.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Resume the DMA2D transfer */
  /* START bit is reset to make sure not to set it again, in the event the HW clears it
     between the register read and the register write by the CPU (writing 0 has no
     effect on START bitvalue). */
  CLEAR_BIT(hdma2d->Instance->CR, (DMA2D_CR_SUSP|DMA2D_CR_START));
stm32l4xx_hal_dma2d.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 145 : 
{
  HAL_DMA2D_STATE_RESET             = 0x00U,    /*!< DMA2D not yet initialized or disabled       */
  HAL_DMA2D_STATE_READY             = 0x01U,    /*!< Peripheral Initialized and ready for use    */
  HAL_DMA2D_STATE_BUSY              = 0x02U,    /*!< An internal process is ongoing              */
  HAL_DMA2D_STATE_TIMEOUT           = 0x03U,    /*!< Timeout state                               */
stm32l4xx_hal_dma2d.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 383 : 

/** @brief Reset DMA2D handle state
  * @param  __HANDLE__ specifies the DMA2D handle.
  * @retval None
  */
#if (USE_HAL_DMA2D_REGISTER_CALLBACKS == 1)
#define __HAL_DMA2D_RESET_HANDLE_STATE(__HANDLE__) do{                                            \
                                                      (__HANDLE__)->State = HAL_DMA2D_STATE_RESET;\
                                                      (__HANDLE__)->MspInitCallback = NULL;       \
                                                      (__HANDLE__)->MspDeInitCallback = NULL;     \
                                                     }while(0)
#else
#define __HAL_DMA2D_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_DMA2D_STATE_RESET)
#endif /* USE_HAL_DMA2D_REGISTER_CALLBACKS */


HAL_DMAEx_EnableMuxRequestGenerator in stm32l4xx_hal_dma_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  */
  if((hdma->State != HAL_DMA_STATE_RESET) && (hdma->DMAmuxRequestGen != 0))
  {

    /* Enable the request generator*/
HAL_DMAEx_DisableMuxRequestGenerator in stm32l4xx_hal_dma_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  */
  if((hdma->State != HAL_DMA_STATE_RESET) && (hdma->DMAmuxRequestGen != 0))
  {

    /* Disable the request generator*/
stm32l4xx_hal_dsi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 104 : 
    [..]
    Use function HAL_DSI_UnRegisterCallback() to reset a callback to the default
    weak function.
    HAL_DSI_UnRegisterCallback takes as parameters the HAL peripheral handle,
    and the callback ID.
    [..]
    This function allows to reset following callbacks:
      (+) TearingEffectCallback : DSI Tearing Effect Callback.
      (+) EndOfRefreshCallback  : DSI End Of Refresh Callback.
      (+) ErrorCallback         : DSI Error Callback
stm32l4xx_hal_dsi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 117 : 
    [..]
    By default, after the HAL_DSI_Init and when the state is HAL_DSI_STATE_RESET
    all callbacks are set to the corresponding weak functions:
    examples HAL_DSI_TearingEffectCallback(), HAL_DSI_EndOfRefreshCallback().
    Exception done for MspInit and MspDeInit functions that are respectively
    reset to the legacy weak (surcharged) functions in the HAL_DSI_Init()
    and HAL_DSI_DeInit() only when these callbacks are null (not registered beforehand).
    If not, MspInit or MspDeInit are not null, the HAL_DSI_Init() and HAL_DSI_DeInit()
    keep and use the user MspInit/MspDeInit callbacks (registered beforehand).
stm32l4xx_hal_dsi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 129 : 
    Exception done MspInit/MspDeInit that can be registered/unregistered
    in HAL_DSI_STATE_READY or HAL_DSI_STATE_RESET state,
    thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
    In that case first register the MspInit/MspDeInit user callbacks
    using HAL_DSI_RegisterCallback() before calling HAL_DSI_DeInit()
HAL_DSI_Init in stm32l4xx_hal_dsi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_HAL_DSI_REGISTER_CALLBACKS == 1)
  if (hdsi->State == HAL_DSI_STATE_RESET)
  {
    /* Reset the DSI callback to the legacy weak callbacks */
    hdsi->TearingEffectCallback = HAL_DSI_TearingEffectCallback; /* Legacy weak TearingEffectCallback */
    hdsi->EndOfRefreshCallback  = HAL_DSI_EndOfRefreshCallback;  /* Legacy weak EndOfRefreshCallback  */
    hdsi->ErrorCallback         = HAL_DSI_ErrorCallback;         /* Legacy weak ErrorCallback         */
HAL_DSI_Init in stm32l4xx_hal_dsi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#else
  if (hdsi->State == HAL_DSI_STATE_RESET)
  {
    /* Initialize the low level hardware */
    HAL_DSI_MspInit(hdsi);
HAL_DSI_Init in stm32l4xx_hal_dsi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Disable all error interrupts and reset the Error Mask */
  hdsi->Instance->IER[0U] = 0U;
  hdsi->Instance->IER[1U] = 0U;
  hdsi->ErrorMsk = 0U;
stm32l4xx_hal_dsi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 431 : 
/**
  * @brief  De-initializes the DSI peripheral registers to their default reset
  *         values.
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
HAL_DSI_DeInit in stm32l4xx_hal_dsi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Initialize the DSI state*/
  hdsi->State = HAL_DSI_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(hdsi);
HAL_DSI_RegisterCallback in stm32l4xx_hal_dsi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (hdsi->State == HAL_DSI_STATE_RESET)
  {
    switch (CallbackID)
    {
HAL_DSI_UnRegisterCallback in stm32l4xx_hal_dsi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (hdsi->State == HAL_DSI_STATE_RESET)
  {
    switch (CallbackID)
    {
HAL_DSI_ConfigVideoMode in stm32l4xx_hal_dsi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Select video mode by resetting CMDM and DSIM bits */
  hdsi->Instance->MCR &= ~DSI_MCR_CMDM;
  hdsi->Instance->WCFGR &= ~DSI_WCFGR_DSIM;

stm32l4xx_hal_dsi.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 292 : 
{
  HAL_DSI_STATE_RESET   = 0x00U,
  HAL_DSI_STATE_READY   = 0x01U,
  HAL_DSI_STATE_ERROR   = 0x02U,
  HAL_DSI_STATE_BUSY    = 0x03U,
stm32l4xx_hal_dsi.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 396 : 
#define DSI_SET_VSYNC_TIMING      0x40U
#define DSI_SOFT_RESET            0x01U
#define DSI_WRITE_LUT             0x2DU
#define DSI_WRITE_MEMORY_CONTINUE 0x3CU
#define DSI_WRITE_MEMORY_START    0x2CU
stm32l4xx_hal_dsi.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 924 : 
/**
  * @brief Reset DSI handle state.
  * @param  __HANDLE__: DSI handle
  * @retval None
  */
#if (USE_HAL_DSI_REGISTER_CALLBACKS == 1)
#define __HAL_DSI_RESET_HANDLE_STATE(__HANDLE__) do{                                               \
                                                     (__HANDLE__)->State = HAL_DSI_STATE_RESET;    \
                                                     (__HANDLE__)->MspInitCallback = NULL;         \
                                                     (__HANDLE__)->MspDeInitCallback = NULL;       \
                                                   } while(0)
#else
#define __HAL_DSI_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_DSI_STATE_RESET)
#endif /*USE_HAL_DSI_REGISTER_CALLBACKS */

/**
stm32l4xx_hal_dsi.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1055 : 
  *            @arg DSI_FLAG_RR   : Regulator Ready Interrupt Flag
  * @retval The state of FLAG (SET or RESET).
  */
#define __HAL_DSI_GET_FLAG(__HANDLE__, __FLAG__) ((__HANDLE__)->Instance->WISR & (__FLAG__))

stm32l4xx_hal_dsi.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1111 : 
  *            @arg DSI_IT_RR  : Regulator Ready Interrupt
  * @retval The state of INTERRUPT (SET or RESET).
  */
#define __HAL_DSI_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((__HANDLE__)->Instance->WIER & (__INTERRUPT__))

HAL_FIREWALL_Config in stm32l4xx_hal_firewall.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Make sure that Firewall is not enabled already */
  if (__HAL_FIREWALL_IS_ENABLED() != RESET)
  {
    return HAL_ERROR;
  }
stm32l4xx_hal_firewall.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 217 : 
  *       Once enabled, the Firewall cannot be disabled by software. Only a
  *       system reset can set again FWDIS bit.
  * @retval None
  */
void HAL_FIREWALL_EnableFirewall(void)
stm32l4xx_hal_firewall.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 254 : 
  * @brief Disable FIREWALL pre arm.
  * @note When FPA bit is reset, any code executed outside the protected segment
  *       when the Firewall is opened will generate a system reset.
  * @note This API provides the same service as __HAL_FIREWALL_PREARM_DISABLE() macro
  *       but can't be executed inside a code area protected by the Firewall.
  * @note When the Firewall is disabled, user can resort to HAL_FIREWALL_EnablePreArmFlag() API any time.
stm32l4xx_hal_firewall.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 108 : 
  */
#define FIREWALL_PRE_ARM_RESET                 ((uint32_t)0x0000)
#define FIREWALL_PRE_ARM_SET                   ((uint32_t)FW_CR_FPA)

/**
stm32l4xx_hal_firewall.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 156 : 
  * @note When FPA bit is set, any code executed outside the protected segment
  *       closes the Firewall, otherwise it generates a system reset.
  * @note This macro provides the same service as HAL_FIREWALL_EnablePreArmFlag() API
  *       but can be executed inside a code area protected by the Firewall.
  * @note This macro can be executed whatever the Firewall state (opened or closed) when
stm32l4xx_hal_firewall.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 178 : 
  * @note When FPA bit is set, any code executed outside the protected segment
  *       closes the Firewall, otherwise, it generates a system reset.
  * @note This macro provides the same service as HAL_FIREWALL_DisablePreArmFlag() API
  *       but can be executed inside a code area protected by the Firewall.
  * @note This macro can be executed whatever the Firewall state (opened or closed) when
stm32l4xx_hal_firewall.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 215 : 

/** @brief Disable volatile data sharing in resetting VDS bit.
  * @note When VDS bit is reset, the volatile data segment is not shared and cannot be
  *       hit by a non protected executable code when the Firewall is closed. If it is
  *       accessed in such a condition, a system reset is generated by the Firewall.
  * @note This macro can be executed inside a code area protected by the Firewall.
  * @note This macro can be executed whatever the Firewall state (opened or closed) when
  *       NVDSL register is equal to 0. Otherwise (when NVDSL register is different from
stm32l4xx_hal_firewall.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 257 : 

/** @brief Disable volatile data execution in resetting VDE bit.
  * @note VDE bit is ignored when VDS is set. IF VDS = 1, the Volatile data segment can be
  *       executed whatever the VDE bit value.
  * @note When VDE bit is reset (with VDS = 0), the volatile data segment cannot  be executed.
  * @note This macro can be executed inside a code area protected by the Firewall.
  * @note This macro can be executed whatever the Firewall state (opened or closed) when
  *       NVDSL register is equal to 0. Otherwise (when NVDSL register is different from
stm32l4xx_hal_flash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 60 : 
           (++) Launch the reload of the option bytes using HAL_FLASH_Launch() function.
                In this case, a reset is generated

    [..]
      In addition to these functions, this driver includes a set of macros allowing
stm32l4xx_hal_flash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 68 : 
       (+) Enable/Disable the Instruction cache and the Data cache
       (+) Reset the Instruction cache and the Data cache
       (+) Enable/Disable the Flash power-down during low-power run and sleep modes
       (+) Enable/Disable the Flash interrupts
       (+) Monitor the Flash flags status
HAL_FLASH_IRQHandler in stm32l4xx_hal_flash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
        /* No more pages to Erase */
        /* Reset Address and stop Erase pages procedure */
        pFlash.Page = 0xFFFFFFFFU;
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;

FLASH_WaitForLastOperation in stm32l4xx_hal_flash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
{
  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */

  uint32_t tickstart = HAL_GetTick();
stm32l4xx_hal_flash.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 247 : 
  */
#define OB_USER_BOR_LEV           ((uint32_t)0x0001)                   /*!< BOR reset Level */
#define OB_USER_nRST_STOP         ((uint32_t)0x0002)                   /*!< Reset generated when entering the stop mode */
#define OB_USER_nRST_STDBY        ((uint32_t)0x0004)                   /*!< Reset generated when entering the standby mode */
#define OB_USER_IWDG_SW           ((uint32_t)0x0008)                   /*!< Independent watchdog selection */
#define OB_USER_IWDG_STOP         ((uint32_t)0x0010)                   /*!< Independent watchdog counter freeze in stop mode */
#define OB_USER_IWDG_STDBY        ((uint32_t)0x0020)                   /*!< Independent watchdog counter freeze in standby mode */
stm32l4xx_hal_flash.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 266 : 
#define OB_USER_SRAM2_PE          ((uint32_t)0x0400)                   /*!< SRAM2 parity check enable */
#define OB_USER_SRAM2_RST         ((uint32_t)0x0800)                   /*!< SRAM2 Erase when system reset */
#define OB_USER_nRST_SHDW         ((uint32_t)0x1000)                   /*!< Reset generated when entering the shutdown mode */
#if defined (STM32L412xx) || defined (STM32L422xx) || defined (STM32L431xx) || defined (STM32L432xx) || defined (STM32L433xx) || \
    defined (STM32L442xx) || defined (STM32L443xx) || defined (STM32L451xx) || defined (STM32L452xx) || defined (STM32L462xx) || \
    defined (STM32L496xx) || defined (STM32L4A6xx) || defined (STM32L4R5xx) || \
stm32l4xx_hal_flash.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 285 : 
  */
#define OB_BOR_LEVEL_0            ((uint32_t)FLASH_OPTR_BOR_LEV_0)     /*!< Reset level threshold is around 1.7V */
#define OB_BOR_LEVEL_1            ((uint32_t)FLASH_OPTR_BOR_LEV_1)     /*!< Reset level threshold is around 2.0V */
#define OB_BOR_LEVEL_2            ((uint32_t)FLASH_OPTR_BOR_LEV_2)     /*!< Reset level threshold is around 2.2V */
#define OB_BOR_LEVEL_3            ((uint32_t)FLASH_OPTR_BOR_LEV_3)     /*!< Reset level threshold is around 2.5V */
#define OB_BOR_LEVEL_4            ((uint32_t)FLASH_OPTR_BOR_LEV_4)     /*!< Reset level threshold is around 2.8V */
/**
  * @}
  */

/** @defgroup FLASH_OB_USER_nRST_STOP FLASH Option Bytes User Reset On Stop
  * @{
  */
#define OB_STOP_RST               ((uint32_t)0x0000)                   /*!< Reset generated when entering the stop mode */
#define OB_STOP_NORST             ((uint32_t)FLASH_OPTR_nRST_STOP)     /*!< No reset generated when entering the stop mode */
/**
  * @}
  */

/** @defgroup FLASH_OB_USER_nRST_STANDBY FLASH Option Bytes User Reset On Standby
  * @{
  */
#define OB_STANDBY_RST            ((uint32_t)0x0000)                   /*!< Reset generated when entering the standby mode */
#define OB_STANDBY_NORST          ((uint32_t)FLASH_OPTR_nRST_STDBY)    /*!< No reset generated when entering the standby mode */
/**
  * @}
  */

/** @defgroup FLASH_OB_USER_nRST_SHUTDOWN FLASH Option Bytes User Reset On Shutdown
  * @{
  */
#define OB_SHUTDOWN_RST           ((uint32_t)0x0000)                   /*!< Reset generated when entering the shutdown mode */
#define OB_SHUTDOWN_NORST         ((uint32_t)FLASH_OPTR_nRST_SHDW)     /*!< No reset generated when entering the shutdown mode */
/**
  * @}
  */
stm32l4xx_hal_flash.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 417 : 

/** @defgroup FLASH_OB_USER_SRAM2_RST FLASH Option Bytes User SRAM2 Erase On Reset Type
  * @{
  */
#define OB_SRAM2_RST_ERASE        ((uint32_t)0x0000000)                /*!< SRAM2 erased when a system reset occurs */
#define OB_SRAM2_RST_NOT_ERASE    ((uint32_t)FLASH_OPTR_SRAM2_RST)     /*!< SRAM2 is not erased when a system reset occurs */
/**
  * @}
  */
stm32l4xx_hal_flash.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 442 : 
  */
#define OB_BOOT0_RESET            ((uint32_t)0x0000000)                /*!< nBOOT0 = 0 */
#define OB_BOOT0_SET              ((uint32_t)FLASH_OPTR_nBOOT0)        /*!< nBOOT0 = 1 */
/**
  * @}
stm32l4xx_hal_flash.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 624 : 
/**
  * @brief  Reset the FLASH instruction Cache.
  * @note   This function must be used only when the Instruction Cache is disabled.
  * @retval None
  */
#define __HAL_FLASH_INSTRUCTION_CACHE_RESET()   do { SET_BIT(FLASH->ACR, FLASH_ACR_ICRST);   \
                                                     CLEAR_BIT(FLASH->ACR, FLASH_ACR_ICRST); \
                                                   } while (0)

/**
  * @brief  Reset the FLASH data Cache.
  * @note   This function must be used only when the data Cache is disabled.
  * @retval None
  */
#define __HAL_FLASH_DATA_CACHE_RESET()          do { SET_BIT(FLASH->ACR, FLASH_ACR_DCRST);   \
                                                     CLEAR_BIT(FLASH->ACR, FLASH_ACR_DCRST); \
                                                   } while (0)

stm32l4xx_hal_flash.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 729 : 
  *     @arg FLASH_FLAG_ECCD: FLASH two ECC errors have been detected
  * @retval The new state of FLASH_FLAG (SET or RESET).
  */
#define __HAL_FLASH_GET_FLAG(__FLAG__)          ((((__FLAG__) & (FLASH_FLAG_ECCC | FLASH_FLAG_ECCD)) != 0U) ? \
                                                 (READ_BIT(FLASH->ECCR, (__FLAG__)) == (__FLAG__))          : \
stm32l4xx_hal_flash.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 997 : 

#define IS_OB_USER_BOOT0(VALUE)            (((VALUE) == OB_BOOT0_RESET) || ((VALUE) == OB_BOOT0_SET))
#endif

#define IS_OB_PCROP_RDP(VALUE)             (((VALUE) == OB_PCROP_RDP_NOT_ERASE) || ((VALUE) == OB_PCROP_RDP_ERASE))
stm32l4xx_hal_flash_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 35 : 
      (#) Option Bytes Programming function: Use HAL_FLASHEx_OBProgram() to :
        (++) Set/Reset the write protection
        (++) Set the Read protection Level
        (++) Program the user Option Bytes
        (++) Configure the PCROP protection
FLASH_FlushCaches in stm32l4xx_hal_flash_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Reset instruction cache */
    __HAL_FLASH_INSTRUCTION_CACHE_RESET();
    /* Enable instruction cache */
    __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
  }
FLASH_FlushCaches in stm32l4xx_hal_flash_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Reset data cache */
    __HAL_FLASH_DATA_CACHE_RESET();
    /* Enable data cache */
    __HAL_FLASH_DATA_CACHE_ENABLE();
  }

  /* Reset internal variable */
  pFlash.CacheToReactivate = FLASH_CACHE_DISABLED;
}

HAL_FLASHEx_OB_DBankConfig in stm32l4xx_hal_flash_ramfunc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
        /* Flush Flash instruction cache */
        __HAL_FLASH_INSTRUCTION_CACHE_RESET();
      }

      if (READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != 0U)
HAL_FLASHEx_OB_DBankConfig in stm32l4xx_hal_flash_ramfunc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
        /* Flush Flash data cache */
        __HAL_FLASH_DATA_CACHE_RESET();
      }

      /* Disable WRP zone 1 of 1st bank if needed */
HAL_FLASHEx_OB_DBankConfig in stm32l4xx_hal_flash_ramfunc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
        count--;
      } while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET);

      /* If the option byte program operation is completed, disable the OPTSTRT Bit */
      CLEAR_BIT(FLASH->CR, FLASH_CR_OPTSTRT);
stm32l4xx_hal_gfxmmu.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 72 : 
    [..]
    Use function HAL_GFXMMU_UnRegisterCallback() to reset a callback to the default
    weak (surcharged) function.
    HAL_GFXMMU_UnRegisterCallback() takes as parameters the HAL peripheral handle,
    and the callback ID.
    [..]
    This function allows to reset following callbacks:
      (+) ErrorCallback      : GFXMMU error.
      (+) MspInitCallback    : GFXMMU MspInit.
      (+) MspDeInitCallback  : GFXMMU MspDeInit.
stm32l4xx_hal_gfxmmu.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 83 : 
    [..]
    By default, after the HAL_GFXMMU_Init and if the state is HAL_GFXMMU_STATE_RESET
    all callbacks are reset to the corresponding legacy weak (surcharged) functions:
    examples HAL_GFXMMU_ErrorCallback().
    Exception done for MspInit and MspDeInit callbacks that are respectively
    reset to the legacy weak (surcharged) functions in the HAL_GFXMMU_Init
    and HAL_GFXMMU_DeInit only when these callbacks are null (not registered beforehand).
    If not, MspInit or MspDeInit are not null, the HAL_GFXMMU_Init and HAL_GFXMMU_DeInit
    keep and use the user MspInit/MspDeInit callbacks (registered beforehand).
stm32l4xx_hal_gfxmmu.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 95 : 
    Exception done for MspInit/MspDeInit callbacks that can be registered/unregistered
    in READY or RESET state, thus registered (user) MspInit/DeInit callbacks can be used
    during the Init/DeInit.
    In that case first register the MspInit/MspDeInit user callbacks
    using HAL_GFXMMU_RegisterCallback before calling HAL_GFXMMU_DeInit
HAL_GFXMMU_Init in stm32l4xx_hal_gfxmmu.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_HAL_GFXMMU_REGISTER_CALLBACKS == 1)
    /* Reset callback pointers to the weak predefined callbacks */
    hgfxmmu->ErrorCallback = HAL_GFXMMU_ErrorCallback;

    /* Call GFXMMU MSP init function */
HAL_GFXMMU_Init in stm32l4xx_hal_gfxmmu.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    
    /* Reset GFXMMU error code */
    hgfxmmu->ErrorCode = GFXMMU_ERROR_NONE;
    
    /* Set GFXMMU to ready state */
HAL_GFXMMU_DeInit in stm32l4xx_hal_gfxmmu.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    
    /* Set GFXMMU to reset state */
    hgfxmmu->State = HAL_GFXMMU_STATE_RESET;
  }
  /* Return function status */
  return status;
HAL_GFXMMU_RegisterCallback in stm32l4xx_hal_gfxmmu.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    }
    else if(HAL_GFXMMU_STATE_RESET == hgfxmmu->State)
    {
      switch (CallbackID)
      {
HAL_GFXMMU_UnRegisterCallback in stm32l4xx_hal_gfxmmu.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if(HAL_GFXMMU_STATE_RESET == hgfxmmu->State)
  {
    switch (CallbackID)
    {
HAL_GFXMMU_GetError in stm32l4xx_hal_gfxmmu.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  
  /* Store and reset GFXMMU error code */
  error_code = hgfxmmu->ErrorCode;
  hgfxmmu->ErrorCode = GFXMMU_ERROR_NONE;
  
stm32l4xx_hal_gfxmmu.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 50 : 
{
  HAL_GFXMMU_STATE_RESET = 0x00U, /*!< GFXMMU not initialized */
  HAL_GFXMMU_STATE_READY = 0x01U, /*!< GFXMMU initialized and ready for use */
}HAL_GFXMMU_StateTypeDef;

stm32l4xx_hal_gfxmmu.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 210 : 

/** @brief  Reset GFXMMU handle state.
  * @param  __HANDLE__ GFXMMU handle.
  * @retval None
  */
#if (USE_HAL_GFXMMU_REGISTER_CALLBACKS == 1)
#define __HAL_GFXMMU_RESET_HANDLE_STATE(__HANDLE__) do{                                               \
                                                        (__HANDLE__)->State = HAL_GFXMMU_STATE_RESET; \
                                                        (__HANDLE__)->MspInitCallback = NULL;         \
                                                        (__HANDLE__)->MspDeInitCallback = NULL;       \
                                                      } while(0)
#else
#define __HAL_GFXMMU_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_GFXMMU_STATE_RESET)
#endif

/**
stm32l4xx_hal_gpio.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 23 : 

    (+) During and just after reset, the alternate functions and external interrupt
        lines are not active and the I/O ports are configured in input floating mode.

    (+) All GPIO pins have weak internal pull-up and pull-down resistors, which can be
stm32l4xx_hal_gpio.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 72 : 

    (#) To set/reset the level of a pin configured in output mode use
        HAL_GPIO_WritePin()/HAL_GPIO_TogglePin().

   (#) To lock pin configuration until next reset use HAL_GPIO_LockPin().

    (#) During and just after reset, the alternate functions are not
        active and the GPIO pins are configured in input floating mode (except JTAG
        pins).

stm32l4xx_hal_gpio.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 304 : 
/**
  * @brief  De-initialize the GPIOx peripheral registers to their default reset values.
  * @param  GPIOx: where x can be (A..H) to select the GPIO peripheral for STM32L4 family
  * @param  GPIO_Pin: specifies the port bit to be written.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
HAL_GPIO_ReadPin in stm32l4xx_hal_gpio.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
stm32l4xx_hal_gpio.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 426 : 
  *         This parameter can be one of the GPIO_PinState enum values:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
HAL_GPIO_WritePin in stm32l4xx_hal_gpio.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if(PinState != GPIO_PIN_RESET)
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
  }
stm32l4xx_hal_gpio.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 472 : 
  * @note   The configuration of the locked GPIO pins can no longer be modified
  *         until the next reset.
  * @param  GPIOx where x can be (A..H) to select the GPIO peripheral for STM32L4 family
  * @param  GPIO_Pin specifies the port bits to be locked.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
HAL_GPIO_LockPin in stm32l4xx_hal_gpio.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  GPIOx->LCKR = tmp;
  /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
  GPIOx->LCKR = GPIO_Pin;
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
stm32l4xx_hal_gpio.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 65 : 
/**
  * @brief  GPIO Bit SET and Bit RESET enumeration
  */
typedef enum
{
  GPIO_PIN_RESET = 0U,
  GPIO_PIN_SET
}GPIO_PinState;
/**
stm32l4xx_hal_gpio.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 169 : 
  *         This parameter can be GPIO_PIN_x where x can be(0..15)
  * @retval The new state of __EXTI_LINE__ (SET or RESET).
  */
#define __HAL_GPIO_EXTI_GET_FLAG(__EXTI_LINE__)       (EXTI->PR1 & (__EXTI_LINE__))

stm32l4xx_hal_gpio.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 185 : 
  *          This parameter can be GPIO_PIN_x where x can be(0..15)
  * @retval The new state of __EXTI_LINE__ (SET or RESET).
  */
#define __HAL_GPIO_EXTI_GET_IT(__EXTI_LINE__)         (EXTI->PR1 & (__EXTI_LINE__))

stm32l4xx_hal_gpio.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 213 : 
  */
#define IS_GPIO_PIN_ACTION(ACTION)  (((ACTION) == GPIO_PIN_RESET) || ((ACTION) == GPIO_PIN_SET))

#define IS_GPIO_PIN(__PIN__)        ((((uint32_t)(__PIN__) & GPIO_PIN_MASK) != 0x00U) &&\
                                     (((uint32_t)(__PIN__) & ~GPIO_PIN_MASK) == 0x00U))
stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 75 : 
             From that point, each buffer can be fed to the Peripheral thru HAL_HASH_xxx_Start_DMA() API.
             Before entering the last buffer, reset the MDMAT bit with __HAL_HASH_RESET_MDMAT()
             macro then wrap-up the HASH processing in feeding the last input buffer thru the
             same API HAL_HASH_xxx_Start_DMA(). The digest can then be retrieved with a call to
             API HAL_HASH_xxx_Finish().
stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 157 : 

      (#) Use function @ref HAL_HASH_UnRegisterCallback() to reset a callback to the default
          weak (surcharged) function.
          @ref HAL_HASH_UnRegisterCallback() takes as parameters the HAL peripheral handle,
          and the Callback ID.
          This function allows to reset following callbacks:
            (+) InCpltCallback    : callback for input completion.
            (+) DgstCpltCallback  : callback for digest computation completion.
            (+) ErrorCallback     : callback for error.
stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 168 : 

      (#) By default, after the @ref HAL_HASH_Init and if the state is HAL_HASH_STATE_RESET
          all callbacks are reset to the corresponding legacy weak (surcharged) functions:
          examples @ref HAL_HASH_InCpltCallback(), @ref HAL_HASH_DgstCpltCallback()
          Exception done for MspInit and MspDeInit callbacks that are respectively
          reset to the legacy weak (surcharged) functions in the @ref HAL_HASH_Init
          and @ref HAL_HASH_DeInit only when these callbacks are null (not registered beforehand)
          If not, MspInit or MspDeInit are not null, the @ref HAL_HASH_Init and @ref HAL_HASH_DeInit
          keep and use the user MspInit/MspDeInit callbacks (registered beforehand).
stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 179 : 
          Exception done for MspInit/MspDeInit callbacks that can be registered/unregistered
          in READY or RESET state, thus registered (user) MspInit/DeInit callbacks can be used
          during the Init/DeInit.
          In that case first register the MspInit/MspDeInit user callbacks
          using @ref HAL_HASH_RegisterCallback before calling @ref HAL_HASH_DeInit
stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 316 : 
  *         other configuration bits are set by HASH or HMAC processing APIs.
  * @note   MDMAT bit is systematically reset by HAL_HASH_Init(). To set it for
  *         multi-buffer HASH processing, user needs to resort to
  *         __HAL_HASH_SET_MDMAT() macro. For HMAC multi-buffer processing, the
  *         relevant APIs manage themselves the MDMAT bit.
HAL_HASH_Init in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_HAL_HASH_REGISTER_CALLBACKS == 1)
  if (hhash->State == HAL_HASH_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hhash->Lock = HAL_UNLOCKED;

    /* Reset Callback pointers in HAL_HASH_STATE_RESET only */
    hhash->InCpltCallback =  HAL_HASH_InCpltCallback;     /* Legacy weak (surcharged) input completion callback */
    hhash->DgstCpltCallback =  HAL_HASH_DgstCpltCallback; /* Legacy weak (surcharged) digest computation completion callback */
    hhash->ErrorCallback =  HAL_HASH_ErrorCallback;       /* Legacy weak (surcharged) error callback */
HAL_HASH_Init in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#else
  if(hhash->State == HAL_HASH_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hhash->Lock = HAL_UNLOCKED;
HAL_HASH_Init in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset HashInCount, HashITCounter, HashBuffSize and NbWordsAlreadyPushed */
  hhash->HashInCount = 0;
  hhash->HashBuffSize = 0;
  hhash->HashITCounter = 0;
  hhash->NbWordsAlreadyPushed = 0;
  /* Reset digest calculation bridle (MDMAT bit control) */
  hhash->DigestCalculationDisable = RESET;
  /* Set phase to READY */
  hhash->Phase = HAL_HASH_PHASE_READY;

HAL_HASH_Init in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  MODIFY_REG(HASH->CR, HASH_CR_DATATYPE, hhash->Init.DataType);
  /* Reset MDMAT bit */
__HAL_HASH_RESET_MDMAT();
  /* Reset HASH handle status */
  hhash->Status = HAL_OK;

  /* Set the HASH state to Ready */
HAL_HASH_DeInit in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset HashInCount, HashITCounter and HashBuffSize */
  hhash->HashInCount = 0;
  hhash->HashBuffSize = 0;
  hhash->HashITCounter = 0;
  /* Reset digest calculation bridle (MDMAT bit control) */
  hhash->DigestCalculationDisable = RESET;

#if (USE_HAL_HASH_REGISTER_CALLBACKS == 1)
    if(hhash->MspDeInitCallback == NULL)
HAL_HASH_DeInit in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset HASH handle status */
  hhash->Status = HAL_OK;

  /* Set the HASH state to Ready */
  hhash->State = HAL_HASH_STATE_RESET;

  /* Initialise the error code */
  hhash->ErrorCode = HAL_HASH_ERROR_NONE;

  /* Reset multi buffers accumulation flag */
  hhash->Accumulation = 0U;

  /* Return function status */
HAL_HASH_RegisterCallback in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if(HAL_HASH_STATE_RESET == hhash->State)
  {
    switch (CallbackID)
    {
HAL_HASH_UnRegisterCallback in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if(HAL_HASH_STATE_RESET == hhash->State)
  {
    switch (CallbackID)
    {
HAL_HASH_IRQHandler in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#endif /* USE_HAL_HASH_REGISTER_CALLBACKS */
    /* After error handling by code user, reset HASH handle HAL status */
    hhash->Status = HAL_OK;
  }
}
stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 982 : 
          the successive calls to HAL_HASH_xxx_Start_DMA(). Then, MDMAT bit needs to be
          reset before the last call to HAL_HASH_xxx_Start_DMA(). Digest is finally
          retrieved thanks to HAL_HASH_xxx_Finish().

@endverbatim
stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 1208 : 
  *          For the processing of the last buffer of the thread, MDMAT bit must
  *          be reset and the buffer length (in bytes) doesn't have to be a
  *          multiple of 4.
  * @param  hhash: HASH handle.
  * @param  pInBuffer: pointer to the input buffer (buffer to be hashed).
stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 1233 : 
  *          For the processing of the last buffer of the thread, MDMAT bit must
  *          be reset and the buffer length (in bytes) doesn't have to be a
  *          multiple of 4.
  * @param  hhash: HASH handle.
  * @param  pInBuffer: pointer to the input buffer (buffer to be hashed).
HAL_HASH_ContextRestoring in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset the HASH processor before restoring the Context
  Swap Registers (CSR) */
  __HAL_HASH_INIT();

HAL_HASH_DMAFeed_ProcessSuspend in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Wait for BUSY flag to be reset */
    if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_BUSY, SET, HASH_TIMEOUTVALUE) != HAL_OK)
    {
       return HAL_TIMEOUT;
HAL_HASH_DMAFeed_ProcessSuspend in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    if (__HAL_HASH_GET_FLAG(HASH_FLAG_DCIS) != RESET)
    {
      return HAL_ERROR;
    }
HAL_HASH_DMAFeed_ProcessSuspend in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Wait for BUSY flag to be set */
    if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_BUSY, RESET, HASH_TIMEOUTVALUE) != HAL_OK)
    {
       return HAL_TIMEOUT;
    }
HAL_HASH_DMAFeed_ProcessSuspend in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Wait for BUSY flag to be reset */
    if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_BUSY, SET, HASH_TIMEOUTVALUE) != HAL_OK)
    {
      return HAL_TIMEOUT;
HAL_HASH_DMAFeed_ProcessSuspend in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    if (__HAL_HASH_GET_FLAG(HASH_FLAG_DCIS) != RESET)
    {
      return HAL_ERROR;
    }
HASH_DMAXferCplt in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

        hhash->NbWordsAlreadyPushed = 0U;                  /* Reset number of words already pushed */
        /* Check whether or not digest calculation must be disabled (in case of multi-buffer HMAC processing) */
        if (hhash->DigestCalculationDisable != RESET)
        {
          /* Digest calculation is disabled: Step 2 must start with MDMAT bit set,
          no digest calculation will be triggered at the end of the input buffer feeding to the Peripheral */
HASH_DMAXferCplt in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      {
        if (hhash->DigestCalculationDisable != RESET)
        {
          /* No automatic move to Step 3 as a new message buffer will be fed to the Peripheral
          (case of multi-buffer HMAC processing):
HASH_DMAXferCplt in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

          hhash->NbWordsAlreadyPushed = 0U;              /* Reset number of words already pushed */
        }
      }

HASH_DMAError in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#endif /* USE_HAL_HASH_REGISTER_CALLBACKS */
    /* After error handling by code user, reset HASH handle HAL status */
    hhash->Status = HAL_OK;

  }
HASH_WriteData in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      {
        /* Reset SuspendRequest */
        hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;

        /* Depending whether the key or the input data were fed to the Peripheral, the feeding point
stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 1868 : 
  * @param  Flag: specifies the HASH flag to check.
  * @param  Status: the Flag status (SET or RESET).
  * @param  Timeout: Timeout duration.
  * @retval HAL status
  */
HASH_WaitOnFlagUntilTimeout in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Wait until flag is set */
  if(Status == RESET)
  {
    while(__HAL_HASH_GET_FLAG(Flag) == RESET)
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
HASH_WaitOnFlagUntilTimeout in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    while(__HAL_HASH_GET_FLAG(Flag) != RESET)
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
HASH_IT in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

        /* Reset SuspendRequest */
        hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;

        /* Change the HASH state */
HASH_Write_Block_Data in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

      /* Reset multi buffers accumulation flag */
      hhash->Accumulation = 0U;
      /* Change the HASH state */
      hhash->State = HAL_HASH_STATE_READY;
HASH_Write_Block_Data in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    }
    /* Reset buffer counter */
    hhash->HashInCount = 0;
  }

HMAC_Processing in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Wait for DCIS flag to be set */
     if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_DCIS, RESET, Timeout) != HAL_OK)
    {
      return HAL_TIMEOUT;
    }
HASH_Start in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

      /* Select the HASH algorithm, clear HMAC mode and long key selection bit, reset the HASH processor core */
      MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_CR_INIT);

      /* Configure the number of valid bits in last word of the message */
HASH_Start in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      /* Wait for DCIS flag to be set */
      if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_DCIS, RESET, Timeout) != HAL_OK)
      {
        return HAL_TIMEOUT;
      }
HASH_Accumulate in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      {
        /* Select the HASH algorithm, clear HMAC mode and long key selection bit, reset the HASH processor core */
        MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_CR_INIT);
      }

HASH_Accumulate_IT in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      {
        /* Select the HASH algorithm, clear HMAC mode and long key selection bit, reset the HASH processor core */
        MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_CR_INIT);
        hhash->HashITCounter = 1;
      }
HASH_Start_IT in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    {
      /* Select the HASH algorithm, clear HMAC mode and long key selection bit, reset the HASH processor core */
      MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_CR_INIT);

      /* Configure the number of valid bits in last word of the message */
stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 2846 : 
  *          For the processing of the last buffer of the thread, MDMAT bit must
  *          be reset and the buffer length (in bytes) doesn't have to be a
  *          multiple of 4.
  * @param  hhash: HASH handle.
  * @param  pInBuffer: pointer to the input buffer (buffer to be hashed).
HASH_Start_DMA in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      {
        /* Select the HASH algorithm, clear HMAC mode and long key selection bit, reset the HASH processor core */
        MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_CR_INIT);

        /* Set the phase */
HASH_Finish in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Wait for DCIS flag to be set */
    if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_DCIS, RESET, Timeout) != HAL_OK)
    {
      return HAL_TIMEOUT;
    }
HMAC_Start_DMA in stm32l4xx_hal_hash.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

      if (hhash->DigestCalculationDisable == RESET)
      {
        /* This means this is the last buffer of the multi-buffer sequence: DCAL needs to be set. */
       __HAL_HASH_RESET_MDMAT();
        __HAL_HASH_SET_NBVALIDBITS(inputSize);
      }
    }
stm32l4xx_hal_hash.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 62 : 
{
  HAL_HASH_STATE_RESET             = 0x00U,    /*!< Peripheral is not initialized            */
  HAL_HASH_STATE_READY             = 0x01U,    /*!< Peripheral Initialized and ready for use */
  HAL_HASH_STATE_BUSY              = 0x02U,    /*!< Processing (hashing) is ongoing          */
  HAL_HASH_STATE_TIMEOUT           = 0x06U,    /*!< Timeout state                            */
stm32l4xx_hal_hash.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 322 : 

/** @brief Reset HASH handle state.
  * @param  __HANDLE__: HASH handle.
  * @retval None
  */
stm32l4xx_hal_hash.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 328 : 
#if (USE_HAL_HASH_REGISTER_CALLBACKS == 1)
#define __HAL_HASH_RESET_HANDLE_STATE(__HANDLE__) do{\
                                                      (__HANDLE__)->State = HAL_HASH_STATE_RESET;\
                                                      (__HANDLE__)->MspInitCallback = NULL;      \
                                                      (__HANDLE__)->MspDeInitCallback = NULL;    \
                                                     }while(0)
#else
#define __HAL_HASH_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_HASH_STATE_RESET)
#endif /* USE_HAL_HASH_REGISTER_CALLBACKS */


/** @brief Reset HASH handle status.
  * @param  __HANDLE__: HASH handle.
  * @retval None
  */
#define __HAL_HASH_RESET_HANDLE_STATUS(__HANDLE__) ((__HANDLE__)->Status = HAL_OK)

/**
  * @brief  Enable the multi-buffer DMA transfer mode.
stm32l4xx_hal_hash.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 355 : 
  */
#define __HAL_HASH_RESET_MDMAT()        CLEAR_BIT(HASH->CR, HASH_CR_MDMAT)


/**
stm32l4xx_hal_hash.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 372 : 
/**
  * @brief Reset the HASH core.
  * @retval None
  */
#define __HAL_HASH_INIT()       SET_BIT(HASH->CR, HASH_CR_INIT)
stm32l4xx_hal_hash.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 402 : 
  * @param __DATATYPE__: HASH input data type.
  * @retval SET (__DATATYPE__ is valid) or RESET (__DATATYPE__ is invalid)
  */
#define IS_HASH_DATATYPE(__DATATYPE__) (((__DATATYPE__) == HASH_DATATYPE_32B)|| \
                                        ((__DATATYPE__) == HASH_DATATYPE_16B)|| \
stm32l4xx_hal_hash.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 414 : 
  * @param __SIZE__: input data buffer size.
  * @retval SET (__SIZE__ is valid) or RESET (__SIZE__ is invalid)
  */
#define IS_HASH_DMA_MULTIBUFFER_SIZE(__SIZE__)  ((READ_BIT(HASH->CR, HASH_CR_MDMAT) == 0U) || (((__SIZE__) % 4U) == 0U))

stm32l4xx_hal_hash.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 424 : 
  * @param __SIZE__: input data buffer size.
  * @retval SET (__SIZE__ is valid) or RESET (__SIZE__ is invalid)
  */
#define IS_HMAC_DMA_MULTIBUFFER_SIZE(__HANDLE__,__SIZE__)  ((((__HANDLE__)->DigestCalculationDisable) == RESET) || (((__SIZE__) % 4U) == 0U))
/**
  * @brief Ensure that handle phase is set to HASH processing.
  * @param __HANDLE__: HASH handle.
  * @retval SET (handle phase is set to HASH processing) or RESET (handle phase is not set to HASH processing)
  */
#define IS_HASH_PROCESSING(__HANDLE__)  ((__HANDLE__)->Phase == HAL_HASH_PHASE_PROCESS)

stm32l4xx_hal_hash.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 437 : 
  * @param __HANDLE__: HASH handle.
  * @retval SET (handle phase is set to HMAC processing) or RESET (handle phase is not set to HMAC processing)
  */
#define IS_HMAC_PROCESSING(__HANDLE__)  (((__HANDLE__)->Phase == HAL_HASH_PHASE_HMAC_STEP_1) || \
                                         ((__HANDLE__)->Phase == HAL_HASH_PHASE_HMAC_STEP_2) || \
stm32l4xx_hal_hash_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 50 : 
             From that point, each buffer can be fed to the Peripheral thru HAL_HASHEx_xxx_Start_DMA() API.
             Before entering the last buffer, reset the MDMAT bit with __HAL_HASH_RESET_MDMAT()
             macro then wrap-up the HASH processing in feeding the last input buffer thru the
             same API HAL_HASHEx_xxx_Start_DMA(). The digest can then be retrieved with a call to
             API HAL_HASHEx_xxx_Finish().
stm32l4xx_hal_hash_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 344 : 
          the successive calls to HAL_HASHEx_xxx_Start_DMA(). Then, MDMAT bit needs to be
          reset before the last call to HAL_HASHEx_xxx_Start_DMA(). Digest is finally
          retrieved thanks to HAL_HASHEx_xxx_Finish().

@endverbatim
stm32l4xx_hal_hash_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 578 : 
  *          For the processing of the last buffer of the thread, MDMAT bit must
  *          be reset and the buffer length (in bytes) doesn't have to be a
  *          multiple of 4.
  * @param  hhash: HASH handle.
  * @param  pInBuffer: pointer to the input buffer (buffer to be hashed).
stm32l4xx_hal_hash_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 602 : 
  *          For the processing of the last buffer of the thread, MDMAT bit must
  *          be reset and the buffer length (in bytes) doesn't have to be a
  *          multiple of 4.
  * @param  hhash: HASH handle.
  * @param  pInBuffer: pointer to the input buffer (buffer to be hashed).
HAL_HMACEx_MD5_Step2_3_DMA in stm32l4xx_hal_hash_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
{
  hhash->DigestCalculationDisable = RESET;
  return  HMAC_Start_DMA(hhash, pInBuffer, Size, HASH_ALGOSELECTION_MD5);
}

HAL_HMACEx_SHA1_Step2_3_DMA in stm32l4xx_hal_hash_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
{
  hhash->DigestCalculationDisable = RESET;
  return  HMAC_Start_DMA(hhash, pInBuffer, Size, HASH_ALGOSELECTION_SHA1);
}

HAL_HMACEx_SHA224_Step2_3_DMA in stm32l4xx_hal_hash_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
{
  hhash->DigestCalculationDisable = RESET;
  return  HMAC_Start_DMA(hhash, pInBuffer, Size, HASH_ALGOSELECTION_SHA224);
}

HAL_HMACEx_SHA256_Step2_3_DMA in stm32l4xx_hal_hash_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
{
  hhash->DigestCalculationDisable = RESET;
  return  HMAC_Start_DMA(hhash, pInBuffer, Size, HASH_ALGOSELECTION_SHA256);
}

HAL_HCD_Init in stm32l4xx_hal_hcd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (hhcd->State == HAL_HCD_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hhcd->Lock = HAL_UNLOCKED;
HAL_HCD_DeInit in stm32l4xx_hal_hcd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  hhcd->State = HAL_HCD_STATE_RESET;

  return HAL_OK;
}
HAL_HCD_RegisterCallback in stm32l4xx_hal_hcd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (hhcd->State == HAL_HCD_STATE_RESET)
  {
    switch (CallbackID)
    {
HAL_HCD_UnRegisterCallback in stm32l4xx_hal_hcd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (hhcd->State == HAL_HCD_STATE_RESET)
  {
    switch (CallbackID)
    {
stm32l4xx_hal_hcd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 1025 : 
/**
  * @brief  Reset the host port.
  * @param  hhcd HCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_ResetPort(HCD_HandleTypeDef *hhcd)
{
  return (USB_ResetPort(hhcd->Instance));
}

/**
stm32l4xx_hal_hcd.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 49 : 
{
  HAL_HCD_STATE_RESET    = 0x00,
  HAL_HCD_STATE_READY    = 0x01,
  HAL_HCD_STATE_ERROR    = 0x02,
  HAL_HCD_STATE_BUSY     = 0x03,
stm32l4xx_hal_hcd.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 260 : 
  */
HAL_StatusTypeDef       HAL_HCD_ResetPort(HCD_HandleTypeDef *hhcd);
HAL_StatusTypeDef       HAL_HCD_Start(HCD_HandleTypeDef *hhcd);
HAL_StatusTypeDef       HAL_HCD_Stop(HCD_HandleTypeDef *hhcd);
/**
stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 248 : 
    [..]
     Use function @ref HAL_I2C_UnRegisterCallback to reset a callback to the default
     weak function.
     @ref HAL_I2C_UnRegisterCallback takes as parameters the HAL peripheral handle,
     and the Callback ID.
     This function allows to reset following callbacks:
       (+) MasterTxCpltCallback : callback for Master transmission end of transfer.
       (+) MasterRxCpltCallback : callback for Master reception end of transfer.
       (+) SlaveTxCpltCallback  : callback for Slave transmission end of transfer.
stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 267 : 
    [..]
     By default, after the @ref HAL_I2C_Init() and when the state is @ref HAL_I2C_STATE_RESET
     all callbacks are set to the corresponding weak functions:
     examples @ref HAL_I2C_MasterTxCpltCallback(), @ref HAL_I2C_MasterRxCpltCallback().
     Exception done for MspInit and MspDeInit functions that are
     reset to the legacy weak functions in the @ref HAL_I2C_Init()/ @ref HAL_I2C_DeInit() only when
     these callbacks are null (not registered beforehand).
     If MspInit or MspDeInit are not null, the @ref HAL_I2C_Init()/ @ref HAL_I2C_DeInit()
     keep and use the user MspInit/MspDeInit callbacks (registered beforehand) whatever the state.
stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 278 : 
     Exception done MspInit/MspDeInit functions that can be registered/unregistered
     in @ref HAL_I2C_STATE_READY or @ref HAL_I2C_STATE_RESET state,
     thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
     Then, the user first registers the MspInit/MspDeInit user callbacks
     using @ref HAL_I2C_RegisterCallback() before calling @ref HAL_I2C_DeInit()
stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 361 : 

/* Private define Sequential Transfer Options default/reset value */
#define I2C_NO_OPTION_FRAME     (0xFFFF0000U)
/**
  * @}
HAL_I2C_Init in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (hi2c->State == HAL_I2C_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
HAL_I2C_DeInit in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
  hi2c->State = HAL_I2C_STATE_RESET;
  hi2c->PreviousState = I2C_STATE_NONE;
  hi2c->Mode = HAL_I2C_MODE_NONE;

HAL_I2C_RegisterCallback in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (HAL_I2C_STATE_RESET == hi2c->State)
  {
    switch (CallbackID)
    {
HAL_I2C_UnRegisterCallback in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (HAL_I2C_STATE_RESET == hi2c->State)
  {
    switch (CallbackID)
    {
HAL_I2C_Master_Transmit in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
        {
          return HAL_ERROR;
        }
HAL_I2C_Master_Transmit in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;
    hi2c->Mode  = HAL_I2C_MODE_NONE;
HAL_I2C_Master_Receive in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
        {
          return HAL_ERROR;
        }
HAL_I2C_Master_Receive in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;
    hi2c->Mode  = HAL_I2C_MODE_NONE;
HAL_I2C_Slave_Transmit in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Wait until ADDR flag is set */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
HAL_I2C_Slave_Transmit in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      /* Wait until ADDR flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
      {
        /* Disable Address Acknowledge */
        hi2c->Instance->CR2 |= I2C_CR2_NACK;
HAL_I2C_Slave_Transmit in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Wait until DIR flag is set Transmitter mode */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, RESET, Timeout, tickstart) != HAL_OK)
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
HAL_I2C_Slave_Transmit in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Wait until BUSY flag is reset */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)
    {
      /* Disable Address Acknowledge */
HAL_I2C_Slave_Receive in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Wait until ADDR flag is set */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
HAL_I2C_Slave_Receive in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Wait until DIR flag is reset Receiver mode */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, SET, Timeout, tickstart) != HAL_OK)
    {
      /* Disable Address Acknowledge */
HAL_I2C_Slave_Receive in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Wait until BUSY flag is reset */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)
    {
      /* Disable Address Acknowledge */
HAL_I2C_Mem_Write in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
        {
          return HAL_ERROR;
        }
HAL_I2C_Mem_Write in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
    {
      return HAL_ERROR;
HAL_I2C_Mem_Write in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;
    hi2c->Mode  = HAL_I2C_MODE_NONE;
HAL_I2C_Mem_Read in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
      {
        return HAL_ERROR;
      }
HAL_I2C_Mem_Read in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
        {
          return HAL_ERROR;
        }
HAL_I2C_Mem_Read in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
    {
      return HAL_ERROR;
HAL_I2C_Mem_Read in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;
    hi2c->Mode  = HAL_I2C_MODE_NONE;
HAL_I2C_IsDeviceReady in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

      while ((tmp1 == RESET) && (tmp2 == RESET))
      {
        if (Timeout != HAL_MAX_DELAY)
        {
HAL_I2C_IsDeviceReady in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      /* Check if the NACKF flag has not been set */
      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET)
      {
        /* Wait until STOPF flag is reset */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
        {
          return HAL_ERROR;
        }
HAL_I2C_IsDeviceReady in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      {
        /* Wait until STOPF flag is reset */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
        {
          return HAL_ERROR;
        }
HAL_I2C_IsDeviceReady in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

        /* Wait until STOPF flag is reset */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
        {
          return HAL_ERROR;
        }
HAL_I2C_Slave_Seq_Transmit_DMA in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

      /* Reset XferSize */
      hi2c->XferSize = 0;
    }
    else
HAL_I2C_Slave_Seq_Receive_DMA in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

      /* Reset XferSize */
      hi2c->XferSize = 0;
    }
    else
HAL_I2C_ER_IRQHandler in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* I2C Bus error interrupt occurred ------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;

HAL_I2C_ER_IRQHandler in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* I2C Over-Run/Under-Run interrupt occurred ----------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;

HAL_I2C_ER_IRQHandler in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* I2C Arbitration Loss error interrupt occurred -------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;

I2C_Master_ISR_IT in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
I2C_Master_ISR_IT in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
  {
    /* Remove RXNE flag on temporary variable as read done */
    tmpITFlags &= ~I2C_FLAG_RXNE;
I2C_Master_ISR_IT in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
  {
    /* Write data to TXDR */
    hi2c->Instance->TXDR = *hi2c->pBuffPtr;
I2C_Master_ISR_IT in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
  {
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
    {
I2C_Master_ISR_IT in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
  {
    if (hi2c->XferCount == 0U)
    {
I2C_Master_ISR_IT in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
  {
    /* Call I2C Master complete process */
    I2C_ITMasterCplt(hi2c, tmpITFlags);
I2C_Slave_ISR_IT in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
  {
    /* Check that I2C transfer finished */
    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
I2C_Slave_ISR_IT in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
  {
    if (hi2c->XferCount > 0U)
    {
I2C_Slave_ISR_IT in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
  {
    I2C_ITAddrCplt(hi2c, tmpITFlags);
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
  {
    /* Write data to TXDR only if XferCount not reach "0" */
    /* A TXIS flag can be set, during STOP treatment      */
I2C_Slave_ISR_IT in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Check if STOPF is set */
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
  {
    /* Call I2C Slave complete process */
    I2C_ITSlaveCplt(hi2c, tmpITFlags);
I2C_Master_ISR_DMA in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
I2C_Master_ISR_DMA in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
  {
    /* Disable TC interrupt */
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_TCI);
I2C_Master_ISR_DMA in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
  {
    if (hi2c->XferCount == 0U)
    {
I2C_Master_ISR_DMA in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
  {
    /* Call I2C Master complete process */
    I2C_ITMasterCplt(hi2c, ITFlags);
I2C_Slave_ISR_DMA in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
  {
    /* Check that I2C transfer finished */
    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
I2C_Slave_ISR_DMA in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* So clear Flag NACKF only */
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
        (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET))
    {
      /* Split check of hdmarx, for MISRA compliance */
      if (hi2c->hdmarx != NULL)
      {
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET)
        {
          if (__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U)
          {
I2C_Slave_ISR_DMA in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      {
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET)
        {
          if (__HAL_DMA_GET_COUNTER(hi2c->hdmatx) == 0U)
          {
I2C_Slave_ISR_DMA in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
  {
    I2C_ITAddrCplt(hi2c, ITFlags);
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
  {
    /* Call I2C Slave complete process */
    I2C_ITSlaveCplt(hi2c, ITFlags);
I2C_RequestMemoryWrite in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Wait until TCR flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
  {
    return HAL_ERROR;
  }
I2C_RequestMemoryRead in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Wait until TC flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
  {
    return HAL_ERROR;
  }
I2C_ITAddrCplt in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
        {
          /* Reset Address Event counter */
          hi2c->AddrEventCount = 0U;

          /* Clear ADDR flag */
I2C_ITMasterSeqCplt in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
{
  /* Reset I2C handle mode */
  hi2c->Mode = HAL_I2C_MODE_NONE;

  /* No Generate Stop, to permit restart mode */
I2C_ITSlaveSeqCplt in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
{
  /* Reset I2C handle mode */
  hi2c->Mode = HAL_I2C_MODE_NONE;

  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
I2C_ITMasterCplt in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Clear Configuration Register 2 */
  I2C_RESET_CR2(hi2c);

  /* Reset handle parameters */
  hi2c->PreviousState = I2C_STATE_NONE;
  hi2c->XferISR       = NULL;
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;

  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET)
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
I2C_ITSlaveCplt in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Clear Configuration Register 2 */
  I2C_RESET_CR2(hi2c);

  /* Flush TX register */
  I2C_Flush_TXDR(hi2c);
I2C_ITSlaveCplt in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* If a DMA is ongoing, Update handle size context */
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
  {
    if (hi2c->hdmatx != NULL)
    {
I2C_ITSlaveCplt in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
  {
    if (hi2c->hdmarx != NULL)
    {
I2C_ITSlaveCplt in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Store Last receive data if any */
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET)
  {
    /* Remove RXNE flag on temporary variable as read done */
    tmpITFlags &= ~I2C_FLAG_RXNE;
I2C_ITListenCplt in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
{
  /* Reset handle parameters */
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
  hi2c->PreviousState = I2C_STATE_NONE;
  hi2c->State = HAL_I2C_STATE_READY;
I2C_ITListenCplt in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Store Last receive data if any */
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
  {
    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
I2C_ITError in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset handle parameters */
  hi2c->Mode          = HAL_I2C_MODE_NONE;
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
  hi2c->XferCount     = 0U;
I2C_Flush_TXDR in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
  {
    hi2c->Instance->TXDR = 0x00U;
  }
I2C_Flush_TXDR in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
  }
I2C_DMAAbort in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset AbortCpltCallback */
  hi2c->hdmatx->XferAbortCallback = NULL;
  hi2c->hdmarx->XferAbortCallback = NULL;

stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 6075 : 
  * @param  Flag Specifies the I2C flag to check.
  * @param  Status The new Flag status (SET or RESET).
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
I2C_WaitOnTXISFlagUntilTimeout in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
{
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
I2C_WaitOnSTOPFlagUntilTimeout in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
{
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
I2C_WaitOnRXNEFlagUntilTimeout in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
{
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
I2C_WaitOnRXNEFlagUntilTimeout in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);

        hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
        hi2c->State = HAL_I2C_STATE_READY;
I2C_IsAcknowledgeFailed in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
I2C_IsAcknowledgeFailed in stm32l4xx_hal_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);

    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    hi2c->State = HAL_I2C_STATE_READY;
stm32l4xx_hal_i2c.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 89 : 
  *          b5     Peripheral initialization status\n
  *             0  : Reset (peripheral not initialized)\n
  *             1  : Init done (peripheral initialized and ready to use. HAL I2C Init function called)\n
  *          b4     (not used)\n
  *             x  : Should be set to 0\n
stm32l4xx_hal_i2c.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 109 : 
{
  HAL_I2C_STATE_RESET             = 0x00U,   /*!< Peripheral is not yet Initialized         */
  HAL_I2C_STATE_READY             = 0x20U,   /*!< Peripheral Initialized and ready for use  */
  HAL_I2C_STATE_BUSY              = 0x24U,   /*!< An internal process is ongoing            */
  HAL_I2C_STATE_BUSY_TX           = 0x21U,   /*!< Data Transmission process is ongoing      */
stm32l4xx_hal_i2c.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 437 : 

/** @brief Reset I2C handle state.
  * @param  __HANDLE__ specifies the I2C Handle.
  * @retval None
  */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
#define __HAL_I2C_RESET_HANDLE_STATE(__HANDLE__)                do{                                                   \
                                                                    (__HANDLE__)->State = HAL_I2C_STATE_RESET;       \
                                                                    (__HANDLE__)->MspInitCallback = NULL;            \
                                                                    (__HANDLE__)->MspDeInitCallback = NULL;          \
                                                                  } while(0)
#else
#define __HAL_I2C_RESET_HANDLE_STATE(__HANDLE__)                ((__HANDLE__)->State = HAL_I2C_STATE_RESET)
#endif

/** @brief  Enable the specified I2C interrupt.
stm32l4xx_hal_i2c.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 495 : 
  *
  * @retval The new state of __INTERRUPT__ (SET or RESET).
  */
#define __HAL_I2C_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)      ((((__HANDLE__)->Instance->CR1 & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)

/** @brief  Check whether the specified I2C flag is set or not.
  * @param  __HANDLE__ specifies the I2C Handle.
stm32l4xx_hal_i2c.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 520 : 
  *
  * @retval The new state of __FLAG__ (SET or RESET).
  */
#define I2C_FLAG_MASK  (0x0001FFFFU)
#define __HAL_I2C_GET_FLAG(__HANDLE__, __FLAG__) (((((__HANDLE__)->Instance->ISR) & (__FLAG__)) == (__FLAG__)) ? SET : RESET)

/** @brief  Clear the I2C pending flags which are cleared by writing 1 in a specific bit.
  * @param  __HANDLE__ specifies the I2C Handle.
stm32l4xx_hal_i2c.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 734 : 

#define I2C_RESET_CR2(__HANDLE__)                 ((__HANDLE__)->Instance->CR2 &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_HEAD10R | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_RD_WRN)))

#define I2C_GET_ADDR_MATCH(__HANDLE__)            ((uint16_t)(((__HANDLE__)->Instance->ISR & I2C_ISR_ADDCODE) >> 16U))
#define I2C_GET_DIR(__HANDLE__)                   ((uint8_t)(((__HANDLE__)->Instance->ISR & I2C_ISR_DIR) >> 16U))
stm32l4xx_hal_i2c.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 751 : 

#define I2C_CHECK_FLAG(__ISR__, __FLAG__)         ((((__ISR__) & ((__FLAG__) & I2C_FLAG_MASK)) == ((__FLAG__) & I2C_FLAG_MASK)) ? SET : RESET)
#define I2C_CHECK_IT_SOURCE(__CR1__, __IT__)      ((((__CR1__) & (__IT__)) == (__IT__)) ? SET : RESET)
/**
  * @}
  */
HAL_I2CEx_ConfigAnalogFilter in stm32l4xx_hal_i2c_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);

    /* Set analog filter bit*/
HAL_I2CEx_ConfigDigitalFilter in stm32l4xx_hal_i2c_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);

    /* Set I2Cx DNF coefficient */
stm32l4xx_hal_irda.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 131 : 
    [..]
    Use function @ref HAL_IRDA_UnRegisterCallback() to reset a callback to the default
    weak (surcharged) function.
    @ref HAL_IRDA_UnRegisterCallback() takes as parameters the HAL peripheral handle,
    and the Callback ID.
    This function allows to reset following callbacks:
    (+) TxHalfCpltCallback        : Tx Half Complete Callback.
    (+) TxCpltCallback            : Tx Complete Callback.
    (+) RxHalfCpltCallback        : Rx Half Complete Callback.
stm32l4xx_hal_irda.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 148 : 
    [..]
    By default, after the @ref HAL_IRDA_Init() and when the state is HAL_IRDA_STATE_RESET
    all callbacks are set to the corresponding weak (surcharged) functions:
    examples @ref HAL_IRDA_TxCpltCallback(), @ref HAL_IRDA_RxHalfCpltCallback().
    Exception done for MspInit and MspDeInit functions that are respectively
    reset to the legacy weak (surcharged) functions in the @ref HAL_IRDA_Init()
    and @ref HAL_IRDA_DeInit() only when these callbacks are null (not registered beforehand).
    If not, MspInit or MspDeInit are not null, the @ref HAL_IRDA_Init() and @ref HAL_IRDA_DeInit()
    keep and use the user MspInit/MspDeInit callbacks (registered beforehand).
stm32l4xx_hal_irda.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 160 : 
    Exception done MspInit/MspDeInit that can be registered/unregistered
    in HAL_IRDA_STATE_READY or HAL_IRDA_STATE_RESET state, thus registered (user)
    MspInit/DeInit callbacks can be used during the Init/DeInit.
    In that case first register the MspInit/MspDeInit user callbacks
    using @ref HAL_IRDA_RegisterCallback() before calling @ref HAL_IRDA_DeInit()
HAL_IRDA_Init in stm32l4xx_hal_irda.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (hirda->gState == HAL_IRDA_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hirda->Lock = HAL_UNLOCKED;
HAL_IRDA_DeInit in stm32l4xx_hal_irda.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  hirda->ErrorCode = HAL_IRDA_ERROR_NONE;
  hirda->gState    = HAL_IRDA_STATE_RESET;
  hirda->RxState   = HAL_IRDA_STATE_RESET;

  /* Process Unlock */
  __HAL_UNLOCK(hirda);
HAL_IRDA_RegisterCallback in stm32l4xx_hal_irda.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (hirda->gState == HAL_IRDA_STATE_RESET)
  {
    switch (CallbackID)
    {
HAL_IRDA_UnRegisterCallback in stm32l4xx_hal_irda.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (HAL_IRDA_STATE_RESET == hirda->gState)
  {
    switch (CallbackID)
    {
HAL_IRDA_Transmit in stm32l4xx_hal_irda.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

      if (IRDA_WaitOnFlagUntilTimeout(hirda, IRDA_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
      {
        return HAL_TIMEOUT;
      }
HAL_IRDA_Transmit in stm32l4xx_hal_irda.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    if (IRDA_WaitOnFlagUntilTimeout(hirda, IRDA_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
    {
      return HAL_TIMEOUT;
    }
HAL_IRDA_Receive in stm32l4xx_hal_irda.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

      if (IRDA_WaitOnFlagUntilTimeout(hirda, IRDA_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
      {
        return HAL_TIMEOUT;
      }
HAL_IRDA_Abort in stm32l4xx_hal_irda.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset Tx and Rx transfer counters */
  hirda->TxXferCount = 0U;
  hirda->RxXferCount = 0U;

HAL_IRDA_Abort in stm32l4xx_hal_irda.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset Handle ErrorCode to No Error */
  hirda->ErrorCode = HAL_IRDA_ERROR_NONE;

  return HAL_OK;
HAL_IRDA_AbortTransmit in stm32l4xx_hal_irda.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset Tx transfer counter */
  hirda->TxXferCount = 0U;

  /* Restore hirda->gState to Ready */
HAL_IRDA_AbortReceive in stm32l4xx_hal_irda.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset Rx transfer counter */
  hirda->RxXferCount = 0U;

  /* Clear the Error flags in the ICR register */
HAL_IRDA_Abort_IT in stm32l4xx_hal_irda.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Reset Tx and Rx transfer counters */
    hirda->TxXferCount = 0U;
    hirda->RxXferCount = 0U;

    /* Reset errorCode */
    hirda->ErrorCode = HAL_IRDA_ERROR_NONE;

    /* Clear the Error flags in the ICR register */
HAL_IRDA_AbortTransmit_IT in stm32l4xx_hal_irda.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    {
      /* Reset Tx transfer counter */
      hirda->TxXferCount = 0U;

      /* Restore hirda->gState to Ready */
HAL_IRDA_AbortTransmit_IT in stm32l4xx_hal_irda.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Reset Tx transfer counter */
    hirda->TxXferCount = 0U;

    /* Restore hirda->gState to Ready */
HAL_IRDA_AbortReceive_IT in stm32l4xx_hal_irda.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    {
      /* Reset Rx transfer counter */
      hirda->RxXferCount = 0U;

      /* Clear the Error flags in the ICR register */
HAL_IRDA_AbortReceive_IT in stm32l4xx_hal_irda.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Reset Rx transfer counter */
    hirda->RxXferCount = 0U;

    /* Clear the Error flags in the ICR register */
IRDA_CheckIdleState in stm32l4xx_hal_irda.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Wait until TEACK flag is set */
    if (IRDA_WaitOnFlagUntilTimeout(hirda, USART_ISR_TEACK, RESET, tickstart, IRDA_TEACK_REACK_TIMEOUT) != HAL_OK)
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
IRDA_CheckIdleState in stm32l4xx_hal_irda.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Wait until REACK flag is set */
    if (IRDA_WaitOnFlagUntilTimeout(hirda, USART_ISR_REACK, RESET, tickstart, IRDA_TEACK_REACK_TIMEOUT) != HAL_OK)
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
stm32l4xx_hal_irda.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 2427 : 
  * @param  Flag Specifies the IRDA flag to check.
  * @param  Status Flag status (SET or RESET)
  * @param  Tickstart Tick start value
  * @param  Timeout Timeout duration
  * @retval HAL status
IRDA_WaitOnFlagUntilTimeout in stm32l4xx_hal_irda.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Wait until flag is set */
  while ((__HAL_IRDA_GET_FLAG(hirda, Flag) ? SET : RESET) == Status)
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
IRDA_DMATransmitCplt in stm32l4xx_hal_irda.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Disable the DMA transfer for transmit request by resetting the DMAT bit
       in the IRDA CR3 register */
    CLEAR_BIT(hirda->Instance->CR3, USART_CR3_DMAT);

IRDA_DMAReceiveCplt in stm32l4xx_hal_irda.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
       in the IRDA CR3 register */
    CLEAR_BIT(hirda->Instance->CR3, USART_CR3_DMAR);

IRDA_DMATxAbortCallback in stm32l4xx_hal_irda.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset errorCode */
  hirda->ErrorCode = HAL_IRDA_ERROR_NONE;

  /* Clear the Error flags in the ICR register */
IRDA_DMARxAbortCallback in stm32l4xx_hal_irda.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset errorCode */
  hirda->ErrorCode = HAL_IRDA_ERROR_NONE;

  /* Clear the Error flags in the ICR register */
stm32l4xx_hal_irda.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 92 : 
  *          b5     Peripheral initialization status
  *             0  : Reset (Peripheral not initialized)
  *             1  : Init done (Peripheral not initialized. HAL IRDA Init function already called)
  *          b4-b3  (not used)
  *             xx : Should be set to 00
stm32l4xx_hal_irda.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 109 : 
  *          b5     Peripheral initialization status
  *             0  : Reset (Peripheral not initialized)
  *             1  : Init done (Peripheral not initialized)
  *          b4-b2  (not used)
  *            xxx : Should be set to 000
stm32l4xx_hal_irda.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 240 : 
  */
#define HAL_IRDA_STATE_RESET                0x00000000U   /*!< Peripheral is not initialized
                                                               Value is allowed for gState and RxState */
#define HAL_IRDA_STATE_READY                0x00000020U   /*!< Peripheral Initialized and ready for use
                                                               Value is allowed for gState and RxState */
stm32l4xx_hal_irda.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 479 : 

/** @brief  Reset IRDA handle state.
  * @param  __HANDLE__ IRDA handle.
  * @retval None
  */
#if USE_HAL_IRDA_REGISTER_CALLBACKS == 1
#define __HAL_IRDA_RESET_HANDLE_STATE(__HANDLE__)  do{                                                   \
                                                       (__HANDLE__)->gState = HAL_IRDA_STATE_RESET;      \
                                                       (__HANDLE__)->RxState = HAL_IRDA_STATE_RESET;     \
                                                       (__HANDLE__)->MspInitCallback = NULL;             \
                                                       (__HANDLE__)->MspDeInitCallback = NULL;           \
                                                     } while(0U)
#else
#define __HAL_IRDA_RESET_HANDLE_STATE(__HANDLE__)  do{                                                   \
                                                       (__HANDLE__)->gState = HAL_IRDA_STATE_RESET;      \
                                                       (__HANDLE__)->RxState = HAL_IRDA_STATE_RESET;     \
                                                     } while(0U)
#endif /*USE_HAL_IRDA_REGISTER_CALLBACKS  */

stm32l4xx_hal_irda.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 618 : 
  *            @arg @ref IRDA_IT_PE Parity Error interrupt
  * @retval The new state of __IT__ (SET or RESET).
  */
#define __HAL_IRDA_GET_IT(__HANDLE__, __INTERRUPT__) ((((__HANDLE__)->Instance->ISR\
                                                        & (0x01U << (((__INTERRUPT__) & IRDA_ISR_MASK)>> IRDA_ISR_POS))) != 0U) ? SET : RESET)

/** @brief  Check whether the specified IRDA interrupt source is enabled or not.
  * @param  __HANDLE__ specifies the IRDA Handle.
stm32l4xx_hal_irda.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 633 : 
  *            @arg @ref IRDA_IT_PE Parity Error interrupt
  * @retval The new state of __IT__ (SET or RESET).
  */
#define __HAL_IRDA_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((((((((__INTERRUPT__) & IRDA_CR_MASK) >> IRDA_CR_POS) == 0x01U)? (__HANDLE__)->Instance->CR1 : \
                                                                (((((__INTERRUPT__) & IRDA_CR_MASK) >> IRDA_CR_POS) == 0x02U)? (__HANDLE__)->Instance->CR2 : \
                                                                 (__HANDLE__)->Instance->CR3)) & ((uint32_t)0x01U << (((uint16_t)(__INTERRUPT__)) & IRDA_IT_MASK))) != 0U) ? SET : RESET)

/** @brief  Clear the specified IRDA ISR flag, in setting the proper ICR register flag.
  * @param  __HANDLE__ specifies the IRDA Handle.
stm32l4xx_hal_irda.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 713 : 
  * @param __PARITY__ IRDA frame parity.
  * @retval SET (__PARITY__ is valid) or RESET (__PARITY__ is invalid)
  */
#define IS_IRDA_PARITY(__PARITY__) (((__PARITY__) == IRDA_PARITY_NONE) || \
                                    ((__PARITY__) == IRDA_PARITY_EVEN) || \
stm32l4xx_hal_irda.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 721 : 
  * @param __MODE__ IRDA communication mode.
  * @retval SET (__MODE__ is valid) or RESET (__MODE__ is invalid)
  */
#define IS_IRDA_TX_RX_MODE(__MODE__) ((((__MODE__)\
                                        & (~((uint32_t)(IRDA_MODE_TX_RX)))) == 0x00U) && ((__MODE__) != 0x00U))
stm32l4xx_hal_irda.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 728 : 
  * @param __MODE__ IRDA power mode.
  * @retval SET (__MODE__ is valid) or RESET (__MODE__ is invalid)
  */
#define IS_IRDA_POWERMODE(__MODE__) (((__MODE__) == IRDA_POWERMODE_LOWPOWER) || \
                                     ((__MODE__) == IRDA_POWERMODE_NORMAL))
stm32l4xx_hal_irda.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 736 : 
  * @param __CLOCKPRESCALER__ IRDA clock Prescaler value.
  * @retval SET (__CLOCKPRESCALER__ is valid) or RESET (__CLOCKPRESCALER__ is invalid)
  */
#define IS_IRDA_CLOCKPRESCALER(__CLOCKPRESCALER__) (((__CLOCKPRESCALER__) == IRDA_PRESCALER_DIV1) || \
                                                    ((__CLOCKPRESCALER__) == IRDA_PRESCALER_DIV2)   || \
stm32l4xx_hal_irda.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 754 : 
  * @param __STATE__ IRDA state mode.
  * @retval SET (__STATE__ is valid) or RESET (__STATE__ is invalid)
  */
#define IS_IRDA_STATE(__STATE__) (((__STATE__) == IRDA_STATE_DISABLE) || \
                                  ((__STATE__) == IRDA_STATE_ENABLE))
stm32l4xx_hal_irda.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 761 : 
  * @param __MODE__ IRDA associated UART/USART mode.
  * @retval SET (__MODE__ is valid) or RESET (__MODE__ is invalid)
  */
#define IS_IRDA_MODE(__MODE__)  (((__MODE__) == IRDA_MODE_DISABLE) || \
                                 ((__MODE__) == IRDA_MODE_ENABLE))
stm32l4xx_hal_irda.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 768 : 
  * @param __ONEBIT__ IRDA sampling rate.
  * @retval SET (__ONEBIT__ is valid) or RESET (__ONEBIT__ is invalid)
  */
#define IS_IRDA_ONE_BIT_SAMPLE(__ONEBIT__)      (((__ONEBIT__) == IRDA_ONE_BIT_SAMPLE_DISABLE) || \
                                                 ((__ONEBIT__) == IRDA_ONE_BIT_SAMPLE_ENABLE))
stm32l4xx_hal_irda.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 775 : 
  * @param __DMATX__ IRDA DMA TX mode.
  * @retval SET (__DMATX__ is valid) or RESET (__DMATX__ is invalid)
  */
#define IS_IRDA_DMA_TX(__DMATX__)     (((__DMATX__) == IRDA_DMA_TX_DISABLE) || \
                                       ((__DMATX__) == IRDA_DMA_TX_ENABLE))
stm32l4xx_hal_irda.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 782 : 
  * @param __DMARX__ IRDA DMA RX mode.
  * @retval SET (__DMARX__ is valid) or RESET (__DMARX__ is invalid)
  */
#define IS_IRDA_DMA_RX(__DMARX__) (((__DMARX__) == IRDA_DMA_RX_DISABLE) || \
                                   ((__DMARX__) == IRDA_DMA_RX_ENABLE))
stm32l4xx_hal_irda.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 789 : 
  * @param __PARAM__ IRDA request.
  * @retval SET (__PARAM__ is valid) or RESET (__PARAM__ is invalid)
  */
#define IS_IRDA_REQUEST_PARAMETER(__PARAM__) (((__PARAM__) == IRDA_AUTOBAUD_REQUEST) || \
                                              ((__PARAM__) == IRDA_RXDATA_FLUSH_REQUEST) || \
stm32l4xx_hal_irda_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 452 : 
  * @param __LENGTH__ IRDA frame length.
  * @retval SET (__LENGTH__ is valid) or RESET (__LENGTH__ is invalid)
  */
#define IS_IRDA_WORD_LENGTH(__LENGTH__) (((__LENGTH__) == IRDA_WORDLENGTH_7B) || \
                                         ((__LENGTH__) == IRDA_WORDLENGTH_8B) || \
stm32l4xx_hal_iwdg.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 22 : 
    (+) Once the IWDG is started, the LSI is forced ON and both can not be
        disabled. The counter starts counting down from the reset value (0xFFF).
        When it reaches the end of count value (0x000) a reset signal is
        generated (IWDG reset).

    (+) Whenever the key value 0x0000 AAAA is written in the IWDG_KR register,
        the IWDG_RLR value is reloaded in the counter and the watchdog reset is
        prevented.

    (+) The IWDG is implemented in the VDD voltage domain that is still functional
        in STOP and STANDBY mode (IWDG reset can wake-up from STANDBY).
        IWDGRST flag in RCC_CSR register can be used to inform when an IWDG
        reset occurs.

    (+) Debug mode : When the microcontroller enters debug mode (core halted),
        the IWDG counter either continues to work normally or stops, depending
stm32l4xx_hal_iwdg.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 57 : 
           reloaded, then the IWDG will start counting down from this value.
      (+) wait for status flags to be reset
      (+) Depending on window parameter:
        (++) If Window Init parameter is same as Window register value,
             nothing more is done but reload counter value in order to exit
stm32l4xx_hal_iwdg.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 66 : 
    (#) Then the application program must refresh the IWDG counter at regular
        intervals during normal operation to prevent an MCU reset, using
        HAL_IWDG_Refresh() function.

     *** IWDG HAL driver macros list ***
HAL_LCD_Init in stm32l4xx_hal_lcd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (hlcd->State == HAL_LCD_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hlcd->Lock = HAL_UNLOCKED;
HAL_LCD_Init in stm32l4xx_hal_lcd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Wait Until the LCD is enabled */
  while (__HAL_LCD_GET_FLAG(hlcd, LCD_FLAG_ENS) == RESET)
  {
    if ((HAL_GetTick() - tickstart) > LCD_TIMEOUT_VALUE)
    {
HAL_LCD_Init in stm32l4xx_hal_lcd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /*!< Wait Until the LCD Booster is ready */
  while (__HAL_LCD_GET_FLAG(hlcd, LCD_FLAG_RDY) == RESET)
  {
    if ((HAL_GetTick() - tickstart) > LCD_TIMEOUT_VALUE)
    {
HAL_LCD_DeInit in stm32l4xx_hal_lcd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  hlcd->ErrorCode = HAL_LCD_ERROR_NONE;
  hlcd->State = HAL_LCD_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(hlcd);
HAL_LCD_Write in stm32l4xx_hal_lcd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      /*!< Wait Until the LCD is ready */
      while (__HAL_LCD_GET_FLAG(hlcd, LCD_FLAG_UDR) != RESET)
      {
        if ((HAL_GetTick() - tickstart) > LCD_TIMEOUT_VALUE)
        {
HAL_LCD_Clear in stm32l4xx_hal_lcd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /*!< Wait Until the LCD is ready */
    while (__HAL_LCD_GET_FLAG(hlcd, LCD_FLAG_UDR) != RESET)
    {
      if ((HAL_GetTick() - tickstart) > LCD_TIMEOUT_VALUE)
      {
HAL_LCD_UpdateDisplayRequest in stm32l4xx_hal_lcd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /*!< Wait Until the LCD display is done */
  while (__HAL_LCD_GET_FLAG(hlcd, LCD_FLAG_UDD) == RESET)
  {
    if ((HAL_GetTick() - tickstart) > LCD_TIMEOUT_VALUE)
    {
LCD_WaitForSynchro in stm32l4xx_hal_lcd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Loop until FCRSF flag is set */
  while (__HAL_LCD_GET_FLAG(hlcd, LCD_FLAG_FCRSF) == RESET)
  {
    if ((HAL_GetTick() - tickstart) > LCD_TIMEOUT_VALUE)
    {
stm32l4xx_hal_lcd.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 82 : 
{
  HAL_LCD_STATE_RESET             = 0x00,    /*!< Peripheral is not yet Initialized */
  HAL_LCD_STATE_READY             = 0x01,    /*!< Peripheral Initialized and ready for use */
  HAL_LCD_STATE_BUSY              = 0x02,    /*!< an internal process is ongoing */
  HAL_LCD_STATE_TIMEOUT           = 0x03,    /*!< Timeout state */
stm32l4xx_hal_lcd.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 353 : 

/** @brief Reset LCD handle state.
  * @param __HANDLE__ specifies the LCD Handle.
  * @retval None
  */
#define __HAL_LCD_RESET_HANDLE_STATE(__HANDLE__)  ((__HANDLE__)->State = HAL_LCD_STATE_RESET)

/** @brief  Enable the LCD peripheral.
  * @param __HANDLE__ specifies the LCD Handle.
stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 76 : 
         the counter. The first trigger event will start the timer, any
         successive trigger event will reset the counter and the timer will
         restart. To start this mode call HAL_LPTIM_TimeOut_Start_IT() or
         HAL_LPTIM_TimeOut_Start_IT() for interruption mode.

stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 102 : 
  [..]
  Use function @ref HAL_LPTIM_UnRegisterCallback() to reset a callback to the
  default weak function.
  @ref HAL_LPTIM_UnRegisterCallback takes as parameters the HAL peripheral handle,
  and the Callback ID.
stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 120 : 
  [..]
  By default, after the Init and when the state is HAL_LPTIM_STATE_RESET
  all interrupt callbacks are set to the corresponding weak functions:
  examples @ref HAL_LPTIM_TriggerCallback(), @ref HAL_LPTIM_CompareMatchCallback().

  [..]
  Exception done for MspInit and MspDeInit functions that are reset to the legacy weak
  functionalities in the Init/DeInit only when these callbacks are null
  (not registered beforehand). If not, MspInit or MspDeInit are not null, the Init/DeInit
  keep and use the user MspInit/MspDeInit callbacks (registered beforehand)
stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 133 : 
  Exception done MspInit/MspDeInit that can be registered/unregistered
  in HAL_LPTIM_STATE_READY or HAL_LPTIM_STATE_RESET state,
  thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
  In that case first register the MspInit/MspDeInit user callbacks
  using @ref HAL_LPTIM_RegisterCallback() before calling DeInit or Init function.
stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 181 : 
#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)
static void LPTIM_ResetCallback(LPTIM_HandleTypeDef *lptim);
#endif /* USE_HAL_LPTIM_REGISTER_CALLBACKS */

/* Exported functions --------------------------------------------------------*/
HAL_LPTIM_Init in stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (hlptim->State == HAL_LPTIM_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hlptim->Lock = HAL_UNLOCKED;
HAL_LPTIM_Init in stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)
    /* Reset interrupt callbacks to legacy weak callbacks */
    LPTIM_ResetCallback(hlptim);

    if (hlptim->MspInitCallback == NULL)
    {
HAL_LPTIM_DeInit in stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Change the LPTIM state */
  hlptim->State = HAL_LPTIM_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(hlptim);
HAL_LPTIM_PWM_Start in stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset WAVE bit to set PWM mode */
  hlptim->Instance->CFGR &= ~LPTIM_CFGR_WAVE;

  /* Enable the Peripheral */
HAL_LPTIM_PWM_Start_IT in stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset WAVE bit to set PWM mode */
  hlptim->Instance->CFGR &= ~LPTIM_CFGR_WAVE;

  /* Enable Autoreload write complete interrupt */
HAL_LPTIM_OnePulse_Start in stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset WAVE bit to set one pulse mode */
  hlptim->Instance->CFGR &= ~LPTIM_CFGR_WAVE;

  /* Enable the Peripheral */
HAL_LPTIM_OnePulse_Start_IT in stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset WAVE bit to set one pulse mode */
  hlptim->Instance->CFGR &= ~LPTIM_CFGR_WAVE;

  /* Enable Autoreload write complete interrupt */
HAL_LPTIM_Encoder_Stop in stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset ENC bit to disable the encoder interface */
  hlptim->Instance->CFGR &= ~LPTIM_CFGR_ENC;

  /* Change the TIM state*/
HAL_LPTIM_Encoder_Stop_IT in stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset ENC bit to disable the encoder interface */
  hlptim->Instance->CFGR &= ~LPTIM_CFGR_ENC;

  /* Disable "switch to down direction" interrupt */
stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 1207 : 
  * @note   The first trigger event will start the timer, any successive
  *         trigger event will reset the counter and the timer restarts.
  * @param  hlptim LPTIM handle
  * @param  Period Specifies the Autoreload value.
  *         This parameter must be a value between 0x0000 and 0xFFFF.
  * @param  Timeout Specifies the TimeOut value to reset the counter.
  *         This parameter must be a value between 0x0000 and 0xFFFF.
  * @retval HAL status
  */
HAL_LPTIM_TimeOut_Stop in stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset TIMOUT bit to enable the timeout function */
  hlptim->Instance->CFGR &= ~LPTIM_CFGR_TIMOUT;

  /* Change the TIM state*/
stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 1276 : 
  * @note   The first trigger event will start the timer, any successive
  *         trigger event will reset the counter and the timer restarts.
  * @param  hlptim LPTIM handle
  * @param  Period Specifies the Autoreload value.
  *         This parameter must be a value between 0x0000 and 0xFFFF.
  * @param  Timeout Specifies the TimeOut value to reset the counter.
  *         This parameter must be a value between 0x0000 and 0xFFFF.
  * @retval HAL status
  */
HAL_LPTIM_TimeOut_Stop_IT in stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset TIMOUT bit to enable the timeout function */
  hlptim->Instance->CFGR &= ~LPTIM_CFGR_TIMOUT;

  /* Disable Compare match interrupt */
HAL_LPTIM_IRQHandler in stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Compare match interrupt */
  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_CMPM) != RESET)
  {
    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_CMPM) != RESET)
    {
      /* Clear Compare match flag */
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_CMPM);
HAL_LPTIM_IRQHandler in stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Autoreload match interrupt */
  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_ARRM) != RESET)
  {
    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_ARRM) != RESET)
    {
      /* Clear Autoreload match flag */
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARRM);
HAL_LPTIM_IRQHandler in stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Trigger detected interrupt */
  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_EXTTRIG) != RESET)
  {
    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_EXTTRIG) != RESET)
    {
      /* Clear Trigger detected flag */
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_EXTTRIG);
HAL_LPTIM_IRQHandler in stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Compare write interrupt */
  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_CMPOK) != RESET)
  {
    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_CMPOK) != RESET)
    {
      /* Clear Compare write flag */
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_CMPOK);
HAL_LPTIM_IRQHandler in stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Autoreload write interrupt */
  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_ARROK) != RESET)
  {
    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_ARROK) != RESET)
    {
      /* Clear Autoreload write flag */
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);
HAL_LPTIM_IRQHandler in stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Direction counter changed from Down to Up interrupt */
  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_UP) != RESET)
  {
    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_UP) != RESET)
    {
      /* Clear Direction counter changed from Down to Up flag */
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_UP);
HAL_LPTIM_IRQHandler in stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Direction counter changed from Up to Down interrupt */
  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_DOWN) != RESET)
  {
    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_DOWN) != RESET)
    {
      /* Clear Direction counter changed from Up to Down flag */
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_DOWN);
HAL_LPTIM_IRQHandler in stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
     overflowed */
  if(__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_UPDATE) != RESET)
  {
    if(__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_UPDATE) != RESET)
    {
      /* Clear update event flag */
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_UPDATE);
HAL_LPTIM_IRQHandler in stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Successful APB bus write to repetition counter register */
  if(__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_REPOK) != RESET)
  {
    if(__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_REPOK) != RESET)
    {
      /* Clear successful APB bus write to repetition counter flag */
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_REPOK);
HAL_LPTIM_RegisterCallback in stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (hlptim->State == HAL_LPTIM_STATE_RESET)
  {
    switch (CallbackID)
    {
HAL_LPTIM_UnRegisterCallback in stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (hlptim->State == HAL_LPTIM_STATE_RESET)
  {
    switch (CallbackID)
    {
stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 2192 : 
/**
  * @brief  Reset interrupt callbacks to the legacy weak callbacks.
  * @param  lptim pointer to a LPTIM_HandleTypeDef structure that contains
  *                the configuration information for LPTIM module.
  * @retval None
  */
static void LPTIM_ResetCallback(LPTIM_HandleTypeDef *lptim)
{
  /* Reset the LPTIM callback to the legacy weak callbacks */
  lptim->CompareMatchCallback    = HAL_LPTIM_CompareMatchCallback;    /* Compare match Callback                       */
  lptim->AutoReloadMatchCallback = HAL_LPTIM_AutoReloadMatchCallback; /* Auto-reload match Callback                   */
  lptim->TriggerCallback         = HAL_LPTIM_TriggerCallback;         /* External trigger event detection Callback    */
LPTIM_Disable in stm32l4xx_hal_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /*********** Reset LPTIM ***********/
  switch ((uint32_t)lptim->Instance)
  {
     case LPTIM1_BASE:
       __HAL_RCC_LPTIM1_FORCE_RESET();
       __HAL_RCC_LPTIM1_RELEASE_RESET();
       break;
#if defined(LPTIM2)
     case LPTIM2_BASE:
       __HAL_RCC_LPTIM2_FORCE_RESET();
       __HAL_RCC_LPTIM2_RELEASE_RESET();
       break;
#endif /* LPTIM2 */
     default:
stm32l4xx_hal_lptim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 140 : 
{
  HAL_LPTIM_STATE_RESET            = 0x00U,    /*!< Peripheral not yet initialized or disabled  */
  HAL_LPTIM_STATE_READY            = 0x01U,    /*!< Peripheral Initialized and ready for use    */
  HAL_LPTIM_STATE_BUSY             = 0x02U,    /*!< An internal process is ongoing              */
  HAL_LPTIM_STATE_TIMEOUT          = 0x03U,    /*!< Timeout state                               */
stm32l4xx_hal_lptim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 398 : 

/** @brief Reset LPTIM handle state.
  * @param  __HANDLE__ LPTIM handle
  * @retval None
  */
#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)
#define __HAL_LPTIM_RESET_HANDLE_STATE(__HANDLE__) do {                                                        \
                                                      (__HANDLE__)->State             = HAL_LPTIM_STATE_RESET; \
                                                      (__HANDLE__)->MspInitCallback   = NULL;                  \
                                                      (__HANDLE__)->MspDeInitCallback = NULL;                  \
                                                     } while(0)
#else
#define __HAL_LPTIM_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_LPTIM_STATE_RESET)
#endif /* USE_HAL_LPTIM_REGISTER_CALLBACKS */

/**
stm32l4xx_hal_lptim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 493 : 
  *            @arg LPTIM_FLAG_CMPM    : Compare match Flag.
  * @retval The state of the specified flag (SET or RESET).
  */
#define __HAL_LPTIM_GET_FLAG(__HANDLE__, __FLAG__)          (((__HANDLE__)->Instance->ISR &(__FLAG__)) == (__FLAG__))

stm32l4xx_hal_lptim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 564 : 

#define __HAL_LPTIM_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((((__HANDLE__)->Instance->IER & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)

/**
  * @brief  Enable interrupt on the LPTIM Wake-up Timer associated Exti line.
stm32l4xx_hal_ltdc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 110 : 
    [..]
    Use function HAL_LTDC_UnRegisterCallback() to reset a callback to the default
    weak function.
    HAL_LTDC_UnRegisterCallback() takes as parameters the HAL peripheral handle
    and the callback ID.
    [..]
    This function allows to reset following callbacks:
      (+) LineEventCallback   : LTDC Line Event Callback
      (+) ReloadEventCallback : LTDC Reload Event Callback
      (+) ErrorCallback       : LTDC Error Callback
stm32l4xx_hal_ltdc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 123 : 
    [..]
    By default, after the HAL_LTDC_Init and when the state is HAL_LTDC_STATE_RESET
    all callbacks are set to the corresponding weak functions:
    examples HAL_LTDC_LineEventCallback(), HAL_LTDC_ErrorCallback().
    Exception done for MspInit and MspDeInit functions that are
    reset to the legacy weak (surcharged) functions in the HAL_LTDC_Init() and HAL_LTDC_DeInit()
    only when these callbacks are null (not registered beforehand).
    If not, MspInit or MspDeInit are not null, the HAL_LTDC_Init() and HAL_LTDC_DeInit()
    keep and use the user MspInit/MspDeInit callbacks (registered beforehand).
stm32l4xx_hal_ltdc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 135 : 
    Exception done MspInit/MspDeInit that can be registered/unregistered
    in HAL_LTDC_STATE_READY or HAL_LTDC_STATE_RESET state,
    thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
    In that case first register the MspInit/MspDeInit user callbacks
    using HAL_LTDC_RegisterCallback() before calling HAL_LTDC_DeInit()
HAL_LTDC_Init in stm32l4xx_hal_ltdc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_HAL_LTDC_REGISTER_CALLBACKS == 1)
  if (hltdc->State == HAL_LTDC_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hltdc->Lock = HAL_UNLOCKED;

    /* Reset the LTDC callback to the legacy weak callbacks */
    hltdc->LineEventCallback   = HAL_LTDC_LineEventCallback;    /* Legacy weak LineEventCallback    */
    hltdc->ReloadEventCallback = HAL_LTDC_ReloadEventCallback;  /* Legacy weak ReloadEventCallback  */
    hltdc->ErrorCallback       = HAL_LTDC_ErrorCallback;        /* Legacy weak ErrorCallback        */
HAL_LTDC_Init in stm32l4xx_hal_ltdc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#else
  if (hltdc->State == HAL_LTDC_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hltdc->Lock = HAL_UNLOCKED;
HAL_LTDC_DeInit in stm32l4xx_hal_ltdc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Initialize the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(hltdc);
HAL_LTDC_RegisterCallback in stm32l4xx_hal_ltdc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (hltdc->State == HAL_LTDC_STATE_RESET)
  {
    switch (CallbackID)
    {
HAL_LTDC_UnRegisterCallback in stm32l4xx_hal_ltdc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (hltdc->State == HAL_LTDC_STATE_RESET)
  {
    switch (CallbackID)
    {
stm32l4xx_hal_ltdc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 160 : 
{
  HAL_LTDC_STATE_RESET             = 0x00U,    /*!< LTDC not yet initialized or disabled */
  HAL_LTDC_STATE_READY             = 0x01U,    /*!< LTDC initialized and ready for use   */
  HAL_LTDC_STATE_BUSY              = 0x02U,    /*!< LTDC internal process is ongoing     */
  HAL_LTDC_STATE_TIMEOUT           = 0x03U,    /*!< LTDC Timeout state                   */
stm32l4xx_hal_ltdc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 405 : 

/** @brief Reset LTDC handle state.
  * @param  __HANDLE__  LTDC handle
  * @retval None
  */
#if (USE_HAL_LTDC_REGISTER_CALLBACKS == 1)
#define __HAL_LTDC_RESET_HANDLE_STATE(__HANDLE__) do{                                                  \
                                                      (__HANDLE__)->State = HAL_LTDC_STATE_RESET;     \
                                                      (__HANDLE__)->MspInitCallback = NULL;           \
                                                      (__HANDLE__)->MspDeInitCallback = NULL;         \
                                                    } while(0)
#else
#define __HAL_LTDC_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_LTDC_STATE_RESET)
#endif /*USE_HAL_LTDC_REGISTER_CALLBACKS */

/**
stm32l4xx_hal_ltdc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 475 : 
  *            @arg LTDC_FLAG_RR: Register Reload Interrupt Flag
  * @retval The state of FLAG (SET or RESET).
  */
#define __HAL_LTDC_GET_FLAG(__HANDLE__, __FLAG__) ((__HANDLE__)->Instance->ISR & (__FLAG__))

stm32l4xx_hal_ltdc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 527 : 
  *            @arg LTDC_IT_RR: Register Reload Interrupt Flag
  * @retval The state of INTERRUPT (SET or RESET).
  */
#define __HAL_LTDC_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((__HANDLE__)->Instance->IER & (__INTERRUPT__))
/**
stm32l4xx_hal_mmc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 210 : 

    Use function @ref HAL_MMC_UnRegisterCallback() to reset a callback to the default
    weak (surcharged) function. It allows to reset following callbacks:
      (+) TxCpltCallback : callback when a transmission transfer is completed.
      (+) RxCpltCallback : callback when a reception transfer is completed.
      (+) ErrorCallback : callback when error occurs.
stm32l4xx_hal_mmc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 224 : 

    By default, after the @ref HAL_MMC_Init and if the state is HAL_MMC_STATE_RESET
    all callbacks are reset to the corresponding legacy weak (surcharged) functions.
    Exception done for MspInit and MspDeInit callbacks that are respectively
    reset to the legacy weak (surcharged) functions in the @ref HAL_MMC_Init
    and @ref  HAL_MMC_DeInit only when these callbacks are null (not registered beforehand).
    If not, MspInit or MspDeInit are not null, the @ref HAL_MMC_Init and @ref HAL_MMC_DeInit
    keep and use the user MspInit/MspDeInit callbacks (registered beforehand)
stm32l4xx_hal_mmc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 234 : 
    Exception done for MspInit/MspDeInit callbacks that can be registered/unregistered
    in READY or RESET state, thus registered (user) MspInit/DeInit callbacks can be used
    during the Init/DeInit.
    In that case first register the MspInit/MspDeInit user callbacks
    using @ref HAL_MMC_RegisterCallback before calling @ref HAL_MMC_DeInit
HAL_MMC_Init in stm32l4xx_hal_mmc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if(hmmc->State == HAL_MMC_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hmmc->Lock = HAL_UNLOCKED;
#if defined (USE_HAL_MMC_REGISTER_CALLBACKS) && (USE_HAL_MMC_REGISTER_CALLBACKS == 1U)
    /* Reset Callback pointers in HAL_MMC_STATE_RESET only */
    hmmc->TxCpltCallback    = HAL_MMC_TxCpltCallback;
    hmmc->RxCpltCallback    = HAL_MMC_RxCpltCallback;
    hmmc->ErrorCallback     = HAL_MMC_ErrorCallback;
HAL_MMC_DeInit in stm32l4xx_hal_mmc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  hmmc->ErrorCode = HAL_MMC_ERROR_NONE;
  hmmc->State = HAL_MMC_STATE_RESET;

  return HAL_OK;
}
HAL_MMC_IRQHandler in stm32l4xx_hal_mmc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Check for SDMMC interrupt flags */
  if((__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_RXFIFOHF) != RESET) && ((context & MMC_CONTEXT_IT) != 0U))
  {
    MMC_Read_IT(hmmc);
  }

  else if(__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_DATAEND) != RESET)
  {
    __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_FLAG_DATAEND);

HAL_MMC_IRQHandler in stm32l4xx_hal_mmc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  else if((__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_TXFIFOHE) != RESET) && ((context & MMC_CONTEXT_IT) != 0U))
  {
    MMC_Write_IT(hmmc);
  }

  else if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_DCRCFAIL| SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_RXOVERR | SDMMC_FLAG_TXUNDERR) != RESET)
  {
    /* Set Error code */
    if(__HAL_MMC_GET_FLAG(hmmc, SDMMC_IT_DCRCFAIL) != RESET)
    {
      hmmc->ErrorCode |= HAL_MMC_ERROR_DATA_CRC_FAIL;
    }
    if(__HAL_MMC_GET_FLAG(hmmc, SDMMC_IT_DTIMEOUT) != RESET)
    {
      hmmc->ErrorCode |= HAL_MMC_ERROR_DATA_TIMEOUT;
    }
    if(__HAL_MMC_GET_FLAG(hmmc, SDMMC_IT_RXOVERR) != RESET)
    {
      hmmc->ErrorCode |= HAL_MMC_ERROR_RX_OVERRUN;
    }
    if(__HAL_MMC_GET_FLAG(hmmc, SDMMC_IT_TXUNDERR) != RESET)
    {
      hmmc->ErrorCode |= HAL_MMC_ERROR_TX_UNDERRUN;
    }
HAL_MMC_IRQHandler in stm32l4xx_hal_mmc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  else if(__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_IDMABTC) != RESET)
  {
    __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_IT_IDMABTC);
    if(READ_BIT(hmmc->Instance->IDMACTRL, SDMMC_IDMA_IDMABACT) == 0U)
HAL_MMC_RegisterCallback in stm32l4xx_hal_mmc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (hmmc->State == HAL_MMC_STATE_RESET)
  {
    switch (CallbackId)
    {
HAL_MMC_UnRegisterCallback in stm32l4xx_hal_mmc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (hmmc->State == HAL_MMC_STATE_RESET)
  {
    switch (CallbackId)
    {
stm32l4xx_hal_mmc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 51 : 
{
  HAL_MMC_STATE_RESET                  = ((uint32_t)0x00000000U),  /*!< MMC not yet initialized or disabled  */
  HAL_MMC_STATE_READY                  = ((uint32_t)0x00000001U),  /*!< MMC initialized and ready for use    */
  HAL_MMC_STATE_TIMEOUT                = ((uint32_t)0x00000002U),  /*!< MMC Timeout state                    */
  HAL_MMC_STATE_BUSY                   = ((uint32_t)0x00000003U),  /*!< MMC process ongoing                  */
stm32l4xx_hal_mmc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 314 : 
#define HAL_MMC_ERROR_CARD_ECC_DISABLED        SDMMC_ERROR_CARD_ECC_DISABLED       /*!< Command has been executed without using internal ECC          */
#define HAL_MMC_ERROR_ERASE_RESET              SDMMC_ERROR_ERASE_RESET             /*!< Erase sequence was cleared before executing because an out
                                                                                        of erase sequence command was received                        */
#define HAL_MMC_ERROR_AKE_SEQ_ERR              SDMMC_ERROR_AKE_SEQ_ERR             /*!< Error in sequence of authentication                           */
#define HAL_MMC_ERROR_INVALID_VOLTRANGE        SDMMC_ERROR_INVALID_VOLTRANGE       /*!< Error in case of invalid voltage range                        */
stm32l4xx_hal_mmc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 382 : 
 */
/** @brief Reset MMC handle state.
  * @param  __HANDLE__ : MMC handle.
  * @retval None
  */
#if defined (USE_HAL_MMC_REGISTER_CALLBACKS) && (USE_HAL_MMC_REGISTER_CALLBACKS == 1U)
#define __HAL_MMC_RESET_HANDLE_STATE(__HANDLE__)           do {                                              \
                                                               (__HANDLE__)->State = HAL_MMC_STATE_RESET; \
                                                               (__HANDLE__)->MspInitCallback = NULL;       \
                                                               (__HANDLE__)->MspDeInitCallback = NULL;     \
                                                             } while(0)
#else
#define __HAL_MMC_RESET_HANDLE_STATE(__HANDLE__)           ((__HANDLE__)->State = HAL_MMC_STATE_RESET)
#endif
 
#if !defined(STM32L4R5xx) && !defined(STM32L4R7xx) && !defined(STM32L4R9xx) && !defined(STM32L4S5xx) && !defined(STM32L4S7xx) && !defined(STM32L4S9xx)
stm32l4xx_hal_mmc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 539 : 
  *            @arg SDMMC_FLAG_IDMABTC:    IDMA buffer transfer complete
  * @retval The new state of MMC FLAG (SET or RESET).
  */
#define __HAL_MMC_GET_FLAG(__HANDLE__, __FLAG__) __SDMMC_GET_FLAG((__HANDLE__)->Instance, (__FLAG__))

stm32l4xx_hal_mmc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 607 : 
  *            @arg SDMMC_IT_IDMABTC:    IDMA buffer transfer complete interrupt
  * @retval The new state of MMC IT (SET or RESET).
  */
#define __HAL_MMC_GET_IT(__HANDLE__, __INTERRUPT__) __SDMMC_GET_IT((__HANDLE__)->Instance, (__INTERRUPT__))

stm32l4xx_hal_nand.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 34 : 

      (+) Perform NAND flash Reset chip operation using the function HAL_NAND_Reset().

      (+) Perform NAND flash erase block operation using the function HAL_NAND_Erase_Block().
          The erase block address information is contained in the Nand_Address_Typedef
HAL_NAND_Init in stm32l4xx_hal_nand.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if(hnand->State == HAL_NAND_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hnand->Lock = HAL_UNLOCKED;
HAL_NAND_DeInit in stm32l4xx_hal_nand.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Configure the NAND registers with their reset values */
  FMC_NAND_DeInit(hnand->Instance, hnand->Init.NandBank);

  /* Reset the NAND controller state */
  hnand->State = HAL_NAND_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(hnand);
stm32l4xx_hal_nand.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 361 : 
/**
  * @brief  NAND memory reset
  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains
  *                the configuration information for NAND module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_NAND_Reset(NAND_HandleTypeDef *hnand)
{
  uint32_t deviceAddress = 0;

HAL_NAND_Reset in stm32l4xx_hal_nand.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Send NAND reset command */
  *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = 0xFF;

  /* Update the NAND controller state */
stm32l4xx_hal_nand.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 51 : 
{
  HAL_NAND_STATE_RESET     = 0x00U,  /*!< NAND not yet initialized or disabled */
  HAL_NAND_STATE_READY     = 0x01U,  /*!< NAND initialized and ready for use   */
  HAL_NAND_STATE_BUSY      = 0x02U,  /*!< NAND internal process is ongoing     */
  HAL_NAND_STATE_ERROR     = 0x03U   /*!< NAND error state                     */
stm32l4xx_hal_nand.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 137 : 

/** @brief Reset NAND handle state
  * @param  __HANDLE__ specifies the NAND handle.
  * @retval None
  */
#define __HAL_NAND_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_NAND_STATE_RESET)

/**
  * @}
stm32l4xx_hal_nand.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 179 : 

HAL_StatusTypeDef  HAL_NAND_Reset(NAND_HandleTypeDef *hnand);

HAL_StatusTypeDef  HAL_NAND_Read_Page_8b(NAND_HandleTypeDef *hnand, NAND_AddressTypeDef *pAddress, uint8_t *pBuffer, uint32_t NumPageToRead);
HAL_StatusTypeDef  HAL_NAND_Write_Page_8b(NAND_HandleTypeDef *hnand, NAND_AddressTypeDef *pAddress, uint8_t *pBuffer, uint32_t NumPageToWrite);
stm32l4xx_hal_nand.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 249 : 
#define NAND_CMD_LOCK_STATUS       ((uint8_t)0x7AU)
#define NAND_CMD_RESET             ((uint8_t)0xFFU)

/* NAND memory status */
#define NAND_VALID_ADDRESS         ((uint32_t)0x00000100U)
stm32l4xx_hal_nor.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 99 : 
/* Constants to define data to program a command */
#define NOR_CMD_DATA_READ_RESET               (uint16_t)0x00F0
#define NOR_CMD_DATA_FIRST                    (uint16_t)0x00AA
#define NOR_CMD_DATA_SECOND                   (uint16_t)0x0055
#define NOR_CMD_DATA_AUTO_SELECT              (uint16_t)0x0090
HAL_NOR_Init in stm32l4xx_hal_nor.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if(hnor->State == HAL_NOR_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hnor->Lock = HAL_UNLOCKED;
HAL_NOR_DeInit in stm32l4xx_hal_nor.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Configure the NOR registers with their reset values */
  FMC_NORSRAM_DeInit(hnor->Instance, hnor->Extended, hnor->Init.NSBank);

  /* Update the NOR controller state */
  hnor->State = HAL_NOR_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(hnor);
HAL_NOR_ReturnToReadMode in stm32l4xx_hal_nor.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  NOR_WRITE(deviceaddress, NOR_CMD_DATA_READ_RESET);

  /* Check the NOR controller state */
  hnor->State = HAL_NOR_STATE_READY;
HAL_NOR_Read in stm32l4xx_hal_nor.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  NOR_WRITE(NOR_ADDR_SHIFT(deviceaddress, uwNORMemoryDataWidth, NOR_CMD_ADDRESS_SECOND), NOR_CMD_DATA_SECOND);
  NOR_WRITE(NOR_ADDR_SHIFT(deviceaddress, uwNORMemoryDataWidth, NOR_CMD_ADDRESS_THIRD), NOR_CMD_DATA_READ_RESET);

  /* Read the data */
  *pData = *(__IO uint32_t *)(uint32_t)pAddress;
HAL_NOR_ReadBuffer in stm32l4xx_hal_nor.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  NOR_WRITE(NOR_ADDR_SHIFT(deviceaddress, uwNORMemoryDataWidth, NOR_CMD_ADDRESS_SECOND), NOR_CMD_DATA_SECOND);
  NOR_WRITE(NOR_ADDR_SHIFT(deviceaddress, uwNORMemoryDataWidth, NOR_CMD_ADDRESS_THIRD), NOR_CMD_DATA_READ_RESET);

  /* Read buffer */
  while( uwBufferSize > 0)
stm32l4xx_hal_nor.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 51 : 
{
  HAL_NOR_STATE_RESET             = 0x00U,  /*!< NOR not yet initialized or disabled  */
  HAL_NOR_STATE_READY             = 0x01U,  /*!< NOR initialized and ready for use    */
  HAL_NOR_STATE_BUSY              = 0x02U,  /*!< NOR internal processing is ongoing   */
  HAL_NOR_STATE_ERROR             = 0x03U,  /*!< NOR error state                      */
stm32l4xx_hal_nor.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 128 : 
  */
/** @brief Reset NOR handle state
  * @param  __HANDLE__ specifies the NOR handle.
  * @retval None
  */
#define __HAL_NOR_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_NOR_STATE_RESET)
/**
  * @}
  */
stm32l4xx_hal_opamp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 123 : 

      (++) Use function @ref HAL_OPAMP_UnRegisterCallback() to reset a callback to the default
           weak (surcharged) function. It allows to reset following callbacks:
      (+++) MspInitCallback         : OPAMP MspInit.
      (+++) MspDeInitCallback       : OPAMP MspdeInit.
      (+++) All Callbacks
stm32l4xx_hal_opamp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 229 : 

/* CSR register reset value */
#define OPAMP_CSR_RESET_VALUE             ((uint32_t)0x00000000)

#define OPAMP_CSR_RESET_BITS    (OPAMP_CSR_OPAMPxEN | OPAMP_CSR_OPALPM | OPAMP_CSR_OPAMODE \
                               | OPAMP_CSR_PGGAIN | OPAMP_CSR_VMSEL | OPAMP_CSR_VPSEL \
                               | OPAMP_CSR_CALON | OPAMP_CSR_USERTRIM)

stm32l4xx_hal_opamp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 275 : 
  * @note   If the selected opamp is locked, initialization can't be performed.
  *         To unlock the configuration, perform a system reset.
  * @param  hopamp: OPAMP handle
  * @retval HAL status
  */
HAL_OPAMP_Init in stm32l4xx_hal_opamp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    if(hopamp->State == HAL_OPAMP_STATE_RESET)
    {
#if (USE_HAL_OPAMP_REGISTER_CALLBACKS == 1)
    if(hopamp->MspInitCallback == NULL)
HAL_OPAMP_Init in stm32l4xx_hal_opamp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    if(hopamp->State == HAL_OPAMP_STATE_RESET)
    {
      /* Allocate lock resource and initialize it */
      hopamp->Lock = HAL_UNLOCKED;
HAL_OPAMP_Init in stm32l4xx_hal_opamp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Update the OPAMP state*/
    if (hopamp->State == HAL_OPAMP_STATE_RESET)
    {
      /* From RESET state to READY State */
      hopamp->State = HAL_OPAMP_STATE_READY;
    }
    /* else: remain in READY or BUSY state (no update) */
HAL_OPAMP_DeInit in stm32l4xx_hal_opamp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Set OPAMP_CSR register to reset value */
    /* Mind that OPAMP1_CSR_OPARANGE of CSR of OPAMP1 remains unchanged (applies to both OPAMPs) */
    /* OPAMP shall be disabled first separately */
    CLEAR_BIT(hopamp->Instance->CSR, OPAMP_CSR_OPAMPxEN);
    MODIFY_REG(hopamp->Instance->CSR, OPAMP_CSR_RESET_BITS, OPAMP_CSR_RESET_VALUE);

#if (USE_HAL_OPAMP_REGISTER_CALLBACKS == 1)
  if(hopamp->MspDeInitCallback == NULL)
HAL_OPAMP_DeInit in stm32l4xx_hal_opamp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Update the OPAMP state*/
    hopamp->State = HAL_OPAMP_STATE_RESET;

    /* Process unlocked */
    __HAL_UNLOCK(hopamp);
HAL_OPAMP_GetState in stm32l4xx_hal_opamp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    return HAL_OPAMP_STATE_RESET;
  }

  /* Check the parameter */
HAL_OPAMP_RegisterCallback in stm32l4xx_hal_opamp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (hopamp->State == HAL_OPAMP_STATE_RESET)
  {
    switch (CallbackID)
    {
HAL_OPAMP_UnRegisterCallback in stm32l4xx_hal_opamp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (hopamp->State == HAL_OPAMP_STATE_RESET)
  {
    switch (CallbackID)
    {
stm32l4xx_hal_opamp.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 107 : 
{
  HAL_OPAMP_STATE_RESET               = 0x00000000, /*!< OPAMP is not yet Initialized          */

  HAL_OPAMP_STATE_READY               = 0x00000001, /*!< OPAMP is initialized and ready for use */
  HAL_OPAMP_STATE_CALIBBUSY           = 0x00000002, /*!< OPAMP is enabled in auto calibration mode */
stm32l4xx_hal_opamp.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 114 : 
  HAL_OPAMP_STATE_BUSYLOCKED          = 0x00000005  /*!< OPAMP is locked
                                                         only system reset allows reconfiguring the opamp. */

}HAL_OPAMP_StateTypeDef;

stm32l4xx_hal_opamp.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 291 : 

/** @brief Reset OPAMP handle state.
  * @param  __HANDLE__: OPAMP handle.
  * @retval None
  */
#if (USE_HAL_OPAMP_REGISTER_CALLBACKS == 1)
#define __HAL_OPAMP_RESET_HANDLE_STATE(__HANDLE__)           do {                                              \
                                                                 (__HANDLE__)->State = HAL_OPAMP_STATE_RESET; \
                                                                 (__HANDLE__)->MspInitCallback = NULL;       \
                                                                 (__HANDLE__)->MspDeInitCallback = NULL;     \
                                                               } while(0)
#else
#define __HAL_OPAMP_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_OPAMP_STATE_RESET)
#endif /* USE_HAL_OPAMP_REGISTER_CALLBACKS */


stm32l4xx_hal_ospi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 27 : 
        (++) Enable OctoSPI and OctoSPIM clocks interface with __HAL_RCC_OSPIx_CLK_ENABLE().
        (++) Reset OctoSPI Peripheral with __HAL_RCC_OSPIx_FORCE_RESET() and __HAL_RCC_OSPIx_RELEASE_RESET().
        (++) Enable the clocks for the OctoSPI GPIOS with __HAL_RCC_GPIOx_CLK_ENABLE().
        (++) Configure these OctoSPI pins in alternate mode using HAL_GPIO_Init().
        (++) If interrupt or DMA mode is used, enable and configure OctoSPI global
stm32l4xx_hal_ospi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 163 : 

      Use function @ref HAL_OSPI_UnRegisterCallback() to reset a callback to the default
      weak (surcharged) function. It allows to reset following callbacks:
        (+) ErrorCallback : callback when error occurs.
        (+) AbortCpltCallback : callback when abort is completed.
        (+) FifoThresholdCallback : callback when the fifo threshold is reached.
stm32l4xx_hal_ospi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 179 : 

      By default, after the @ref HAL_OSPI_Init and if the state is HAL_OSPI_STATE_RESET
      all callbacks are reset to the corresponding legacy weak (surcharged) functions.
      Exception done for MspInit and MspDeInit callbacks that are respectively
      reset to the legacy weak (surcharged) functions in the @ref HAL_OSPI_Init
      and @ref  HAL_OSPI_DeInit only when these callbacks are null (not registered beforehand).
      If not, MspInit or MspDeInit are not null, the @ref HAL_OSPI_Init and @ref HAL_OSPI_DeInit
      keep and use the user MspInit/MspDeInit callbacks (registered beforehand)
stm32l4xx_hal_ospi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 189 : 
      Exception done for MspInit/MspDeInit callbacks that can be registered/unregistered
      in READY or RESET state, thus registered (user) MspInit/DeInit callbacks can be used
      during the Init/DeInit.
      In that case first register the MspInit/MspDeInit user callbacks
      using @ref HAL_OSPI_RegisterCallback before calling @ref HAL_OSPI_DeInit
HAL_OSPI_Init in stm32l4xx_hal_ospi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Check if the state is the reset state */
    if (hospi->State == HAL_OSPI_STATE_RESET)
    {
#if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
      /* Reset Callback pointers in HAL_OSPI_STATE_RESET only */
      hospi->ErrorCallback         = HAL_OSPI_ErrorCallback;
      hospi->AbortCpltCallback     = HAL_OSPI_AbortCpltCallback;
      hospi->FifoThresholdCallback = HAL_OSPI_FifoThresholdCallback;
HAL_OSPI_Init in stm32l4xx_hal_ospi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

      /* Wait till busy flag is reset */
      status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);

      if (status == HAL_OK)
      {
HAL_OSPI_DeInit in stm32l4xx_hal_ospi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

     /* Reset the driver state */
     hospi->State = HAL_OSPI_STATE_RESET;
  }

  return status;
HAL_OSPI_Command in stm32l4xx_hal_ospi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Wait till busy flag is reset */
    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, Timeout);

    if (status == HAL_OK)
    {
HAL_OSPI_Command_IT in stm32l4xx_hal_ospi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Wait till busy flag is reset */
    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);

    if (status == HAL_OK)
    {
HAL_OSPI_HyperbusCfg in stm32l4xx_hal_ospi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Wait till busy flag is reset */
    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, Timeout);

    if (status == HAL_OK)
    {
HAL_OSPI_HyperbusCmd in stm32l4xx_hal_ospi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Wait till busy flag is reset */
    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, Timeout);

    if (status == HAL_OK)
    {
HAL_OSPI_AutoPolling in stm32l4xx_hal_ospi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Wait till busy flag is reset */
    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, Timeout);

    if (status == HAL_OK)
    {
HAL_OSPI_AutoPolling_IT in stm32l4xx_hal_ospi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Wait till busy flag is reset */
    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);

    if (status == HAL_OK)
    {
HAL_OSPI_MemoryMapped in stm32l4xx_hal_ospi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Wait till busy flag is reset */
    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);

    if (status == HAL_OK)
    {
HAL_OSPI_RegisterCallback in stm32l4xx_hal_ospi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (hospi->State == HAL_OSPI_STATE_RESET)
  {
    switch (CallbackID)
    {
HAL_OSPI_UnRegisterCallback in stm32l4xx_hal_ospi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (hospi->State == HAL_OSPI_STATE_RESET)
  {
    switch (CallbackID)
    {
HAL_OSPI_Abort in stm32l4xx_hal_ospi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    if (__HAL_OSPI_GET_FLAG(hospi, HAL_OSPI_FLAG_BUSY) != RESET)
    {
      /* Perform an abort of the OctoSPI */
      SET_BIT(hospi->Instance->CR, OCTOSPI_CR_ABORT);
HAL_OSPI_Abort in stm32l4xx_hal_ospi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

        /* Wait until the busy flag is reset to go back in idle state */
        status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);

        if (status == HAL_OK)
        {
HAL_OSPI_Abort_IT in stm32l4xx_hal_ospi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    {
      if (__HAL_OSPI_GET_FLAG(hospi, HAL_OSPI_FLAG_BUSY) != RESET)
      {
        /* Clear transfer complete flag */
        __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TC);
OSPI_DMAAbortCplt in stm32l4xx_hal_ospi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* DMA abort called by OctoSPI abort */
    if (__HAL_OSPI_GET_FLAG(hospi, HAL_OSPI_FLAG_BUSY) != RESET)
    {
      /* Clear transfer complete flag */
      __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TC);
stm32l4xx_hal_ospi.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 284 : 
  */
#define HAL_OSPI_STATE_RESET                 ((uint32_t)0x00000000U)      /*!< Initial state                                                          */
#define HAL_OSPI_STATE_HYPERBUS_INIT         ((uint32_t)0x00000001U)      /*!< Initialization done in hyperbus mode but timing configuration not done */
#define HAL_OSPI_STATE_READY                 ((uint32_t)0x00000002U)      /*!< Driver ready to be used                                                */
#define HAL_OSPI_STATE_CMD_CFG               ((uint32_t)0x00000004U)      /*!< Command (regular or hyperbus) configured, ready for an action          */
stm32l4xx_hal_ospi.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 647 : 
  */
/** @brief Reset OSPI handle state.
  * @param  __HANDLE__: OSPI handle.
  * @retval None
  */
#if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
#define __HAL_OSPI_RESET_HANDLE_STATE(__HANDLE__)           do {                                              \
                                                                  (__HANDLE__)->State = HAL_OSPI_STATE_RESET; \
                                                                  (__HANDLE__)->MspInitCallback = NULL;       \
                                                                  (__HANDLE__)->MspDeInitCallback = NULL;     \
                                                               } while(0)
#else
#define __HAL_OSPI_RESET_HANDLE_STATE(__HANDLE__)           ((__HANDLE__)->State = HAL_OSPI_STATE_RESET)
#endif

/** @brief  Enable the OSPI peripheral.
stm32l4xx_hal_ospi.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 726 : 
  */
#define __HAL_OSPI_GET_FLAG(__HANDLE__, __FLAG__)           ((READ_BIT((__HANDLE__)->Instance->SR, (__FLAG__)) != 0U) ? SET : RESET)

/** @brief  Clears the specified OSPI's flag status.
  * @param  __HANDLE__: specifies the OSPI Handle.
HAL_PCD_Init in stm32l4xx_hal_pcd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (hpcd->State == HAL_PCD_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hpcd->Lock = HAL_UNLOCKED;
HAL_PCD_Init in stm32l4xx_hal_pcd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    hpcd->SetupStageCallback = HAL_PCD_SetupStageCallback;
    hpcd->ResetCallback = HAL_PCD_ResetCallback;
    hpcd->SuspendCallback = HAL_PCD_SuspendCallback;
    hpcd->ResumeCallback = HAL_PCD_ResumeCallback;
    hpcd->ConnectCallback = HAL_PCD_ConnectCallback;
HAL_PCD_DeInit in stm32l4xx_hal_pcd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  hpcd->State = HAL_PCD_STATE_RESET;

  return HAL_OK;
}
stm32l4xx_hal_pcd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 322 : 
  *          @arg @ref HAL_PCD_SETUPSTAGE_CB_ID USB PCD Setup callback ID
  *          @arg @ref HAL_PCD_RESET_CB_ID USB PCD Reset callback ID
  *          @arg @ref HAL_PCD_SUSPEND_CB_ID USB PCD Suspend callback ID
  *          @arg @ref HAL_PCD_RESUME_CB_ID USB PCD Resume callback ID
  *          @arg @ref HAL_PCD_CONNECT_CB_ID USB PCD Connect callback ID
HAL_PCD_RegisterCallback in stm32l4xx_hal_pcd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

      case HAL_PCD_RESET_CB_ID :
        hpcd->ResetCallback = pCallback;
        break;

      case HAL_PCD_SUSPEND_CB_ID :
HAL_PCD_RegisterCallback in stm32l4xx_hal_pcd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (hpcd->State == HAL_PCD_STATE_RESET)
  {
    switch (CallbackID)
    {
stm32l4xx_hal_pcd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 434 : 
  *          @arg @ref HAL_PCD_SETUPSTAGE_CB_ID USB PCD Setup callback ID
  *          @arg @ref HAL_PCD_RESET_CB_ID USB PCD Reset callback ID
  *          @arg @ref HAL_PCD_SUSPEND_CB_ID USB PCD Suspend callback ID
  *          @arg @ref HAL_PCD_RESUME_CB_ID USB PCD Resume callback ID
  *          @arg @ref HAL_PCD_CONNECT_CB_ID USB PCD Connect callback ID
HAL_PCD_UnRegisterCallback in stm32l4xx_hal_pcd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

      case HAL_PCD_RESET_CB_ID :
        hpcd->ResetCallback = HAL_PCD_ResetCallback;
        break;

      case HAL_PCD_SUSPEND_CB_ID :
HAL_PCD_UnRegisterCallback in stm32l4xx_hal_pcd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (hpcd->State == HAL_PCD_STATE_RESET)
  {
    switch (CallbackID)
    {
HAL_PCD_IRQHandler in stm32l4xx_hal_pcd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    
    /* Handle Reset Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
HAL_PCD_IRQHandler in stm32l4xx_hal_pcd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ResetCallback(hpcd);
#else
      HAL_PCD_ResetCallback(hpcd);
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
HAL_PCD_IRQHandler in stm32l4xx_hal_pcd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_RESET))
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_RESET);

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
    hpcd->ResetCallback(hpcd);
#else
    HAL_PCD_ResetCallback(hpcd);
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

    (void)HAL_PCD_SetAddress(hpcd, 0U);
stm32l4xx_hal_pcd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 1595 : 
/**
  * @brief  USB Reset callback.
  * @param  hpcd PCD handle
  * @retval None
  */
__weak void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
{
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hpcd);
HAL_PCD_ResetCallback in stm32l4xx_hal_pcd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PCD_ResetCallback could be implemented in the user file
   */
}

stm32l4xx_hal_pcd.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 50 : 
{
  HAL_PCD_STATE_RESET   = 0x00,
  HAL_PCD_STATE_READY   = 0x01,
  HAL_PCD_STATE_ERROR   = 0x02,
  HAL_PCD_STATE_BUSY    = 0x03,
{anonPCD_HandleTypeDef} in stm32l4xx_hal_pcd.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) : 
  void (* SetupStageCallback)(struct __PCD_HandleTypeDef *hpcd);                       /*!< USB OTG PCD Setup Stage callback        */
  void (* ResetCallback)(struct __PCD_HandleTypeDef *hpcd);                            /*!< USB OTG PCD Reset callback              */
  void (* SuspendCallback)(struct __PCD_HandleTypeDef *hpcd);                          /*!< USB OTG PCD Suspend callback            */
  void (* ResumeCallback)(struct __PCD_HandleTypeDef *hpcd);                           /*!< USB OTG PCD Resume callback             */
  void (* ConnectCallback)(struct __PCD_HandleTypeDef *hpcd);                          /*!< USB OTG PCD Connect callback            */
stm32l4xx_hal_pcd.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 261 : 
  HAL_PCD_SETUPSTAGE_CB_ID   = 0x02,      /*!< USB PCD Setup Stage callback ID  */
  HAL_PCD_RESET_CB_ID        = 0x03,      /*!< USB PCD Reset callback ID        */
  HAL_PCD_SUSPEND_CB_ID      = 0x04,      /*!< USB PCD Suspend callback ID      */
  HAL_PCD_RESUME_CB_ID       = 0x05,      /*!< USB PCD Resume callback ID       */
  HAL_PCD_CONNECT_CB_ID      = 0x06,      /*!< USB PCD Connect callback ID      */
stm32l4xx_hal_pcd.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 328 : 
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd);
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd);
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd);
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd);
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd);
stm32l4xx_hal_pwr.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 83 : 
/**
  * @brief Deinitialize the HAL PWR peripheral registers to their default reset values.
  * @retval None
  */
void HAL_PWR_DeInit(void)
{
  __HAL_RCC_PWR_FORCE_RESET();
  __HAL_RCC_PWR_RELEASE_RESET();
}

/**
stm32l4xx_hal_pwr.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 95 : 
  *        (RTC registers, RTC backup data registers).
  * @note  After reset, the backup domain is protected against
  *        possible unwanted write accesses.
  * @note  RTCSEL that sets the RTC clock source selection is in the RTC back-up domain.
  *        In order to set or modify the RTC clock, the backup domain access must be
stm32l4xx_hal_pwr.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 182 : 
      (+) Exit:
        (++) clear LPR bit then wait for REGLP bit to be reset with HAL_PWREx_DisableLowPowerRunMode() API. Only
             then can the system clock frequency be increased above 2 MHz.


stm32l4xx_hal_pwr.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 254 : 
          (+++) WKUP pin rising edge, RTC alarm or wakeup, tamper event, time-stamp event,
                external reset in NRST pin, IWDG reset.

      [..]    After waking up from Standby mode, program execution restarts in the same way as after a Reset.


    *** Shutdown mode ***
stm32l4xx_hal_pwr.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 271 : 
          (++) WKUP pin rising edge, RTC alarm or wakeup, tamper event, time-stamp event,
               external reset in NRST pin.

         [..] After waking up from Shutdown mode, program execution restarts in the same way as after a Reset.


   *** Auto-wakeup (AWU) from low-power mode ***
HAL_PWR_EnterSLEEPMode in stm32l4xx_hal_pwr.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
       The system clock frequency must be below 2 MHz at this point. */
    if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF) == RESET)
    {
      HAL_PWREx_EnableLowPowerRunMode();
    }
HAL_PWREx_ControlVoltageScaling in stm32l4xx_hal_pwr_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    {
      /* Enable Range 1 Boost (no issue if bit already reset) */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
    }
  }
stm32l4xx_hal_pwr_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 377 : 
  * @note  The configuration is lost when exiting the Shutdown mode due to the
  *        power-on reset, maintained when exiting the Standby mode.
  * @note  To avoid any conflict at Standby and Shutdown modes exits, the corresponding
  *        PDy bit of PWR_PDCRx register is cleared unless it is reserved.
  * @note  Even if a PUy bit to set is reserved, the other PUy bits entered as input
stm32l4xx_hal_pwr_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 461 : 
  * @brief Disable GPIO pull-up state in Standby mode and Shutdown modes.
  * @note  Reset the relevant PUy bits of PWR_PUCRx register used to configure the I/O
  *        in pull-up state in Standby and Shutdown modes.
  * @note  Even if a PUy bit to reset is reserved, the other PUy bits entered as input
  *        parameter at the same time are reset.
  * @param  GPIO: Specifies the IO port. This parameter can be PWR_GPIO_A, ..., PWR_GPIO_H
  *          (or PWR_GPIO_I depending on the devices) to select the GPIO peripheral.
  * @param  GPIONumber: Specify the I/O pins numbers.
stm32l4xx_hal_pwr_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 470 : 
  *         PWR_GPIO_BIT_0, ..., PWR_GPIO_BIT_15 (except for the port where less
  *         I/O pins are available) or the logical OR of several of them to reset
  *         several bits for a given port in a single API call.
  * @retval HAL Status
  */
stm32l4xx_hal_pwr_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 537 : 
  * @note  The configuration is lost when exiting the Shutdown mode due to the
  *        power-on reset, maintained when exiting the Standby mode.
  * @note  To avoid any conflict at Standby and Shutdown modes exits, the corresponding
  *        PUy bit of PWR_PUCRx register is cleared unless it is reserved.
  * @note  Even if a PDy bit to set is reserved, the other PDy bits entered as input
stm32l4xx_hal_pwr_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 621 : 
  * @brief Disable GPIO pull-down state in Standby and Shutdown modes.
  * @note  Reset the relevant PDy bits of PWR_PDCRx register used to configure the I/O
  *        in pull-down state in Standby and Shutdown modes.
  * @note  Even if a PDy bit to reset is reserved, the other PDy bits entered as input
  *        parameter at the same time are reset.
  * @param  GPIO: Specifies the IO port. This parameter can be PWR_GPIO_A..PWR_GPIO_H
  *         (or PWR_GPIO_I depending on the devices) to select the GPIO peripheral.
  * @param  GPIONumber: Specify the I/O pins numbers.
stm32l4xx_hal_pwr_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 630 : 
  *         PWR_GPIO_BIT_0, ..., PWR_GPIO_BIT_15 (except for the port where less
  *         I/O pins are available) or the logical OR of several of them to reset
  *         several bits for a given port in a single API call.
  * @retval HAL Status
  */
stm32l4xx_hal_pwr_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 737 : 
  * @brief Disable SRAM2 content retention in Standby mode.
  * @note  When RRS bit is reset, SRAM2 is powered off in Standby mode
  *        and its content is lost.
  * @retval None
  */
stm32l4xx_hal_pwr_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 812 : 
  * @brief Disable SRAM3 content retention in Stop 2 mode.
  * @note  When RRSTP bit is reset, SRAM3 is powered off in Stop 2 mode
  *        and its content is lost.
  * @retval None
  */
stm32l4xx_hal_pwr_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 1109 : 
  * @note  Before HAL_PWREx_DisableLowPowerRunMode() completion, the function checks that
  *        REGLPF has been properly reset (otherwise, HAL_PWREx_DisableLowPowerRunMode
  *        returns HAL_TIMEOUT status). The system clock frequency can then be
  *        increased above 2 MHz.
  * @retval HAL Status
HAL_PWREx_DisableLowPowerRunMode in stm32l4xx_hal_pwr_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Wait until REGLPF is reset */
  wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
  while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF)) && (wait_loop_index != 0U))
  {
HAL_PWREx_EnterSTOP0Mode in stm32l4xx_hal_pwr_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
}

HAL_PWREx_EnterSTOP1Mode in stm32l4xx_hal_pwr_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
}

HAL_PWREx_EnterSTOP2Mode in stm32l4xx_hal_pwr_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
}

stm32l4xx_hal_qspi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 26 : 
        (++) Enable QuadSPI clock interface with __HAL_RCC_QSPI_CLK_ENABLE().
        (++) Reset QuadSPI Peripheral with __HAL_RCC_QSPI_FORCE_RESET() and __HAL_RCC_QSPI_RELEASE_RESET().
        (++) Enable the clocks for the QuadSPI GPIOS with __HAL_RCC_GPIOx_CLK_ENABLE().
        (++) Configure these QuadSPI pins in alternate mode using HAL_GPIO_Init().
        (++) If interrupt mode is used, enable and configure QuadSPI global
stm32l4xx_hal_qspi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 152 : 

      Use function @ref HAL_QSPI_UnRegisterCallback() to reset a callback to the default
      weak (surcharged) function. It allows to reset following callbacks:
        (+) ErrorCallback : callback when error occurs.
        (+) AbortCpltCallback : callback when abort is completed.
        (+) FifoThresholdCallback : callback when the fifo threshold is reached.
stm32l4xx_hal_qspi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 168 : 

      By default, after the @ref HAL_QSPI_Init and if the state is HAL_QSPI_STATE_RESET
      all callbacks are reset to the corresponding legacy weak (surcharged) functions.
      Exception done for MspInit and MspDeInit callbacks that are respectively
      reset to the legacy weak (surcharged) functions in the @ref HAL_QSPI_Init
      and @ref  HAL_QSPI_DeInit only when these callbacks are null (not registered beforehand).
      If not, MspInit or MspDeInit are not null, the @ref HAL_QSPI_Init and @ref HAL_QSPI_DeInit
      keep and use the user MspInit/MspDeInit callbacks (registered beforehand)
stm32l4xx_hal_qspi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 178 : 
      Exception done for MspInit/MspDeInit callbacks that can be registered/unregistered
      in READY or RESET state, thus registered (user) MspInit/DeInit callbacks can be used
      during the Init/DeInit.
      In that case first register the MspInit/MspDeInit user callbacks
      using @ref HAL_QSPI_RegisterCallback before calling @ref HAL_QSPI_DeInit
HAL_QSPI_Init in stm32l4xx_hal_qspi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if(hqspi->State == HAL_QSPI_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hqspi->Lock = HAL_UNLOCKED;
HAL_QSPI_Init in stm32l4xx_hal_qspi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
    /* Reset Callback pointers in HAL_QSPI_STATE_RESET only */
    hqspi->ErrorCallback         = HAL_QSPI_ErrorCallback;
    hqspi->AbortCpltCallback     = HAL_QSPI_AbortCpltCallback;
    hqspi->FifoThresholdCallback = HAL_QSPI_FifoThresholdCallback;
HAL_QSPI_Init in stm32l4xx_hal_qspi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Wait till BUSY flag reset */
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);

  if(status == HAL_OK)
  {
HAL_QSPI_DeInit in stm32l4xx_hal_qspi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Initialize the QSPI state */
  hqspi->State = HAL_QSPI_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(hqspi);
HAL_QSPI_IRQHandler in stm32l4xx_hal_qspi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      /* Transmission process */
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
      {
        if (hqspi->TxXferCount > 0U)
        {
HAL_QSPI_IRQHandler in stm32l4xx_hal_qspi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      /* Receiving Process */
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
      {
        if (hqspi->RxXferCount > 0U)
        {
HAL_QSPI_IRQHandler in stm32l4xx_hal_qspi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    {
      /* Reset functional mode configuration to indirect write mode by default */
      CLEAR_BIT(hqspi->Instance->CCR, QUADSPI_CCR_FMODE);

      /* Change state of QSPI */
HAL_QSPI_Command in stm32l4xx_hal_qspi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);

    if (status == HAL_OK)
    {
HAL_QSPI_Command_IT in stm32l4xx_hal_qspi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);

    if (status == HAL_OK)
    {
HAL_QSPI_AutoPolling in stm32l4xx_hal_qspi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);

    if (status == HAL_OK)
    {
HAL_QSPI_AutoPolling_IT in stm32l4xx_hal_qspi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);

    if (status == HAL_OK)
    {
HAL_QSPI_MemoryMapped in stm32l4xx_hal_qspi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);

    if (status == HAL_OK)
    {
HAL_QSPI_RegisterCallback in stm32l4xx_hal_qspi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (hqspi->State == HAL_QSPI_STATE_RESET)
  {
    switch (CallbackId)
    {
HAL_QSPI_UnRegisterCallback in stm32l4xx_hal_qspi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (hqspi->State == HAL_QSPI_STATE_RESET)
  {
    switch (CallbackId)
    {
HAL_QSPI_Abort in stm32l4xx_hal_qspi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

      /* Wait until BUSY flag is reset */
      status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
    }

    if (status == HAL_OK)
    {
      /* Reset functional mode configuration to indirect write mode by default */
      CLEAR_BIT(hqspi->Instance->CCR, QUADSPI_CCR_FMODE);

      /* Update state */
stm32l4xx_hal_qspi.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 80 : 
{
  HAL_QSPI_STATE_RESET             = 0x00U,    /*!< Peripheral not initialized                            */
  HAL_QSPI_STATE_READY             = 0x01U,    /*!< Peripheral initialized and ready for use              */
  HAL_QSPI_STATE_BUSY              = 0x02U,    /*!< Peripheral in indirect mode and busy                  */
  HAL_QSPI_STATE_BUSY_INDIRECT_TX  = 0x12U,    /*!< Peripheral in indirect mode with transmission ongoing */
stm32l4xx_hal_qspi.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 465 : 
  */
/** @brief Reset QSPI handle state.
  * @param  __HANDLE__ : QSPI handle.
  * @retval None
  */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
#define __HAL_QSPI_RESET_HANDLE_STATE(__HANDLE__)           do {                                              \
                                                                  (__HANDLE__)->State = HAL_QSPI_STATE_RESET; \
                                                                  (__HANDLE__)->MspInitCallback = NULL;       \
                                                                  (__HANDLE__)->MspDeInitCallback = NULL;     \
                                                               } while(0)
#else
#define __HAL_QSPI_RESET_HANDLE_STATE(__HANDLE__)           ((__HANDLE__)->State = HAL_QSPI_STATE_RESET)
#endif

/** @brief  Enable the QSPI peripheral.
stm32l4xx_hal_qspi.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 544 : 
  */
#define __HAL_QSPI_GET_FLAG(__HANDLE__, __FLAG__)           ((READ_BIT((__HANDLE__)->Instance->SR, (__FLAG__)) != 0U) ? SET : RESET)

/** @brief  Clears the specified QSPI's flag status.
  * @param  __HANDLE__ : specifies the QSPI Handle.
stm32l4xx_hal_rcc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 6 : 
  *          This file provides firmware functions to manage the following
  *          functionalities of the Reset and Clock Control (RCC) peripheral:
  *           + Initialization and de-initialization functions
  *           + Peripheral Control functions
  *
stm32l4xx_hal_rcc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 15 : 
    [..]
      After reset the device is running from Multiple Speed Internal oscillator
      (4 MHz) with Flash 0 wait state. Flash prefetch buffer, D-Cache
      and I-Cache are disabled, and all peripherals are off except internal
      SRAM, Flash and JTAG.
stm32l4xx_hal_rcc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 27 : 
    [..]
      Once the device started from reset, the user application has to:
      (+) Configure the clock source to be used to drive the System clock
          (if the application needs higher frequency/performance)
      (+) Configure the System clock frequency and Flash settings
stm32l4xx_hal_rcc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 250 : 
/**
  * @brief  Reset the RCC clock configuration to the default reset state.
  * @note   The default reset state of the clock configuration is given below:
  *            - MSI ON and used as system clock source
  *            - HSE, HSI, PLL, PLLSAI1 and PLLSAI2 OFF
  *            - AHB, APB1 and APB2 prescalers set to 1.
stm32l4xx_hal_rcc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 257 : 
  *            - All interrupts disabled
  *            - All interrupt and reset flags cleared
  * @note   This function does not modify the configuration of the
  *            - Peripheral clock sources
  *            - LSI, LSE and RTC clocks (Backup domain)
HAL_RCC_DeInit in stm32l4xx_hal_rcc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset to default System clock */
  /* Set MSION bit */
  SET_BIT(RCC->CR, RCC_CR_MSION);

HAL_RCC_DeInit in stm32l4xx_hal_rcc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset CFGR register (MSI is selected as system clock source) */
  CLEAR_REG(RCC->CFGR);

  /* Update the SystemCoreClock global variable for MSI as system clock source */
HAL_RCC_DeInit in stm32l4xx_hal_rcc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset HSION, HSIKERON, HSIASFS, HSEON, HSECSSON, PLLON, PLLSAIxON bits */
#if defined(RCC_PLLSAI2_SUPPORT)

  CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSION | RCC_CR_HSIKERON| RCC_CR_HSIASFS | RCC_CR_PLLON | RCC_CR_PLLSAI1ON | RCC_CR_PLLSAI2ON);
HAL_RCC_DeInit in stm32l4xx_hal_rcc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Insure PLLRDY, PLLSAI1RDY and PLLSAI2RDY (if present) are reset */
  /* Get start tick */
  tickstart = HAL_GetTick();

HAL_RCC_DeInit in stm32l4xx_hal_rcc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset PLLCFGR register */
  CLEAR_REG(RCC->PLLCFGR);
  SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN_4 );

HAL_RCC_DeInit in stm32l4xx_hal_rcc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset PLLSAI1CFGR register */
  CLEAR_REG(RCC->PLLSAI1CFGR);
  SET_BIT(RCC->PLLSAI1CFGR,  RCC_PLLSAI1CFGR_PLLSAI1N_4 );

HAL_RCC_DeInit in stm32l4xx_hal_rcc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset PLLSAI2CFGR register */
  CLEAR_REG(RCC->PLLSAI2CFGR);
  SET_BIT(RCC->PLLSAI2CFGR,  RCC_PLLSAI2CFGR_PLLSAI2N_4 );

HAL_RCC_DeInit in stm32l4xx_hal_rcc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset HSEBYP bit */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);

  /* Disable all interrupts */
HAL_RCC_DeInit in stm32l4xx_hal_rcc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Clear all reset flags */
  SET_BIT(RCC->CSR, RCC_CSR_RMVF);

  return HAL_OK;
HAL_RCC_OscConfig in stm32l4xx_hal_rcc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    FlagStatus       pwrclkchanged = RESET;

    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
stm32l4xx_hal_rcc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 1034 : 
  * @note   The MSI is used by default as system clock source after
  *         startup from Reset, wake-up from STANDBY mode. After restart from Reset,
  *         the MSI frequency is set to its default value 4 MHz.
  *
  * @note   The HSI can be selected as system clock source after
stm32l4xx_hal_rcc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 1660 : 
  *         the Cortex-M4 NMI (Non-Maskable Interrupt) exception vector.
  * @note   The Clock Security System can only be cleared by reset.
  * @retval None
  */
void HAL_RCC_EnableCSS(void)
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 583 : 
#define RCC_FLAG_LSIRDY                ((CSR_REG_INDEX << 5U) | RCC_CSR_LSIRDY_Pos)    /*!< LSI Ready flag */
#define RCC_FLAG_FWRST                 ((CSR_REG_INDEX << 5U) | RCC_CSR_FWRSTF_Pos)    /*!< Firewall reset flag */
#define RCC_FLAG_OBLRST                ((CSR_REG_INDEX << 5U) | RCC_CSR_OBLRSTF_Pos)   /*!< Option Byte Loader reset flag */
#define RCC_FLAG_PINRST                ((CSR_REG_INDEX << 5U) | RCC_CSR_PINRSTF_Pos)   /*!< PIN reset flag */
#define RCC_FLAG_BORRST                ((CSR_REG_INDEX << 5U) | RCC_CSR_BORRSTF_Pos)   /*!< BOR reset flag */
#define RCC_FLAG_SFTRST                ((CSR_REG_INDEX << 5U) | RCC_CSR_SFTRSTF_Pos)   /*!< Software Reset flag */
#define RCC_FLAG_IWDGRST               ((CSR_REG_INDEX << 5U) | RCC_CSR_IWDGRSTF_Pos)  /*!< Independent Watchdog reset flag */
#define RCC_FLAG_WWDGRST               ((CSR_REG_INDEX << 5U) | RCC_CSR_WWDGRSTF_Pos)  /*!< Window watchdog reset flag */
#define RCC_FLAG_LPWRRST               ((CSR_REG_INDEX << 5U) | RCC_CSR_LPWRRSTF_Pos)  /*!< Low-Power reset flag */

#if defined(RCC_HSI48_SUPPORT)
/* Flags in the CRRCR register */
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 632 : 
  * @brief  Enable or disable the AHB1 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  * @{
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 737 : 
  * @brief  Enable or disable the AHB2 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  * @{
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 964 : 
  * @brief  Enable or disable the AHB3 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  * @{
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1032 : 
  * @brief  Enable or disable the APB1 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  * @{
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1419 : 
  * @brief  Enable or disable the APB2 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  * @{
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1613 : 
  * @brief  Check whether the AHB1 peripheral clock is enabled or not.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  * @{
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1670 : 
  * @brief  Check whether the AHB2 peripheral clock is enabled or not.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  * @{
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1779 : 
  * @brief  Check whether the AHB3 peripheral clock is enabled or not.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  * @{
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1807 : 
  * @brief  Check whether the APB1 peripheral clock is enabled or not.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  * @{
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 2016 : 
  * @brief  Check whether the APB2 peripheral clock is enabled or not.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  * @{
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 2117 : 

/** @defgroup RCC_AHB1_Force_Release_Reset AHB1 Peripheral Force Release Reset
  * @brief  Force or release AHB1 peripheral reset.
  * @{
  */
#define __HAL_RCC_AHB1_FORCE_RESET()           WRITE_REG(RCC->AHB1RSTR, 0xFFFFFFFFU)

#define __HAL_RCC_DMA1_FORCE_RESET()           SET_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_DMA1RST)

#define __HAL_RCC_DMA2_FORCE_RESET()           SET_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_DMA2RST)

#if defined(DMAMUX1)
#define __HAL_RCC_DMAMUX1_FORCE_RESET()        SET_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_DMAMUX1RST)
#endif /* DMAMUX1 */

#define __HAL_RCC_FLASH_FORCE_RESET()          SET_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_FLASHRST)

#define __HAL_RCC_CRC_FORCE_RESET()            SET_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_CRCRST)

#define __HAL_RCC_TSC_FORCE_RESET()            SET_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_TSCRST)

#if defined(DMA2D)
#define __HAL_RCC_DMA2D_FORCE_RESET()          SET_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_DMA2DRST)
#endif /* DMA2D */

#if defined(GFXMMU)
#define __HAL_RCC_GFXMMU_FORCE_RESET()         SET_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_GFXMMURST)
#endif /* GFXMMU */


#define __HAL_RCC_AHB1_RELEASE_RESET()         WRITE_REG(RCC->AHB1RSTR, 0x00000000U)

#define __HAL_RCC_DMA1_RELEASE_RESET()         CLEAR_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_DMA1RST)

#define __HAL_RCC_DMA2_RELEASE_RESET()         CLEAR_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_DMA2RST)

#if defined(DMAMUX1)
#define __HAL_RCC_DMAMUX1_RELEASE_RESET()      CLEAR_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_DMAMUX1RST)
#endif /* DMAMUX1 */

#define __HAL_RCC_FLASH_RELEASE_RESET()        CLEAR_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_FLASHRST)

#define __HAL_RCC_CRC_RELEASE_RESET()          CLEAR_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_CRCRST)

#define __HAL_RCC_TSC_RELEASE_RESET()          CLEAR_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_TSCRST)

#if defined(DMA2D)
#define __HAL_RCC_DMA2D_RELEASE_RESET()        CLEAR_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_DMA2DRST)
#endif /* DMA2D */

#if defined(GFXMMU)
#define __HAL_RCC_GFXMMU_RELEASE_RESET()       CLEAR_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_GFXMMURST)
#endif /* GFXMMU */

/**
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 2174 : 

/** @defgroup RCC_AHB2_Force_Release_Reset AHB2 Peripheral Force Release Reset
  * @brief  Force or release AHB2 peripheral reset.
  * @{
  */
#define __HAL_RCC_AHB2_FORCE_RESET()           WRITE_REG(RCC->AHB2RSTR, 0xFFFFFFFFU)

#define __HAL_RCC_GPIOA_FORCE_RESET()          SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOARST)

#define __HAL_RCC_GPIOB_FORCE_RESET()          SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOBRST)

#define __HAL_RCC_GPIOC_FORCE_RESET()          SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOCRST)

#if defined(GPIOD)
#define __HAL_RCC_GPIOD_FORCE_RESET()          SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIODRST)
#endif /* GPIOD */

#if defined(GPIOE)
#define __HAL_RCC_GPIOE_FORCE_RESET()          SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOERST)
#endif /* GPIOE */

#if defined(GPIOF)
#define __HAL_RCC_GPIOF_FORCE_RESET()          SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOFRST)
#endif /* GPIOF */

#if defined(GPIOG)
#define __HAL_RCC_GPIOG_FORCE_RESET()          SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOGRST)
#endif /* GPIOG */

#define __HAL_RCC_GPIOH_FORCE_RESET()          SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOHRST)

#if defined(GPIOI)
#define __HAL_RCC_GPIOI_FORCE_RESET()          SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOIRST)
#endif /* GPIOI */

#if defined(USB_OTG_FS)
#define __HAL_RCC_USB_OTG_FS_FORCE_RESET()     SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_OTGFSRST)
#endif /* USB_OTG_FS */

#define __HAL_RCC_ADC_FORCE_RESET()            SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_ADCRST)

#if defined(DCMI)
#define __HAL_RCC_DCMI_FORCE_RESET()           SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_DCMIRST)
#endif /* DCMI */

#if defined(AES)
#define __HAL_RCC_AES_FORCE_RESET()            SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_AESRST)
#endif /* AES */

#if defined(HASH)
#define __HAL_RCC_HASH_FORCE_RESET()           SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_HASHRST)
#endif /* HASH */

#define __HAL_RCC_RNG_FORCE_RESET()            SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_RNGRST)

#if defined(OCTOSPIM)
#define __HAL_RCC_OSPIM_FORCE_RESET()          SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_OSPIMRST)
#endif /* OCTOSPIM */

#if defined(SDMMC1) && defined(RCC_AHB2RSTR_SDMMC1RST)
#define __HAL_RCC_SDMMC1_FORCE_RESET()         SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_SDMMC1RST)
#endif /* SDMMC1 && RCC_AHB2RSTR_SDMMC1RST */


#define __HAL_RCC_AHB2_RELEASE_RESET()         WRITE_REG(RCC->AHB2RSTR, 0x00000000U)

#define __HAL_RCC_GPIOA_RELEASE_RESET()        CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOARST)

#define __HAL_RCC_GPIOB_RELEASE_RESET()        CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOBRST)

#define __HAL_RCC_GPIOC_RELEASE_RESET()        CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOCRST)

#if defined(GPIOD)
#define __HAL_RCC_GPIOD_RELEASE_RESET()        CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIODRST)
#endif /* GPIOD */

#if defined(GPIOE)
#define __HAL_RCC_GPIOE_RELEASE_RESET()        CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOERST)
#endif /* GPIOE */

#if defined(GPIOF)
#define __HAL_RCC_GPIOF_RELEASE_RESET()        CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOFRST)
#endif /* GPIOF */

#if defined(GPIOG)
#define __HAL_RCC_GPIOG_RELEASE_RESET()        CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOGRST)
#endif /* GPIOG */

#define __HAL_RCC_GPIOH_RELEASE_RESET()        CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOHRST)

#if defined(GPIOI)
#define __HAL_RCC_GPIOI_RELEASE_RESET()        CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOIRST)
#endif /* GPIOI */

#if defined(USB_OTG_FS)
#define __HAL_RCC_USB_OTG_FS_RELEASE_RESET()   CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_OTGFSRST)
#endif /* USB_OTG_FS */

#define __HAL_RCC_ADC_RELEASE_RESET()          CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_ADCRST)

#if defined(DCMI)
#define __HAL_RCC_DCMI_RELEASE_RESET()         CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_DCMIRST)
#endif /* DCMI */

#if defined(AES)
#define __HAL_RCC_AES_RELEASE_RESET()          CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_AESRST)
#endif /* AES */

#if defined(HASH)
#define __HAL_RCC_HASH_RELEASE_RESET()         CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_HASHRST)
#endif /* HASH */

#define __HAL_RCC_RNG_RELEASE_RESET()          CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_RNGRST)

#if defined(OCTOSPIM)
#define __HAL_RCC_OSPIM_RELEASE_RESET()        CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_OSPIMRST)
#endif /* OCTOSPIM */

#if defined(SDMMC1) && defined(RCC_AHB2RSTR_SDMMC1RST)
#define __HAL_RCC_SDMMC1_RELEASE_RESET()       CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_SDMMC1RST)
#endif /* SDMMC1 && RCC_AHB2RSTR_SDMMC1RST */

/**
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 2299 : 

/** @defgroup RCC_AHB3_Force_Release_Reset AHB3 Peripheral Force Release Reset
  * @brief  Force or release AHB3 peripheral reset.
  * @{
  */
#define __HAL_RCC_AHB3_FORCE_RESET()           WRITE_REG(RCC->AHB3RSTR, 0xFFFFFFFFU)

#if defined(FMC_BANK1)
#define __HAL_RCC_FMC_FORCE_RESET()            SET_BIT(RCC->AHB3RSTR, RCC_AHB3RSTR_FMCRST)
#endif /* FMC_BANK1 */

#if defined(QUADSPI)
#define __HAL_RCC_QSPI_FORCE_RESET()           SET_BIT(RCC->AHB3RSTR, RCC_AHB3RSTR_QSPIRST)
#endif /* QUADSPI */

#if defined(OCTOSPI1)
#define __HAL_RCC_OSPI1_FORCE_RESET()          SET_BIT(RCC->AHB3RSTR, RCC_AHB3RSTR_OSPI1RST)
#endif /* OCTOSPI1 */

#if defined(OCTOSPI2)
#define __HAL_RCC_OSPI2_FORCE_RESET()          SET_BIT(RCC->AHB3RSTR, RCC_AHB3RSTR_OSPI2RST)
#endif /* OCTOSPI2 */

#define __HAL_RCC_AHB3_RELEASE_RESET()         WRITE_REG(RCC->AHB3RSTR, 0x00000000U)

#if defined(FMC_BANK1)
#define __HAL_RCC_FMC_RELEASE_RESET()          CLEAR_BIT(RCC->AHB3RSTR, RCC_AHB3RSTR_FMCRST)
#endif /* FMC_BANK1 */

#if defined(QUADSPI)
#define __HAL_RCC_QSPI_RELEASE_RESET()         CLEAR_BIT(RCC->AHB3RSTR, RCC_AHB3RSTR_QSPIRST)
#endif /* QUADSPI */

#if defined(OCTOSPI1)
#define __HAL_RCC_OSPI1_RELEASE_RESET()        CLEAR_BIT(RCC->AHB3RSTR, RCC_AHB3RSTR_OSPI1RST)
#endif /* OCTOSPI1 */

#if defined(OCTOSPI2)
#define __HAL_RCC_OSPI2_RELEASE_RESET()        CLEAR_BIT(RCC->AHB3RSTR, RCC_AHB3RSTR_OSPI2RST)
#endif /* OCTOSPI2 */

/**
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 2343 : 

/** @defgroup RCC_APB1_Force_Release_Reset APB1 Peripheral Force Release Reset
  * @brief  Force or release APB1 peripheral reset.
  * @{
  */
#define __HAL_RCC_APB1_FORCE_RESET()           WRITE_REG(RCC->APB1RSTR1, 0xFFFFFFFFU)

#define __HAL_RCC_TIM2_FORCE_RESET()           SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_TIM2RST)

#if defined(TIM3)
#define __HAL_RCC_TIM3_FORCE_RESET()           SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_TIM3RST)
#endif /* TIM3 */

#if defined(TIM4)
#define __HAL_RCC_TIM4_FORCE_RESET()           SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_TIM4RST)
#endif /* TIM4 */

#if defined(TIM5)
#define __HAL_RCC_TIM5_FORCE_RESET()           SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_TIM5RST)
#endif /* TIM5 */

#define __HAL_RCC_TIM6_FORCE_RESET()           SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_TIM6RST)

#if defined(TIM7)
#define __HAL_RCC_TIM7_FORCE_RESET()           SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_TIM7RST)
#endif /* TIM7 */

#if defined(LCD)
#define __HAL_RCC_LCD_FORCE_RESET()            SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_LCDRST)
#endif /* LCD */

#if defined(SPI2)
#define __HAL_RCC_SPI2_FORCE_RESET()           SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_SPI2RST)
#endif /* SPI2 */

#if defined(SPI3)
#define __HAL_RCC_SPI3_FORCE_RESET()           SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_SPI3RST)
#endif /* SPI3 */

#define __HAL_RCC_USART2_FORCE_RESET()         SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_USART2RST)

#if defined(USART3)
#define __HAL_RCC_USART3_FORCE_RESET()         SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_USART3RST)
#endif /* USART3 */

#if defined(UART4)
#define __HAL_RCC_UART4_FORCE_RESET()          SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_UART4RST)
#endif /* UART4 */

#if defined(UART5)
#define __HAL_RCC_UART5_FORCE_RESET()          SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_UART5RST)
#endif /* UART5 */

#define __HAL_RCC_I2C1_FORCE_RESET()           SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_I2C1RST)

#if defined(I2C2)
#define __HAL_RCC_I2C2_FORCE_RESET()           SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_I2C2RST)
#endif /* I2C2 */

#define __HAL_RCC_I2C3_FORCE_RESET()           SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_I2C3RST)

#if defined(I2C4)
#define __HAL_RCC_I2C4_FORCE_RESET()           SET_BIT(RCC->APB1RSTR2, RCC_APB1RSTR2_I2C4RST)
#endif /* I2C4 */

#if defined(CRS)
#define __HAL_RCC_CRS_FORCE_RESET()            SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_CRSRST)
#endif /* CRS */

#if defined(CAN1)
#define __HAL_RCC_CAN1_FORCE_RESET()           SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_CAN1RST)
#endif /* CAN1 */

#if defined(CAN2)
#define __HAL_RCC_CAN2_FORCE_RESET()           SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_CAN2RST)
#endif /* CAN2 */

#if defined(USB)
#define __HAL_RCC_USB_FORCE_RESET()            SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_USBFSRST)
#endif /* USB */

#define __HAL_RCC_PWR_FORCE_RESET()            SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_PWRRST)

#if defined(DAC1)
#define __HAL_RCC_DAC1_FORCE_RESET()           SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_DAC1RST)
#endif /* DAC1 */

#define __HAL_RCC_OPAMP_FORCE_RESET()          SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_OPAMPRST)

#define __HAL_RCC_LPTIM1_FORCE_RESET()         SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_LPTIM1RST)

#define __HAL_RCC_LPUART1_FORCE_RESET()        SET_BIT(RCC->APB1RSTR2, RCC_APB1RSTR2_LPUART1RST)

#if defined(SWPMI1)
#define __HAL_RCC_SWPMI1_FORCE_RESET()         SET_BIT(RCC->APB1RSTR2, RCC_APB1RSTR2_SWPMI1RST)
#endif /* SWPMI1 */

#define __HAL_RCC_LPTIM2_FORCE_RESET()         SET_BIT(RCC->APB1RSTR2, RCC_APB1RSTR2_LPTIM2RST)


#define __HAL_RCC_APB1_RELEASE_RESET()         WRITE_REG(RCC->APB1RSTR1, 0x00000000U)

#define __HAL_RCC_TIM2_RELEASE_RESET()         CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_TIM2RST)

#if defined(TIM3)
#define __HAL_RCC_TIM3_RELEASE_RESET()         CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_TIM3RST)
#endif /* TIM3 */

#if defined(TIM4)
#define __HAL_RCC_TIM4_RELEASE_RESET()         CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_TIM4RST)
#endif /* TIM4 */

#if defined(TIM5)
#define __HAL_RCC_TIM5_RELEASE_RESET()         CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_TIM5RST)
#endif /* TIM5 */

#define __HAL_RCC_TIM6_RELEASE_RESET()         CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_TIM6RST)

#if defined(TIM7)
#define __HAL_RCC_TIM7_RELEASE_RESET()         CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_TIM7RST)
#endif /* TIM7 */

#if defined(LCD)
#define __HAL_RCC_LCD_RELEASE_RESET()          CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_LCDRST)
#endif /* LCD */

#if defined(SPI2)
#define __HAL_RCC_SPI2_RELEASE_RESET()         CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_SPI2RST)
#endif /* SPI2 */

#if defined(SPI3)
#define __HAL_RCC_SPI3_RELEASE_RESET()         CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_SPI3RST)
#endif /* SPI3 */

#define __HAL_RCC_USART2_RELEASE_RESET()       CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_USART2RST)

#if defined(USART3)
#define __HAL_RCC_USART3_RELEASE_RESET()       CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_USART3RST)
#endif /* USART3 */

#if defined(UART4)
#define __HAL_RCC_UART4_RELEASE_RESET()        CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_UART4RST)
#endif /* UART4 */

#if defined(UART5)
#define __HAL_RCC_UART5_RELEASE_RESET()        CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_UART5RST)
#endif /* UART5 */

#define __HAL_RCC_I2C1_RELEASE_RESET()         CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_I2C1RST)

#if defined(I2C2)
#define __HAL_RCC_I2C2_RELEASE_RESET()         CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_I2C2RST)
#endif /* I2C2 */

#define __HAL_RCC_I2C3_RELEASE_RESET()         CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_I2C3RST)

#if defined(I2C4)
#define __HAL_RCC_I2C4_RELEASE_RESET()         CLEAR_BIT(RCC->APB1RSTR2, RCC_APB1RSTR2_I2C4RST)
#endif /* I2C4 */

#if defined(CRS)
#define __HAL_RCC_CRS_RELEASE_RESET()          CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_CRSRST)
#endif /* CRS */

#if defined(CAN1)
#define __HAL_RCC_CAN1_RELEASE_RESET()         CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_CAN1RST)
#endif /* CAN1 */

#if defined(CAN2)
#define __HAL_RCC_CAN2_RELEASE_RESET()         CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_CAN2RST)
#endif /* CAN2 */

#if defined(USB)
#define __HAL_RCC_USB_RELEASE_RESET()          CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_USBFSRST)
#endif /* USB */

#define __HAL_RCC_PWR_RELEASE_RESET()          CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_PWRRST)

#if defined(DAC1)
#define __HAL_RCC_DAC1_RELEASE_RESET()         CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_DAC1RST)
#endif /* DAC1 */

#define __HAL_RCC_OPAMP_RELEASE_RESET()        CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_OPAMPRST)

#define __HAL_RCC_LPTIM1_RELEASE_RESET()       CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_LPTIM1RST)

#define __HAL_RCC_LPUART1_RELEASE_RESET()      CLEAR_BIT(RCC->APB1RSTR2, RCC_APB1RSTR2_LPUART1RST)

#if defined(SWPMI1)
#define __HAL_RCC_SWPMI1_RELEASE_RESET()       CLEAR_BIT(RCC->APB1RSTR2, RCC_APB1RSTR2_SWPMI1RST)
#endif /* SWPMI1 */

#define __HAL_RCC_LPTIM2_RELEASE_RESET()       CLEAR_BIT(RCC->APB1RSTR2, RCC_APB1RSTR2_LPTIM2RST)

/**
  * @}
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 2540 : 

/** @defgroup RCC_APB2_Force_Release_Reset APB2 Peripheral Force Release Reset
  * @brief  Force or release APB2 peripheral reset.
  * @{
  */
#define __HAL_RCC_APB2_FORCE_RESET()           WRITE_REG(RCC->APB2RSTR, 0xFFFFFFFFU)

#define __HAL_RCC_SYSCFG_FORCE_RESET()         SET_BIT(RCC->APB2RSTR, RCC_APB2RSTR_SYSCFGRST)

#if defined(SDMMC1) && defined(RCC_APB2RSTR_SDMMC1RST)
#define __HAL_RCC_SDMMC1_FORCE_RESET()         SET_BIT(RCC->APB2RSTR, RCC_APB2RSTR_SDMMC1RST)
#endif /* SDMMC1 && RCC_APB2RSTR_SDMMC1RST */

#define __HAL_RCC_TIM1_FORCE_RESET()           SET_BIT(RCC->APB2RSTR, RCC_APB2RSTR_TIM1RST)

#define __HAL_RCC_SPI1_FORCE_RESET()           SET_BIT(RCC->APB2RSTR, RCC_APB2RSTR_SPI1RST)

#if defined(TIM8)
#define __HAL_RCC_TIM8_FORCE_RESET()           SET_BIT(RCC->APB2RSTR, RCC_APB2RSTR_TIM8RST)
#endif /* TIM8 */

#define __HAL_RCC_USART1_FORCE_RESET()         SET_BIT(RCC->APB2RSTR, RCC_APB2RSTR_USART1RST)

#define __HAL_RCC_TIM15_FORCE_RESET()          SET_BIT(RCC->APB2RSTR, RCC_APB2RSTR_TIM15RST)

#define __HAL_RCC_TIM16_FORCE_RESET()          SET_BIT(RCC->APB2RSTR, RCC_APB2RSTR_TIM16RST)

#if defined(TIM17)
#define __HAL_RCC_TIM17_FORCE_RESET()          SET_BIT(RCC->APB2RSTR, RCC_APB2RSTR_TIM17RST)
#endif /* TIM17 */

#if defined(SAI1)
#define __HAL_RCC_SAI1_FORCE_RESET()           SET_BIT(RCC->APB2RSTR, RCC_APB2RSTR_SAI1RST)
#endif /* SAI1 */

#if defined(SAI2)
#define __HAL_RCC_SAI2_FORCE_RESET()           SET_BIT(RCC->APB2RSTR, RCC_APB2RSTR_SAI2RST)
#endif /* SAI2 */

#if defined(DFSDM1_Filter0)
#define __HAL_RCC_DFSDM1_FORCE_RESET()         SET_BIT(RCC->APB2RSTR, RCC_APB2RSTR_DFSDM1RST)
#endif /* DFSDM1_Filter0 */

#if defined(LTDC)
#define __HAL_RCC_LTDC_FORCE_RESET()           SET_BIT(RCC->APB2RSTR, RCC_APB2RSTR_LTDCRST)
#endif /* LTDC */

#if defined(DSI)
#define __HAL_RCC_DSI_FORCE_RESET()            SET_BIT(RCC->APB2RSTR, RCC_APB2RSTR_DSIRST)
#endif /* DSI */


#define __HAL_RCC_APB2_RELEASE_RESET()         WRITE_REG(RCC->APB2RSTR, 0x00000000U)

#define __HAL_RCC_SYSCFG_RELEASE_RESET()       CLEAR_BIT(RCC->APB2RSTR, RCC_APB2RSTR_SYSCFGRST)

#if defined(SDMMC1) && defined(RCC_APB2RSTR_SDMMC1RST)
#define __HAL_RCC_SDMMC1_RELEASE_RESET()       CLEAR_BIT(RCC->APB2RSTR, RCC_APB2RSTR_SDMMC1RST)
#endif /* SDMMC1 && RCC_APB2RSTR_SDMMC1RST */

#define __HAL_RCC_TIM1_RELEASE_RESET()         CLEAR_BIT(RCC->APB2RSTR, RCC_APB2RSTR_TIM1RST)

#define __HAL_RCC_SPI1_RELEASE_RESET()         CLEAR_BIT(RCC->APB2RSTR, RCC_APB2RSTR_SPI1RST)

#if defined(TIM8)
#define __HAL_RCC_TIM8_RELEASE_RESET()         CLEAR_BIT(RCC->APB2RSTR, RCC_APB2RSTR_TIM8RST)
#endif /* TIM8 */

#define __HAL_RCC_USART1_RELEASE_RESET()       CLEAR_BIT(RCC->APB2RSTR, RCC_APB2RSTR_USART1RST)

#define __HAL_RCC_TIM15_RELEASE_RESET()        CLEAR_BIT(RCC->APB2RSTR, RCC_APB2RSTR_TIM15RST)

#define __HAL_RCC_TIM16_RELEASE_RESET()        CLEAR_BIT(RCC->APB2RSTR, RCC_APB2RSTR_TIM16RST)

#if defined(TIM17)
#define __HAL_RCC_TIM17_RELEASE_RESET()        CLEAR_BIT(RCC->APB2RSTR, RCC_APB2RSTR_TIM17RST)
#endif /* TIM17 */

#if defined(SAI1)
#define __HAL_RCC_SAI1_RELEASE_RESET()         CLEAR_BIT(RCC->APB2RSTR, RCC_APB2RSTR_SAI1RST)
#endif /* SAI1 */

#if defined(SAI2)
#define __HAL_RCC_SAI2_RELEASE_RESET()         CLEAR_BIT(RCC->APB2RSTR, RCC_APB2RSTR_SAI2RST)
#endif /* SAI2 */

#if defined(DFSDM1_Filter0)
#define __HAL_RCC_DFSDM1_RELEASE_RESET()       CLEAR_BIT(RCC->APB2RSTR, RCC_APB2RSTR_DFSDM1RST)
#endif /* DFSDM1_Filter0 */

#if defined(LTDC)
#define __HAL_RCC_LTDC_RELEASE_RESET()         CLEAR_BIT(RCC->APB2RSTR, RCC_APB2RSTR_LTDCRST)
#endif /* LTDC */

#if defined(DSI)
#define __HAL_RCC_DSI_RELEASE_RESET()          CLEAR_BIT(RCC->APB2RSTR, RCC_APB2RSTR_DSIRST)
#endif /* DSI */

/**
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 3756 : 

/** @defgroup RCC_Backup_Domain_Reset RCC Backup Domain Reset
  * @{
  */

/** @brief  Macros to force or release the Backup domain reset.
  * @note   This function resets the RTC peripheral (including the backup registers)
  *         and the RTC clock source selection in RCC_CSR register.
  * @note   The BKPSRAM is not affected by this reset.
  * @retval None
  */
#define __HAL_RCC_BACKUPRESET_FORCE()   SET_BIT(RCC->BDCR, RCC_BDCR_BDRST)
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 3780 : 
  * @note   As the RTC is in the Backup domain and write access is denied to
  *         this domain after reset, you have to enable write access using
  *         HAL_PWR_EnableBkUpAccess() function before to configure the RTC
  *         (to be done once after reset).
  * @note   These macros must be used after the RTC clock source was selected.
  * @retval None
  */
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 3797 : 
  *         It is used (enabled by hardware) as system clock source after startup
  *         from Reset, wakeup from STOP and STANDBY mode, or in case of failure
  *         of the HSE used directly or indirectly as system clock (if the Clock
  *         Security System CSS is enabled).
  * @note   HSI can not be stopped if it is used as system clock source. In this case,
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 3853 : 
  *           It is used (enabled by hardware) as system clock source after
  *           startup from Reset, wakeup from STOP and STANDBY mode, or in case
  *           of failure of the HSE used directly or indirectly as system clock
  *           (if the Clock Security System CSS is enabled).
  * @note     MSI can not be stopped if it is used as system clock source.
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 3885 : 
  * @brief  Macro configures the Internal Multi Speed oscillator (MSI) clock range in run mode
  * @note     After restart from Reset , the MSI clock is around 4 MHz.
  *           After stop the startup clock can be MSI (at any of its possible
  *           frequencies, the one that was used before entering stop mode) or HSI.
  *          After Standby its frequency can be selected between 4 possible values
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 3892 : 
  *          (MSIRDY=1).
  * @note    The MSI clock range after reset can be modified on the fly.
  * @param  __MSIRANGEVALUE__ specifies the MSI clock range.
  *         This parameter must be one of the following values:
  *            @arg @ref RCC_MSIRANGE_0  MSI clock is around 100 KHz
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 3901 : 
  *            @arg @ref RCC_MSIRANGE_5  MSI clock is around 2 MHz
  *            @arg @ref RCC_MSIRANGE_6  MSI clock is around 4 MHz (default after Reset)
  *            @arg @ref RCC_MSIRANGE_7  MSI clock is around 8 MHz
  *            @arg @ref RCC_MSIRANGE_8  MSI clock is around 16 MHz
  *            @arg @ref RCC_MSIRANGE_9  MSI clock is around 24 MHz
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 3922 : 
  *            @arg @ref RCC_MSIRANGE_5  MSI clock is around 2 MHz
  *            @arg @ref RCC_MSIRANGE_6  MSI clock is around 4 MHz (default after Reset)
  *            @arg @ref RCC_MSIRANGE_7  MSI clock is around 8 MHz
  * @retval None
  */
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 3938 : 
  *            @arg @ref RCC_MSIRANGE_5  MSI clock is around 2 MHz
  *            @arg @ref RCC_MSIRANGE_6  MSI clock is around 4 MHz (default after Reset)
  *            @arg @ref RCC_MSIRANGE_7  MSI clock is around 8 MHz
  *            @arg @ref RCC_MSIRANGE_8  MSI clock is around 16 MHz
  *            @arg @ref RCC_MSIRANGE_9  MSI clock is around 24 MHz
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 3975 : 
  * @note   The HSE is stopped by hardware when entering STOP and STANDBY modes.
  * @note   This function reset the CSSON bit, so if the clock security system(CSS)
  *         was previously enabled you have to enable it again after calling this
  *         function.
  * @param  __STATE__ specifies the new state of the HSE.
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 4010 : 
  * @note   As the LSE is in the Backup domain and write access is denied to
  *         this domain after reset, you have to enable write access using
  *         HAL_PWR_EnableBkUpAccess() function before to configure the LSE
  *         (to be done once after reset).
  * @note   After enabling the LSE (RCC_LSE_ON or RCC_LSE_BYPASS), the application
  *         software should wait on LSERDY flag to be set indicating that LSE clock
  *         is stable and can be used to clock the RTC.
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 4059 : 
  * @note   As the RTC clock configuration bits are in the Backup domain and write
  *         access is denied to this domain after reset, you have to enable write
  *         access using the Power Backup Access macro before to configure
  *         the RTC clock source (to be done once after reset).
  * @note   Once the RTC clock is configured it cannot be changed unless the
  *         Backup domain is reset using __HAL_RCC_BACKUPRESET_FORCE() macro, or by
  *         a Power On Reset (POR).
  *
  * @param  __RTC_CLKSOURCE__ specifies the RTC clock source.
  *         This parameter can be one of the following values:
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 4251 : 
  *            @arg @ref RCC_PLL_SYSCLK  This Clock is used to generate the high speed system clock (up to 80MHz)
  * @retval SET / RESET
  */
#define __HAL_RCC_GET_PLLCLKOUT_CONFIG(__PLLCLOCKOUT__)  READ_BIT(RCC->PLLCFGR, (__PLLCLOCKOUT__))

stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 4281 : 
  * @note   As the LSE is in the Backup domain and write access is denied to
  *         this domain after reset, you have to enable write access using
  *         HAL_PWR_EnableBkUpAccess() function before to configure the LSE
  *         (to be done once after reset).
  * @param  __LSEDRIVE__ specifies the new state of the LSE drive capability.
  *          This parameter can be one of the following values:
  *            @arg @ref RCC_LSEDRIVE_LOW  LSE oscillator low drive capability.
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 4430 : 

/** @brief Set RMVF bit to clear the reset flags.
  *        The reset flags are: RCC_FLAG_FWRRST, RCC_FLAG_OBLRST, RCC_FLAG_PINRST, RCC_FLAG_BORRST,
  *        RCC_FLAG_SFTRST, RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST and RCC_FLAG_LPWRRST.
  * @retval None
 */
#define __HAL_RCC_CLEAR_RESET_FLAGS() SET_BIT(RCC->CSR, RCC_CSR_RMVF)

/** @brief  Check whether the selected RCC flag is set or not.
  * @param  __FLAG__ specifies the flag to check.
stm32l4xx_hal_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 4455 : 
  *            @arg @ref RCC_FLAG_LSIRDY  LSI oscillator clock ready
  *            @arg @ref RCC_FLAG_BORRST  BOR reset
  *            @arg @ref RCC_FLAG_OBLRST  OBLRST reset
  *            @arg @ref RCC_FLAG_PINRST  Pin reset
  *            @arg @ref RCC_FLAG_FWRST  FIREWALL reset
  *            @arg @ref RCC_FLAG_SFTRST  Software reset
  *            @arg @ref RCC_FLAG_IWDGRST  Independent Watchdog reset
  *            @arg @ref RCC_FLAG_WWDGRST  Window Watchdog reset
  *            @arg @ref RCC_FLAG_LPWRRST  Low Power reset
  * @retval The new state of __FLAG__ (TRUE or FALSE).
  */
#if defined(RCC_HSI48_SUPPORT)
stm32l4xx_hal_rcc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 104 : 
    (@) Important note: Care must be taken when HAL_RCCEx_PeriphCLKConfig() is used to
        select the RTC clock source; in this case the Backup domain will be reset in
        order to modify the RTC Clock source, as consequence RTC registers (including
        the backup registers) are set to their reset values.

@endverbatim
  * @{
HAL_RCCEx_PeriphCLKConfig in stm32l4xx_hal_rcc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    FlagStatus       pwrclkchanged = RESET;

    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
HAL_RCCEx_PeriphCLKConfig in stm32l4xx_hal_rcc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified from default */
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);

      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
        __HAL_RCC_BACKUPRESET_RELEASE();
        /* Restore the Content of BDCR register */
HAL_RCCEx_PeriphCLKConfig in stm32l4xx_hal_rcc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
      {
        /* Get Start Tick*/
HAL_RCCEx_DisablePLLSAI1 in stm32l4xx_hal_rcc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset PLL source to save power if no PLLs on */
#if defined(RCC_PLLSAI2_SUPPORT)
  if(READ_BIT(RCC->CR, (RCC_CR_PLLRDY | RCC_CR_PLLSAI2RDY)) == 0U)
  {
HAL_RCCEx_DisablePLLSAI2 in stm32l4xx_hal_rcc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset PLL source to save power if no PLLs on */
  if(READ_BIT(RCC->CR, (RCC_CR_PLLRDY | RCC_CR_PLLSAI1RDY)) == 0U)
  {
    MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
stm32l4xx_hal_rcc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 2314 : 
  *            @arg @ref RCC_MSIRANGE_5  Range 5 around 2 MHz
  *            @arg @ref RCC_MSIRANGE_6  Range 6 around 4 MHz (reset value)
  *            @arg @ref RCC_MSIRANGE_7  Range 7 around 8 MHz
  * @retval None
  */
HAL_RCCEx_EnableLSCO in stm32l4xx_hal_rcc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  GPIO_InitTypeDef GPIO_InitStruct;
  FlagStatus       pwrclkchanged = RESET;
  FlagStatus       backupchanged = RESET;

  /* Check the parameters */
  assert_param(IS_RCC_LSCOSOURCE(LSCOSource));
HAL_RCCEx_DisableLSCO in stm32l4xx_hal_rcc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
{
  FlagStatus       pwrclkchanged = RESET;
  FlagStatus       backupchanged = RESET;

  /* Update LSCOEN bit in Backup Domain control register */
  if(__HAL_RCC_PWR_IS_CLK_DISABLED())
stm32l4xx_hal_rcc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 2496 : 
  * @brief  Disable the PLL-mode of the MSI.
  * @note   PLL-mode of the MSI is automatically reset when LSE oscillator is disabled.
  * @retval None
  */
void HAL_RCCEx_DisableMSIPLLMode(void)
stm32l4xx_hal_rcc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 2531 : 
          (##) Call function HAL_RCCEx_CRSConfig which
              (+++) Resets CRS registers to their default values.
              (+++) Configures CRS registers with synchronization configuration
              (+++) Enables automatic calibration and frequency error counter feature
           Note: When using USB LPM (Link Power Management) and the device is in Sleep mode, the
HAL_RCCEx_CRSConfig in stm32l4xx_hal_rcc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Before configuration, reset CRS registers to their default values*/
  __HAL_RCC_CRS_FORCE_RESET();
  __HAL_RCC_CRS_RELEASE_RESET();

  /* Set the SYNCDIV[2:0] bits according to Prescaler value */
  /* Set the SYNCSRC[1:0] bits according to Source value */
stm32l4xx_hal_rcc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 797 : 
  */
#define RCC_CRS_RELOADVALUE_DEFAULT    0x0000BB7FU   /*!< The reset value of the RELOAD field corresponds
                                                          to a target frequency of 48 MHz and a synchronization signal frequency of 1 kHz (SOF signal from USB). */
/**
  * @}
stm32l4xx_hal_rcc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1097 : 
  *            @arg @ref RCC_PLLSAI1_ADC1CLK  Clock used to clock ADC peripheral.
  * @retval SET / RESET
  */
#define __HAL_RCC_GET_PLLSAI1CLKOUT_CONFIG(__PLLSAI1_CLOCKOUT__)  READ_BIT(RCC->PLLSAI1CFGR, (__PLLSAI1_CLOCKOUT__))

stm32l4xx_hal_rcc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1358 : 
  @endif
  * @retval SET / RESET
  */
#define __HAL_RCC_GET_PLLSAI2CLKOUT_CONFIG(__PLLSAI2_CLOCKOUT__)  READ_BIT(RCC->PLLSAI2CFGR, (__PLLSAI2_CLOCKOUT__))

stm32l4xx_hal_rcc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 2252 : 
  *              @arg @ref RCC_CRS_IT_ESYNC  Expected SYNC interrupt
  * @retval The new state of __INTERRUPT__ (SET or RESET).
  */
#define __HAL_RCC_CRS_GET_IT_SOURCE(__INTERRUPT__)  ((READ_BIT(CRS->CR, (__INTERRUPT__)) != 0U) ? SET : RESET)

/** @brief  Clear the CRS interrupt pending bits
  * @param  __INTERRUPT__ specifies the interrupt pending bit to clear.
stm32l4xx_hal_rng.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 42 : 
    [..]
    Use function @ref HAL_RNG_UnRegisterCallback() to reset a callback to the default
    weak (surcharged) function.
    @ref HAL_RNG_UnRegisterCallback() takes as parameters the HAL peripheral handle,
    and the Callback ID.
    This function allows to reset following callbacks:
    (+) ErrorCallback             : RNG Error Callback.
    (+) MspInitCallback           : RNG MspInit.
    (+) MspDeInitCallback         : RNG MspDeInit.
stm32l4xx_hal_rng.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 56 : 
    [..]
    By default, after the @ref HAL_RNG_Init() and when the state is HAL_RNG_STATE_RESET
    all callbacks are set to the corresponding weak (surcharged) functions:
    example @ref HAL_RNG_ErrorCallback().
    Exception done for MspInit and MspDeInit functions that are respectively
    reset to the legacy weak (surcharged) functions in the @ref HAL_RNG_Init()
    and @ref HAL_RNG_DeInit() only when these callbacks are null (not registered beforehand).
    If not, MspInit or MspDeInit are not null, the @ref HAL_RNG_Init() and @ref HAL_RNG_DeInit()
    keep and use the user MspInit/MspDeInit callbacks (registered beforehand).
stm32l4xx_hal_rng.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 68 : 
    Exception done MspInit/MspDeInit that can be registered/unregistered
    in HAL_RNG_STATE_READY or HAL_RNG_STATE_RESET state, thus registered (user)
    MspInit/DeInit callbacks can be used during the Init/DeInit.
    In that case first register the MspInit/MspDeInit user callbacks
    using @ref HAL_RNG_RegisterCallback() before calling @ref HAL_RNG_DeInit()
HAL_RNG_Init in stm32l4xx_hal_rng.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_HAL_RNG_REGISTER_CALLBACKS == 1)
  if(hrng->State == HAL_RNG_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hrng->Lock = HAL_UNLOCKED;
HAL_RNG_Init in stm32l4xx_hal_rng.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#else
  if(hrng->State == HAL_RNG_STATE_RESET)
  {  
    /* Allocate lock resource and initialize it */
    hrng->Lock = HAL_UNLOCKED;
HAL_RNG_DeInit in stm32l4xx_hal_rng.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Update the RNG state */
  hrng->State = HAL_RNG_STATE_RESET; 

  /* Initialise the error code */
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;
HAL_RNG_RegisterCallback in stm32l4xx_hal_rng.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if(HAL_RNG_STATE_RESET == hrng->State)
  {
    switch (CallbackID)
    {
HAL_RNG_UnRegisterCallback in stm32l4xx_hal_rng.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if(HAL_RNG_STATE_RESET == hrng->State)
  {
    switch (CallbackID)
    {
HAL_RNG_GenerateRandomNumber in stm32l4xx_hal_rng.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Check if data register contains valid random data */
    while(__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
    {
      if((HAL_GetTick() - tickstart ) > RNG_TIMEOUT_VALUE)
      {    
HAL_RNG_IRQHandler in stm32l4xx_hal_rng.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* RNG clock error interrupt occurred */
  if((__HAL_RNG_GET_IT(hrng, RNG_IT_CEI) != RESET) ||  (__HAL_RNG_GET_IT(hrng, RNG_IT_SEI) != RESET))
  { 
    /* Change RNG peripheral state */
    hrng->State = HAL_RNG_STATE_ERROR;
HAL_RNG_IRQHandler in stm32l4xx_hal_rng.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Check RNG data ready interrupt occurred */    
  if(__HAL_RNG_GET_IT(hrng, RNG_IT_DRDY) != RESET)
  {
    /* Generate random number once, so disable the IT */
    __HAL_RNG_DISABLE_IT(hrng);
stm32l4xx_hal_rng.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 58 : 
{
  HAL_RNG_STATE_RESET     = 0x00,  /*!< RNG not yet initialized or disabled */
  HAL_RNG_STATE_READY     = 0x01,  /*!< RNG initialized and ready for use   */
  HAL_RNG_STATE_BUSY      = 0x02,  /*!< RNG internal process is ongoing     */ 
  HAL_RNG_STATE_TIMEOUT   = 0x03,  /*!< RNG timeout state                   */
stm32l4xx_hal_rng.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 176 : 

/** @brief Reset RNG handle state.
  * @param  __HANDLE__: RNG Handle
  * @retval None
  */
#if (USE_HAL_RNG_REGISTER_CALLBACKS == 1)
#define __HAL_RNG_RESET_HANDLE_STATE(__HANDLE__)  do{                                                   \
                                                       (__HANDLE__)->State = HAL_RNG_STATE_RESET;       \
                                                       (__HANDLE__)->MspInitCallback = NULL;            \
                                                       (__HANDLE__)->MspDeInitCallback = NULL;          \
                                                    } while(0U)
#else
#define __HAL_RNG_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_RNG_STATE_RESET)
#endif /*USE_HAL_RNG_REGISTER_CALLBACKS */

/**
stm32l4xx_hal_rng.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 212 : 
  *            @arg RNG_FLAG_SECS:  Seed error current status 
  * @retval The new state of __FLAG__ (SET or RESET).
  */
#define __HAL_RNG_GET_FLAG(__HANDLE__, __FLAG__) (((__HANDLE__)->Instance->SR & (__FLAG__)) == (__FLAG__))

stm32l4xx_hal_rng.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 248 : 
  *            @arg RNG_IT_SEI: Seed error interrupt
  * @retval The new state of __INTERRUPT__ (SET or RESET).
  */
#define __HAL_RNG_GET_IT(__HANDLE__, __INTERRUPT__) (((__HANDLE__)->Instance->SR & (__INTERRUPT__)) == (__INTERRUPT__))   

stm32l4xx_hal_rng.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 341 : 
  * @param __MODE__: RNG Clock Error Detection mode
  * @retval SET (__MODE__ is valid) or RESET (__MODE__ is invalid)
  */
#define IS_RNG_CED(__MODE__) (((__MODE__) == RNG_CED_ENABLE) || \
                              ((__MODE__) == RNG_CED_DISABLE))
stm32l4xx_hal_rtc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 27 : 

                   ##### Backup Domain Reset #####
 ===============================================================================
  [..] The backup domain reset sets all RTC registers and the RCC_BDCR register
       to their reset values.
       A backup domain reset is generated when one of the following events occurs:
    (#) Software reset, triggered by setting the BDRST bit in the
        RCC Backup domain control register (RCC_BDCR).
    (#) VDD or VBAT power on, if both supplies have previously been powered off.
    (#) Tamper detection event resets all data backup registers.

                   ##### Backup Domain Access #####
  ==================================================================
  [..] After reset, the backup domain (RTC registers and RTC backup data registers)
       is protected against possible unwanted write accesses.
  [..] To enable access to the RTC Domain and RTC registers, proceed as follows:
    (+) Enable the Power Controller (PWR) APB1 interface clock using the
stm32l4xx_hal_rtc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 115 : 

  Use function @ref HAL_RTC_UnRegisterCallback() to reset a callback to the default
  weak function.
  @ref HAL_RTC_UnRegisterCallback() takes as parameters the HAL peripheral handle,
  and the Callback ID.
  This function allows to reset following callbacks:
    (+) AlarmAEventCallback          : RTC Alarm A Event callback.
    (+) AlarmBEventCallback          : RTC Alarm B Event callback.
    (+) TimeStampEventCallback       : RTC TimeStamp Event callback.
stm32l4xx_hal_rtc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 130 : 

  By default, after the @ref HAL_RTC_Init() and when the state is HAL_RTC_STATE_RESET,
  all callbacks are set to the corresponding weak functions :
  examples @ref AlarmAEventCallback(), @ref TimeStampEventCallback().
  Exception done for MspInit and MspDeInit callbacks that are reset to the legacy weak function
  in the @ref HAL_RTC_Init()/@ref HAL_RTC_DeInit() only when these callbacks are null
  (not registered beforehand).
  If not, MspInit or MspDeInit are not null, @ref HAL_RTC_Init()/@ref HAL_RTC_DeInit()
stm32l4xx_hal_rtc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 141 : 
  Exception done MspInit/MspDeInit that can be registered/unregistered
  in HAL_RTC_STATE_READY or HAL_RTC_STATE_RESET state,
  thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
  In that case first register the MspInit/MspDeInit user callbacks
  using @ref HAL_RTC_RegisterCallback() before calling @ref HAL_RTC_DeInit()
HAL_RTC_Init in stm32l4xx_hal_rtc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
    if (hrtc->State == HAL_RTC_STATE_RESET)
    {
      /* Allocate lock resource and initialize it */
      hrtc->Lock = HAL_UNLOCKED;
HAL_RTC_Init in stm32l4xx_hal_rtc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#else /* #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1) */
    if (hrtc->State == HAL_RTC_STATE_RESET)
    {
      /* Allocate lock resource and initialize it */
      hrtc->Lock = HAL_UNLOCKED;
stm32l4xx_hal_rtc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 349 : 
  * @brief  DeInitialize the RTC peripheral.
  * @note   This function does not reset the RTC Backup Data registers.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_RTC_DeInit in stm32l4xx_hal_rtc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    {
      /* Reset all RTC CR register bits */
      hrtc->Instance->TR = 0x00000000U;
      hrtc->Instance->DR = ((uint32_t)(RTC_DR_WDU_0 | RTC_DR_MU_0 | RTC_DR_DU_0));
      hrtc->Instance->CR &= 0x00000000U;
HAL_RTC_DeInit in stm32l4xx_hal_rtc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if defined(STM32L412xx) || defined(STM32L422xx)
        /* Reset TAMP registers */
        ((TAMP_TypeDef *)((uint32_t)hrtc->Instance + hrtc->TampOffset))->CR1 = 0xFFFF0000U;
        ((TAMP_TypeDef *)((uint32_t)hrtc->Instance + hrtc->TampOffset))->CR2 = 0x00000000U;
#else
        /* Reset Tamper configuration register */
        hrtc->Instance->TAMPCR = 0x00000000U;

        /* Reset Option register */
        hrtc->Instance->OR = 0x00000000U;
#endif

HAL_RTC_DeInit in stm32l4xx_hal_rtc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

        hrtc->State = HAL_RTC_STATE_RESET;

        /* Release Lock */
        __HAL_UNLOCK(hrtc);
HAL_RTC_RegisterCallback in stm32l4xx_hal_rtc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (HAL_RTC_STATE_RESET == hrtc->State)
  {
    switch (CallbackID)
    {
HAL_RTC_UnRegisterCallback in stm32l4xx_hal_rtc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (HAL_RTC_STATE_RESET == hrtc->State)
  {
    switch (CallbackID)
    {
stm32l4xx_hal_rtc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 48 : 
{
  HAL_RTC_STATE_RESET             = 0x00U,  /*!< RTC not yet initialized or disabled */
  HAL_RTC_STATE_READY             = 0x01U,  /*!< RTC initialized and ready for use   */
  HAL_RTC_STATE_BUSY              = 0x02U,  /*!< RTC process is ongoing              */
  HAL_RTC_STATE_TIMEOUT           = 0x03U,  /*!< RTC timeout state                   */
stm32l4xx_hal_rtc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 329 : 
  */
#define RTC_STOREOPERATION_RESET            0x00000000u
#define RTC_STOREOPERATION_SET              RTC_CR_BKP
/**
  * @}
stm32l4xx_hal_rtc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 547 : 

/** @brief Reset RTC handle state
  * @param  __HANDLE__ RTC handle.
  * @retval None
  */
#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
#define __HAL_RTC_RESET_HANDLE_STATE(__HANDLE__) do{\
                                                      (__HANDLE__)->State = HAL_RTC_STATE_RESET;\
                                                      (__HANDLE__)->MspInitCallback = NULL;\
                                                      (__HANDLE__)->MspDeInitCallback = NULL;\
                                                     }while(0u)
#else
#define __HAL_RTC_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_RTC_STATE_RESET)
#endif /* USE_HAL_RTC_REGISTER_CALLBACKS */

/**
stm32l4xx_hal_rtc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 587 : 
  *         This parameter can be:
  *            @arg @ref RTC_STOREOPERATION_RESET
  *            @arg @ref RTC_STOREOPERATION_SET
  * @retval None
  */
stm32l4xx_hal_rtc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 604 : 
  *         This parameter can be:
  *            @arg @ref RTC_STOREOPERATION_RESET
  *            @arg @ref RTC_STOREOPERATION_SET
  * @retval None
  */
stm32l4xx_hal_rtc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 974 : 

#define IS_RTC_STORE_OPERATION(OPERATION) (((OPERATION) == RTC_STOREOPERATION_RESET) || \
                                           ((OPERATION) == RTC_STOREOPERATION_SET))

#define IS_RTC_FORMAT(FORMAT) (((FORMAT) == RTC_FORMAT_BIN) || \
HAL_RTCEx_TamperTimeStampIRQHandler in stm32l4xx_hal_rtc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#endif
    /* Not immediatly clear flags because the content of RTC_TSTR and RTC_TSDR arecleared when TSF bit is reset.*/
    hrtc->Instance->SCR = RTC_SCR_CTSF;
  }

stm32l4xx_hal_rtc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 1075 : 
  *             @arg RTC_SMOOTHCALIB_PERIOD_8SEC: The smooth calibration period is 8s.
  * @param  SmoothCalibPlusPulses Select to Set or reset the CALP bit.
  *          This parameter can be one of the following values:
  *             @arg RTC_SMOOTHCALIB_PLUSPULSES_SET: Add one RTCCLK pulse every 2*11 pulses.
  *             @arg RTC_SMOOTHCALIB_PLUSPULSES_RESET: No RTCCLK pulses are added.
  * @param  SmoothCalibMinusPulsesValue Select the value of CALM[8:0] bits.
  *          This parameter can be one any value from 0 to 0x000001FF.
  * @note   To deactivate the smooth calibration, the field SmoothCalibPlusPulses
  *         must be equal to SMOOTHCALIB_PLUSPULSES_RESET and the field
  *         SmoothCalibMinusPulsesValue must be equal to 0.
  * @retval HAL status
  */
stm32l4xx_hal_rtc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 1157 : 
  *             @arg RTC_LPCAL_SET: Low power mode.
  *             @arg RTC_LPCAL_RESET: High consumption mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetLowPowerCalib(RTC_HandleTypeDef *hrtc, uint32_t LowPowerCalib)
stm32l4xx_hal_rtc_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 1196 : 
  *             @arg RTC_SHIFTADD1S_SET: Add one second to the clock calendar.
  *             @arg RTC_SHIFTADD1S_RESET: No effect.
  * @param  ShiftSubFS Select the number of Second Fractions to substitute.
  *          This parameter can be one any value from 0 to 0x7FFF.
  * @retval HAL status
stm32l4xx_hal_rtc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 154 : 
                                                                     with Y = 512, 256, 128 when X = 32, 16, 8 */
#define RTC_SMOOTHCALIB_PLUSPULSES_RESET  0x00000000u           /*!< The number of RTCCLK pulses subbstited
                                                                     during a 32-second window = CALM[8:0] */
/**
  * @}
stm32l4xx_hal_rtc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 167 : 
                                                                     ultra-low consumption mode. */
#define RTC_LPCAL_RESET                   0x00000000u           /*!< Calibration window is 220 RTCCLK,
                                                                     which is a high-consumption mode.
                                                                     This mode should be set only when less
                                                                     than 32s calibration window is required. */
stm32l4xx_hal_rtc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 188 : 
  */
#define RTC_SHIFTADD1S_RESET      0x00000000u
#define RTC_SHIFTADD1S_SET        RTC_SHIFTR_ADD1S
/**
  * @}
stm32l4xx_hal_rtc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1399 : 
#define IS_RTC_SMOOTH_CALIB_PLUS(PLUS) (((PLUS) == RTC_SMOOTHCALIB_PLUSPULSES_SET) || \
                                        ((PLUS) == RTC_SMOOTHCALIB_PLUSPULSES_RESET))

#define IS_RTC_SMOOTH_CALIB_MINUS(VALUE) ((VALUE) <= RTC_CALR_CALM)

stm32l4xx_hal_rtc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1405 : 
#define IS_RTC_LOW_POWER_CALIB(LPCAL) (((LPCAL) == RTC_LPCAL_SET) || \
                                       ((LPCAL) == RTC_LPCAL_RESET))
#endif

#if defined(STM32L412xx) || defined(STM32L422xx)
stm32l4xx_hal_rtc_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1454 : 

#define IS_RTC_SHIFT_ADD1S(SEL) (((SEL) == RTC_SHIFTADD1S_RESET) || \
                                 ((SEL) == RTC_SHIFTADD1S_SET))

#define IS_RTC_SHIFT_SUBFS(FS) ((FS) <= RTC_SHIFTR_SUBFS)
stm32l4xx_hal_sai.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 160 : 
    [..]
    Use function HAL_SAI_UnRegisterCallback() to reset a callback to the default
    weak (surcharged) function.
    HAL_SAI_UnRegisterCallback() takes as parameters the HAL peripheral handle,
    and the callback ID.
    [..]
    This function allows to reset following callbacks:
      (+) RxCpltCallback     : SAI receive complete.
      (+) RxHalfCpltCallback : SAI receive half complete.
      (+) TxCpltCallback     : SAI transmit complete.
stm32l4xx_hal_sai.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 175 : 
    [..]
    By default, after the HAL_SAI_Init and if the state is HAL_SAI_STATE_RESET
    all callbacks are reset to the corresponding legacy weak (surcharged) functions:
    examples HAL_SAI_RxCpltCallback(), HAL_SAI_ErrorCallback().
    Exception done for MspInit and MspDeInit callbacks that are respectively
    reset to the legacy weak (surcharged) functions in the HAL_SAI_Init
    and HAL_SAI_DeInit only when these callbacks are null (not registered beforehand).
    If not, MspInit or MspDeInit are not null, the HAL_SAI_Init and HAL_SAI_DeInit
    keep and use the user MspInit/MspDeInit callbacks (registered beforehand).
stm32l4xx_hal_sai.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 187 : 
    Exception done for MspInit/MspDeInit callbacks that can be registered/unregistered
    in READY or RESET state, thus registered (user) MspInit/DeInit callbacks can be used
    during the Init/DeInit.
    In that case first register the MspInit/MspDeInit user callbacks
    using HAL_SAI_RegisterCallback before calling HAL_SAI_DeInit
HAL_SAI_Init in stm32l4xx_hal_sai.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (hsai->State == HAL_SAI_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hsai->Lock = HAL_UNLOCKED;
HAL_SAI_Init in stm32l4xx_hal_sai.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
    /* Reset callback pointers to the weak predefined callbacks */
    hsai->RxCpltCallback     = HAL_SAI_RxCpltCallback;
    hsai->RxHalfCpltCallback = HAL_SAI_RxHalfCpltCallback;
    hsai->TxCpltCallback     = HAL_SAI_TxCpltCallback;
HAL_SAI_DeInit in stm32l4xx_hal_sai.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Reset SAI state to ready */
    hsai->State = HAL_SAI_STATE_READY;

    /* Release Lock */
HAL_SAI_DeInit in stm32l4xx_hal_sai.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Reset PDM delays */
    SAI1->PDMDLY = 0U;

    /* Disable PDM interface */
HAL_SAI_DeInit in stm32l4xx_hal_sai.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Initialize the SAI state */
  hsai->State = HAL_SAI_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(hsai);
HAL_SAI_RegisterCallback in stm32l4xx_hal_sai.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    }
    else if (HAL_SAI_STATE_RESET == hsai->State)
    {
      switch (CallbackID)
      {
HAL_SAI_UnRegisterCallback in stm32l4xx_hal_sai.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (HAL_SAI_STATE_RESET == hsai->State)
  {
    switch (CallbackID)
    {
HAL_SAI_EnableTxMuteMode in stm32l4xx_hal_sai.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (hsai->State != HAL_SAI_STATE_RESET)
  {
    CLEAR_BIT(hsai->Instance->CR2, SAI_xCR2_MUTEVAL | SAI_xCR2_MUTE);
    SET_BIT(hsai->Instance->CR2, SAI_xCR2_MUTE | (uint32_t)val);
HAL_SAI_DisableTxMuteMode in stm32l4xx_hal_sai.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
{
  if (hsai->State != HAL_SAI_STATE_RESET)
  {
    CLEAR_BIT(hsai->Instance->CR2, SAI_xCR2_MUTEVAL | SAI_xCR2_MUTE);
    return HAL_OK;
HAL_SAI_EnableRxMuteMode in stm32l4xx_hal_sai.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (hsai->State != HAL_SAI_STATE_RESET)
  {
    /* set the mute counter */
    CLEAR_BIT(hsai->Instance->CR2, SAI_xCR2_MUTECNT);
HAL_SAI_DisableRxMuteMode in stm32l4xx_hal_sai.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
{
  if (hsai->State != HAL_SAI_STATE_RESET)
  {
    /* set the mutecallback to NULL */
    hsai->mutecallback = NULL;
HAL_SAI_IRQHandler in stm32l4xx_hal_sai.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
{
  if (hsai->State != HAL_SAI_STATE_RESET)
  {
    uint32_t itflags = hsai->Instance->SR;
    uint32_t itsources = hsai->Instance->IMR;
stm32l4xx_hal_sai.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 50 : 
{
  HAL_SAI_STATE_RESET   = 0x00U, /*!< SAI not yet initialized or disabled  */
  HAL_SAI_STATE_READY   = 0x01U, /*!< SAI initialized and ready for use    */
  HAL_SAI_STATE_BUSY    = 0x02U, /*!< SAI internal process is ongoing      */
  HAL_SAI_STATE_BUSY_TX = 0x12U, /*!< Data transmission process is ongoing */
stm32l4xx_hal_sai.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 639 : 

/** @brief Reset SAI handle state.
  * @param  __HANDLE__ specifies the SAI Handle.
  * @retval None
  */
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
#define __HAL_SAI_RESET_HANDLE_STATE(__HANDLE__) do{                                            \
                                                     (__HANDLE__)->State = HAL_SAI_STATE_RESET; \
                                                     (__HANDLE__)->MspInitCallback = NULL;      \
                                                     (__HANDLE__)->MspDeInitCallback = NULL;    \
                                                   } while(0)
#else
#define __HAL_SAI_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_SAI_STATE_RESET)
#endif

/** @brief  Enable the specified SAI interrupts.
stm32l4xx_hal_sai.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 696 : 
  */
#define __HAL_SAI_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((((__HANDLE__)->Instance->IMR & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)

/** @brief  Check whether the specified SAI flag is set or not.
  * @param  __HANDLE__ specifies the SAI Handle.
HAL_SAIEx_ConfigPdmMicDelay in stm32l4xx_hal_sai_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Check SAI state and offset */
    if ((hsai->State != HAL_SAI_STATE_RESET) && (offset <= 24U))
    {
      /* Reset current delays for specified microphone */
      SAI1->PDMDLY &= ~(SAI_PDM_DELAY_MASK << offset);

      /* Apply new microphone delays */
stm32l4xx_hal_sd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 219 : 

    Use function @ref HAL_SD_UnRegisterCallback() to reset a callback to the default
    weak (surcharged) function. It allows to reset following callbacks:
      (+) TxCpltCallback : callback when a transmission transfer is completed.
      (+) RxCpltCallback : callback when a reception transfer is completed.
      (+) ErrorCallback : callback when error occurs.
stm32l4xx_hal_sd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 235 : 

    By default, after the @ref HAL_SD_Init and if the state is HAL_SD_STATE_RESET
    all callbacks are reset to the corresponding legacy weak (surcharged) functions.
    Exception done for MspInit and MspDeInit callbacks that are respectively
    reset to the legacy weak (surcharged) functions in the @ref HAL_SD_Init
    and @ref  HAL_SD_DeInit only when these callbacks are null (not registered beforehand).
    If not, MspInit or MspDeInit are not null, the @ref HAL_SD_Init and @ref HAL_SD_DeInit
    keep and use the user MspInit/MspDeInit callbacks (registered beforehand)
stm32l4xx_hal_sd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 245 : 
    Exception done for MspInit/MspDeInit callbacks that can be registered/unregistered
    in READY or RESET state, thus registered (user) MspInit/DeInit callbacks can be used
    during the Init/DeInit.
    In that case first register the MspInit/MspDeInit user callbacks
    using @ref HAL_SD_RegisterCallback before calling @ref HAL_SD_DeInit
HAL_SD_Init in stm32l4xx_hal_sd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if(hsd->State == HAL_SD_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hsd->Lock = HAL_UNLOCKED;
#if defined (USE_HAL_SD_REGISTER_CALLBACKS) && (USE_HAL_SD_REGISTER_CALLBACKS == 1U)
    /* Reset Callback pointers in HAL_SD_STATE_RESET only */
    hsd->TxCpltCallback    = HAL_SD_TxCpltCallback;
    hsd->RxCpltCallback    = HAL_SD_RxCpltCallback;
    hsd->ErrorCallback     = HAL_SD_ErrorCallback;
HAL_SD_DeInit in stm32l4xx_hal_sd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    }
    hsd->DriveTransceiver_1_8V_Callback(RESET);
#else
    HAL_SDEx_DriveTransceiver_1_8V_Callback(RESET);
#endif /* USE_HAL_SD_REGISTER_CALLBACKS */
  }
#endif
HAL_SD_DeInit in stm32l4xx_hal_sd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  hsd->ErrorCode = HAL_SD_ERROR_NONE;
  hsd->State = HAL_SD_STATE_RESET;

  return HAL_OK;
}
HAL_SD_IRQHandler in stm32l4xx_hal_sd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Check for SDMMC interrupt flags */
  if((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF) != RESET) && ((context & SD_CONTEXT_IT) != 0U))
  {
    SD_Read_IT(hsd);
  }

  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) != RESET)
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DATAEND);

HAL_SD_IRQHandler in stm32l4xx_hal_sd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  else if((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXFIFOHE) != RESET) && ((context & SD_CONTEXT_IT) != 0U))
  {
    SD_Write_IT(hsd);
  }

  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_RXOVERR | SDMMC_FLAG_TXUNDERR) != RESET)
  {
    /* Set Error code */
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_IT_DCRCFAIL) != RESET)
    {
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
    }
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_IT_DTIMEOUT) != RESET)
    {
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
    }
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_IT_RXOVERR) != RESET)
    {
      hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN;
    }
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_IT_TXUNDERR) != RESET)
    {
      hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN;
    }
HAL_SD_IRQHandler in stm32l4xx_hal_sd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_IDMABTC) != RESET)
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_IDMABTC);
    if(READ_BIT(hsd->Instance->IDMACTRL, SDMMC_IDMA_IDMABACT) == 0U)
HAL_SD_RegisterCallback in stm32l4xx_hal_sd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (hsd->State == HAL_SD_STATE_RESET)
  {
    switch (CallbackID)
    {
HAL_SD_UnRegisterCallback in stm32l4xx_hal_sd.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (hsd->State == HAL_SD_STATE_RESET)
  {
    switch (CallbackID)
    {
stm32l4xx_hal_sd.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 51 : 
{
  HAL_SD_STATE_RESET                  = ((uint32_t)0x00000000U),  /*!< SD not yet initialized or disabled  */
  HAL_SD_STATE_READY                  = ((uint32_t)0x00000001U),  /*!< SD initialized and ready for use    */
  HAL_SD_STATE_TIMEOUT                = ((uint32_t)0x00000002U),  /*!< SD Timeout state                    */
  HAL_SD_STATE_BUSY                   = ((uint32_t)0x00000003U),  /*!< SD process ongoing                  */
stm32l4xx_hal_sd.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 348 : 
#define HAL_SD_ERROR_CARD_ECC_DISABLED        SDMMC_ERROR_CARD_ECC_DISABLED           /*!< Command has been executed without using internal ECC         */
#define HAL_SD_ERROR_ERASE_RESET              SDMMC_ERROR_ERASE_RESET                 /*!< Erase sequence was cleared before executing because an out
                                                                                           of erase sequence command was received                       */
#define HAL_SD_ERROR_AKE_SEQ_ERR              SDMMC_ERROR_AKE_SEQ_ERR                 /*!< Error in sequence of authentication                          */
#define HAL_SD_ERROR_INVALID_VOLTRANGE        SDMMC_ERROR_INVALID_VOLTRANGE           /*!< Error in case of invalid voltage range                       */
stm32l4xx_hal_sd.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 418 : 
 */
/** @brief Reset SD handle state.
  * @param  __HANDLE__ : SD handle.
  * @retval None
  */
#if defined (USE_HAL_SD_REGISTER_CALLBACKS) && (USE_HAL_SD_REGISTER_CALLBACKS == 1U)
#define __HAL_SD_RESET_HANDLE_STATE(__HANDLE__)           do {                                              \
                                                               (__HANDLE__)->State = HAL_SD_STATE_RESET; \
                                                               (__HANDLE__)->MspInitCallback = NULL;       \
                                                               (__HANDLE__)->MspDeInitCallback = NULL;     \
                                                             } while(0)
#else
#define __HAL_SD_RESET_HANDLE_STATE(__HANDLE__)           ((__HANDLE__)->State = HAL_SD_STATE_RESET)
#endif /* USE_HAL_SD_REGISTER_CALLBACKS */

#if !defined(STM32L4R5xx) && !defined(STM32L4R7xx) && !defined(STM32L4R9xx) && !defined(STM32L4S5xx) && !defined(STM32L4S7xx) && !defined(STM32L4S9xx)
stm32l4xx_hal_sd.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 575 : 
  *            @arg SDMMC_FLAG_IDMABTC:    IDMA buffer transfer complete
  * @retval The new state of SD FLAG (SET or RESET).
  */
#define __HAL_SD_GET_FLAG(__HANDLE__, __FLAG__) __SDMMC_GET_FLAG((__HANDLE__)->Instance, (__FLAG__))

stm32l4xx_hal_sd.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 643 : 
  *            @arg SDMMC_IT_IDMABTC:    IDMA buffer transfer complete interrupt
  * @retval The new state of SD IT (SET or RESET).
  */
#define __HAL_SD_GET_IT(__HANDLE__, __INTERRUPT__) __SDMMC_GET_IT((__HANDLE__)->Instance, (__INTERRUPT__))

stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 125 : 
    [..]
    Use function @ref HAL_SMARTCARD_UnRegisterCallback() to reset a callback to the default
    weak (surcharged) function.
    @ref HAL_SMARTCARD_UnRegisterCallback() takes as parameters the HAL peripheral handle,
    and the Callback ID.
    This function allows to reset following callbacks:
    (+) TxCpltCallback            : Tx Complete Callback.
    (+) RxCpltCallback            : Rx Complete Callback.
    (+) ErrorCallback             : Error Callback.
stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 142 : 
    [..]
    By default, after the @ref HAL_SMARTCARD_Init() and when the state is HAL_SMARTCARD_STATE_RESET
    all callbacks are set to the corresponding weak (surcharged) functions:
    examples @ref HAL_SMARTCARD_TxCpltCallback(), @ref HAL_SMARTCARD_RxCpltCallback().
    Exception done for MspInit and MspDeInit functions that are respectively
    reset to the legacy weak (surcharged) functions in the @ref HAL_SMARTCARD_Init()
    and @ref HAL_SMARTCARD_DeInit() only when these callbacks are null (not registered beforehand).
    If not, MspInit or MspDeInit are not null, the @ref HAL_SMARTCARD_Init() and @ref HAL_SMARTCARD_DeInit()
    keep and use the user MspInit/MspDeInit callbacks (registered beforehand).
stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 154 : 
    Exception done MspInit/MspDeInit that can be registered/unregistered
    in HAL_SMARTCARD_STATE_READY or HAL_SMARTCARD_STATE_RESET state, thus registered (user)
    MspInit/DeInit callbacks can be used during the Init/DeInit.
    In that case first register the MspInit/MspDeInit user callbacks
    using @ref HAL_SMARTCARD_RegisterCallback() before calling @ref HAL_SMARTCARD_DeInit()
HAL_SMARTCARD_Init in stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (hsmartcard->gState == HAL_SMARTCARD_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hsmartcard->Lock = HAL_UNLOCKED;
HAL_SMARTCARD_DeInit in stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  hsmartcard->ErrorCode = HAL_SMARTCARD_ERROR_NONE;
  hsmartcard->gState    = HAL_SMARTCARD_STATE_RESET;
  hsmartcard->RxState   = HAL_SMARTCARD_STATE_RESET;

  /* Process Unlock */
  __HAL_UNLOCK(hsmartcard);
HAL_SMARTCARD_RegisterCallback in stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (hsmartcard->gState == HAL_SMARTCARD_STATE_RESET)
  {
    switch (CallbackID)
    {
HAL_SMARTCARD_UnRegisterCallback in stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (HAL_SMARTCARD_STATE_RESET == hsmartcard->gState)
  {
    switch (CallbackID)
    {
HAL_SMARTCARD_Transmit in stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      hsmartcard->TxXferCount--;
      if (SMARTCARD_WaitOnFlagUntilTimeout(hsmartcard, SMARTCARD_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
      {
        return HAL_TIMEOUT;
      }
HAL_SMARTCARD_Transmit in stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    }
    if (SMARTCARD_WaitOnFlagUntilTimeout(hsmartcard, SMARTCARD_TRANSMISSION_COMPLETION_FLAG(hsmartcard), RESET, tickstart,
                                         Timeout) != HAL_OK)
    {
      return HAL_TIMEOUT;
HAL_SMARTCARD_Receive in stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

      if (SMARTCARD_WaitOnFlagUntilTimeout(hsmartcard, SMARTCARD_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
      {
        return HAL_TIMEOUT;
      }
HAL_SMARTCARD_Abort in stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset Tx and Rx transfer counters */
  hsmartcard->TxXferCount = 0U;
  hsmartcard->RxXferCount = 0U;

HAL_SMARTCARD_Abort in stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset Handle ErrorCode to No Error */
  hsmartcard->ErrorCode = HAL_SMARTCARD_ERROR_NONE;

  return HAL_OK;
HAL_SMARTCARD_AbortTransmit in stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset Tx transfer counter */
  hsmartcard->TxXferCount = 0U;

  /* Clear the Error flags in the ICR register */
HAL_SMARTCARD_AbortReceive in stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset Rx transfer counter */
  hsmartcard->RxXferCount = 0U;

  /* Clear the Error flags in the ICR register */
HAL_SMARTCARD_Abort_IT in stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Reset Tx and Rx transfer counters */
    hsmartcard->TxXferCount = 0U;
    hsmartcard->RxXferCount = 0U;

HAL_SMARTCARD_Abort_IT in stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset errorCode */
    hsmartcard->ErrorCode = HAL_SMARTCARD_ERROR_NONE;

    /* Clear the Error flags in the ICR register */
HAL_SMARTCARD_AbortTransmit_IT in stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    {
      /* Reset Tx transfer counter */
      hsmartcard->TxXferCount = 0U;

      /* Clear TxISR function pointers */
HAL_SMARTCARD_AbortTransmit_IT in stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Reset Tx transfer counter */
    hsmartcard->TxXferCount = 0U;

    /* Clear TxISR function pointers */
HAL_SMARTCARD_AbortReceive_IT in stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    {
      /* Reset Rx transfer counter */
      hsmartcard->RxXferCount = 0U;

      /* Clear RxISR function pointer */
HAL_SMARTCARD_AbortReceive_IT in stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Reset Rx transfer counter */
    hsmartcard->RxXferCount = 0U;

    /* Clear RxISR function pointer */
HAL_SMARTCARD_IRQHandler in stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* SMARTCARD in mode Transmitter (transmission end) ------------------------*/
  if (__HAL_SMARTCARD_GET_IT(hsmartcard, hsmartcard->AdvancedInit.TxCompletionIndication) != RESET)
  {
    if (__HAL_SMARTCARD_GET_IT_SOURCE(hsmartcard, hsmartcard->AdvancedInit.TxCompletionIndication) != RESET)
    {
      SMARTCARD_EndTransmit_IT(hsmartcard);
      return;
SMARTCARD_CheckIdleState in stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Wait until TEACK flag is set */
    if (SMARTCARD_WaitOnFlagUntilTimeout(hsmartcard, USART_ISR_TEACK, RESET, tickstart,
                                         SMARTCARD_TEACK_REACK_TIMEOUT) != HAL_OK)
    {
      /* Timeout occurred */
SMARTCARD_CheckIdleState in stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Wait until REACK flag is set */
    if (SMARTCARD_WaitOnFlagUntilTimeout(hsmartcard, USART_ISR_REACK, RESET, tickstart,
                                         SMARTCARD_TEACK_REACK_TIMEOUT) != HAL_OK)
    {
      /* Timeout occurred */
stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 2663 : 
  * @param  Flag Specifies the SMARTCARD flag to check.
  * @param  Status The new Flag status (SET or RESET).
  * @param  Tickstart Tick start value
  * @param  Timeout Timeout duration.
  * @retval HAL status
SMARTCARD_WaitOnFlagUntilTimeout in stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Wait until flag is set */
  while ((__HAL_SMARTCARD_GET_FLAG(hsmartcard, Flag) ? SET : RESET) == Status)
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
SMARTCARD_DMATransmitCplt in stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Disable the DMA transfer for transmit request by resetting the DMAT bit
  in the SMARTCARD associated USART CR3 register */
  CLEAR_BIT(hsmartcard->Instance->CR3, USART_CR3_DMAT);

SMARTCARD_DMAReceiveCplt in stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
     in the SMARTCARD associated USART CR3 register */
  CLEAR_BIT(hsmartcard->Instance->CR3, USART_CR3_DMAR);

SMARTCARD_DMATxAbortCallback in stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset errorCode */
  hsmartcard->ErrorCode = HAL_SMARTCARD_ERROR_NONE;

  /* Clear the Error flags in the ICR register */
SMARTCARD_DMARxAbortCallback in stm32l4xx_hal_smartcard.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset errorCode */
  hsmartcard->ErrorCode = HAL_SMARTCARD_ERROR_NONE;

  /* Clear the Error flags in the ICR register */
stm32l4xx_hal_smartcard.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 162 : 
  *          b5     Peripheral initialization status
  *             0  : Reset (Peripheral not initialized)
  *             1  : Init done (Peripheral not initialized. HAL SMARTCARD Init function already called)
  *          b4-b3  (not used)
  *             xx : Should be set to 00
stm32l4xx_hal_smartcard.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 179 : 
  *          b5     Peripheral initialization status
  *             0  : Reset (Peripheral not initialized)
  *             1  : Init done (Peripheral not initialized)
  *          b4-b2  (not used)
  *            xxx : Should be set to 000
stm32l4xx_hal_smartcard.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 322 : 
  */
#define HAL_SMARTCARD_STATE_RESET            0x00000000U                     /*!< Peripheral is not initialized
                                                                                  Value is allowed for gState and RxState */
#define HAL_SMARTCARD_STATE_READY            0x00000020U                     /*!< Peripheral Initialized and ready for use
                                                                                  Value is allowed for gState and RxState */
stm32l4xx_hal_smartcard.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 564 : 

/** @brief  Reset SMARTCARD handle states.
  * @param  __HANDLE__ SMARTCARD handle.
  * @retval None
  */
#if USE_HAL_SMARTCARD_REGISTER_CALLBACKS == 1
#define __HAL_SMARTCARD_RESET_HANDLE_STATE(__HANDLE__)  do{                                                       \
                                                            (__HANDLE__)->gState = HAL_SMARTCARD_STATE_RESET;     \
                                                            (__HANDLE__)->RxState = HAL_SMARTCARD_STATE_RESET;    \
                                                            (__HANDLE__)->MspInitCallback = NULL;                 \
                                                            (__HANDLE__)->MspDeInitCallback = NULL;               \
                                                          } while(0U)
#else
#define __HAL_SMARTCARD_RESET_HANDLE_STATE(__HANDLE__)  do{                                                       \
                                                            (__HANDLE__)->gState = HAL_SMARTCARD_STATE_RESET;     \
                                                            (__HANDLE__)->RxState = HAL_SMARTCARD_STATE_RESET;    \
                                                          } while(0U)
#endif /*USE_HAL_SMARTCARD_REGISTER_CALLBACKS  */

stm32l4xx_hal_smartcard.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 739 : 
  *            @arg @ref SMARTCARD_IT_TXFT   TXFIFO threshold reached interruption
  * @retval The new state of __INTERRUPT__ (SET or RESET).
  */
#define __HAL_SMARTCARD_GET_IT(__HANDLE__, __INTERRUPT__) ((((__HANDLE__)->Instance->ISR\
                                                             & ((uint32_t)0x01U << (((__INTERRUPT__) & SMARTCARD_ISR_MASK)>> SMARTCARD_ISR_POS))) != 0U) ? SET : RESET)

/** @brief  Check whether the specified SmartCard interrupt source is enabled or not.
  * @param  __HANDLE__ specifies the SMARTCARD Handle.
stm32l4xx_hal_smartcard.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 763 : 
  *            @arg @ref SMARTCARD_IT_TXFT   TXFIFO threshold reached interruption
  * @retval The new state of __INTERRUPT__ (SET or RESET).
  */
#define __HAL_SMARTCARD_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((((((((__INTERRUPT__) & SMARTCARD_CR_MASK) >> SMARTCARD_CR_POS) == 0x01U)? (__HANDLE__)->Instance->CR1 : \
                                                                     (((((__INTERRUPT__) & SMARTCARD_CR_MASK) >> SMARTCARD_CR_POS) == 0x02U)? (__HANDLE__)->Instance->CR2 : \
                                                                      (__HANDLE__)->Instance->CR3)) & ((uint32_t)0x01U << (((uint16_t)(__INTERRUPT__)) & SMARTCARD_IT_MASK)))  != 0U) ? SET : RESET)

/** @brief  Clear the specified SMARTCARD ISR flag, in setting the proper ICR register flag.
  * @param  __HANDLE__ specifies the SMARTCARD Handle.
stm32l4xx_hal_smartcard.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 991 : 
  * @param __LENGTH__ SMARTCARD frame length.
  * @retval SET (__LENGTH__ is valid) or RESET (__LENGTH__ is invalid)
  */
#define IS_SMARTCARD_WORD_LENGTH(__LENGTH__) ((__LENGTH__) == SMARTCARD_WORDLENGTH_9B)

stm32l4xx_hal_smartcard.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 997 : 
  * @param __STOPBITS__ SMARTCARD frame number of stop bits.
  * @retval SET (__STOPBITS__ is valid) or RESET (__STOPBITS__ is invalid)
  */
#define IS_SMARTCARD_STOPBITS(__STOPBITS__) (((__STOPBITS__) == SMARTCARD_STOPBITS_0_5) ||\
                                             ((__STOPBITS__) == SMARTCARD_STOPBITS_1_5))
stm32l4xx_hal_smartcard.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1004 : 
  * @param __PARITY__ SMARTCARD frame parity.
  * @retval SET (__PARITY__ is valid) or RESET (__PARITY__ is invalid)
  */
#define IS_SMARTCARD_PARITY(__PARITY__) (((__PARITY__) == SMARTCARD_PARITY_EVEN) || \
                                         ((__PARITY__) == SMARTCARD_PARITY_ODD))
stm32l4xx_hal_smartcard.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1011 : 
  * @param __MODE__ SMARTCARD communication mode.
  * @retval SET (__MODE__ is valid) or RESET (__MODE__ is invalid)
  */
#define IS_SMARTCARD_MODE(__MODE__) ((((__MODE__) & 0xFFF3U) == 0x00U) && ((__MODE__) != 0x00U))

stm32l4xx_hal_smartcard.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1017 : 
  * @param __CPOL__ SMARTCARD frame polarity.
  * @retval SET (__CPOL__ is valid) or RESET (__CPOL__ is invalid)
  */
#define IS_SMARTCARD_POLARITY(__CPOL__) (((__CPOL__) == SMARTCARD_POLARITY_LOW)\
                                         || ((__CPOL__) == SMARTCARD_POLARITY_HIGH))
stm32l4xx_hal_smartcard.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1024 : 
  * @param __CPHA__ SMARTCARD frame phase.
  * @retval SET (__CPHA__ is valid) or RESET (__CPHA__ is invalid)
  */
#define IS_SMARTCARD_PHASE(__CPHA__) (((__CPHA__) == SMARTCARD_PHASE_1EDGE) || ((__CPHA__) == SMARTCARD_PHASE_2EDGE))

stm32l4xx_hal_smartcard.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1030 : 
  * @param __LASTBIT__ SMARTCARD frame last bit clock pulse setting.
  * @retval SET (__LASTBIT__ is valid) or RESET (__LASTBIT__ is invalid)
  */
#define IS_SMARTCARD_LASTBIT(__LASTBIT__) (((__LASTBIT__) == SMARTCARD_LASTBIT_DISABLE) || \
                                           ((__LASTBIT__) == SMARTCARD_LASTBIT_ENABLE))
stm32l4xx_hal_smartcard.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1037 : 
  * @param __ONEBIT__ SMARTCARD frame sampling.
  * @retval SET (__ONEBIT__ is valid) or RESET (__ONEBIT__ is invalid)
  */
#define IS_SMARTCARD_ONE_BIT_SAMPLE(__ONEBIT__) (((__ONEBIT__) == SMARTCARD_ONE_BIT_SAMPLE_DISABLE) || \
                                                 ((__ONEBIT__) == SMARTCARD_ONE_BIT_SAMPLE_ENABLE))
stm32l4xx_hal_smartcard.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1044 : 
  * @param __NACK__ SMARTCARD NACK transmission setting.
  * @retval SET (__NACK__ is valid) or RESET (__NACK__ is invalid)
  */
#define IS_SMARTCARD_NACK(__NACK__) (((__NACK__) == SMARTCARD_NACK_ENABLE) || \
                                     ((__NACK__) == SMARTCARD_NACK_DISABLE))
stm32l4xx_hal_smartcard.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1051 : 
  * @param __TIMEOUT__ SMARTCARD receiver timeout setting.
  * @retval SET (__TIMEOUT__ is valid) or RESET (__TIMEOUT__ is invalid)
  */
#define IS_SMARTCARD_TIMEOUT(__TIMEOUT__) (((__TIMEOUT__) == SMARTCARD_TIMEOUT_DISABLE) || \
                                           ((__TIMEOUT__) == SMARTCARD_TIMEOUT_ENABLE))
stm32l4xx_hal_smartcard.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1059 : 
  * @param __CLOCKPRESCALER__ SMARTCARD clock Prescaler value.
  * @retval SET (__CLOCKPRESCALER__ is valid) or RESET (__CLOCKPRESCALER__ is invalid)
  */
#define IS_SMARTCARD_CLOCKPRESCALER(__CLOCKPRESCALER__) (((__CLOCKPRESCALER__) == SMARTCARD_PRESCALER_DIV1)   || \
                                                         ((__CLOCKPRESCALER__) == SMARTCARD_PRESCALER_DIV2)   || \
stm32l4xx_hal_smartcard.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1077 : 
  * @param __INIT__ SMARTCARD advanced features initialization.
  * @retval SET (__INIT__ is valid) or RESET (__INIT__ is invalid)
  */
#define IS_SMARTCARD_ADVFEATURE_INIT(__INIT__) ((__INIT__) <= (SMARTCARD_ADVFEATURE_NO_INIT                | \
                                                               SMARTCARD_ADVFEATURE_TXINVERT_INIT          | \
stm32l4xx_hal_smartcard.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1090 : 
  * @param __TXINV__ SMARTCARD frame TX inversion setting.
  * @retval SET (__TXINV__ is valid) or RESET (__TXINV__ is invalid)
  */
#define IS_SMARTCARD_ADVFEATURE_TXINV(__TXINV__) (((__TXINV__) == SMARTCARD_ADVFEATURE_TXINV_DISABLE) || \
                                                  ((__TXINV__) == SMARTCARD_ADVFEATURE_TXINV_ENABLE))
stm32l4xx_hal_smartcard.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1097 : 
  * @param __RXINV__ SMARTCARD frame RX inversion setting.
  * @retval SET (__RXINV__ is valid) or RESET (__RXINV__ is invalid)
  */
#define IS_SMARTCARD_ADVFEATURE_RXINV(__RXINV__) (((__RXINV__) == SMARTCARD_ADVFEATURE_RXINV_DISABLE) || \
                                                  ((__RXINV__) == SMARTCARD_ADVFEATURE_RXINV_ENABLE))
stm32l4xx_hal_smartcard.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1104 : 
  * @param __DATAINV__ SMARTCARD frame data inversion setting.
  * @retval SET (__DATAINV__ is valid) or RESET (__DATAINV__ is invalid)
  */
#define IS_SMARTCARD_ADVFEATURE_DATAINV(__DATAINV__) (((__DATAINV__) == SMARTCARD_ADVFEATURE_DATAINV_DISABLE) || \
                                                      ((__DATAINV__) == SMARTCARD_ADVFEATURE_DATAINV_ENABLE))
stm32l4xx_hal_smartcard.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1111 : 
  * @param __SWAP__ SMARTCARD frame RX/TX pins swap setting.
  * @retval SET (__SWAP__ is valid) or RESET (__SWAP__ is invalid)
  */
#define IS_SMARTCARD_ADVFEATURE_SWAP(__SWAP__) (((__SWAP__) == SMARTCARD_ADVFEATURE_SWAP_DISABLE) || \
                                                ((__SWAP__) == SMARTCARD_ADVFEATURE_SWAP_ENABLE))
stm32l4xx_hal_smartcard.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1118 : 
  * @param __OVERRUN__ SMARTCARD frame overrun setting.
  * @retval SET (__OVERRUN__ is valid) or RESET (__OVERRUN__ is invalid)
  */
#define IS_SMARTCARD_OVERRUN(__OVERRUN__) (((__OVERRUN__) == SMARTCARD_ADVFEATURE_OVERRUN_ENABLE) || \
                                           ((__OVERRUN__) == SMARTCARD_ADVFEATURE_OVERRUN_DISABLE))
stm32l4xx_hal_smartcard.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1125 : 
  * @param __DMA__ SMARTCARD DMA enabling or disabling on error setting.
  * @retval SET (__DMA__ is valid) or RESET (__DMA__ is invalid)
  */
#define IS_SMARTCARD_ADVFEATURE_DMAONRXERROR(__DMA__) (((__DMA__) == SMARTCARD_ADVFEATURE_DMA_ENABLEONRXERROR) || \
                                                       ((__DMA__) == SMARTCARD_ADVFEATURE_DMA_DISABLEONRXERROR))
stm32l4xx_hal_smartcard.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1132 : 
  * @param __MSBFIRST__ SMARTCARD frame MSB first setting.
  * @retval SET (__MSBFIRST__ is valid) or RESET (__MSBFIRST__ is invalid)
  */
#define IS_SMARTCARD_ADVFEATURE_MSBFIRST(__MSBFIRST__) (((__MSBFIRST__) == SMARTCARD_ADVFEATURE_MSBFIRST_DISABLE) || \
                                                        ((__MSBFIRST__) == SMARTCARD_ADVFEATURE_MSBFIRST_ENABLE))
stm32l4xx_hal_smartcard.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1139 : 
  * @param __PARAM__ SMARTCARD request parameter.
  * @retval SET (__PARAM__ is valid) or RESET (__PARAM__ is invalid)
  */
#define IS_SMARTCARD_REQUEST_PARAMETER(__PARAM__) (((__PARAM__) == SMARTCARD_RXDATA_FLUSH_REQUEST) || \
                                                   ((__PARAM__) == SMARTCARD_TXDATA_FLUSH_REQUEST))
stm32l4xx_hal_smartcard_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 271 : 
  * @param __TXCOMPLETE__ SMARTCARD frame transmission completion used flag.
  * @retval SET (__TXCOMPLETE__ is valid) or RESET (__TXCOMPLETE__ is invalid)
  */
#if defined(USART_TCBGT_SUPPORT)
#define IS_SMARTCARD_TRANSMISSION_COMPLETION(__TXCOMPLETE__) (((__TXCOMPLETE__) == SMARTCARD_TCBGT) || \
stm32l4xx_hal_smartcard_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 283 : 
  * @param __STATE__ SMARTCARD FIFO mode.
  * @retval SET (__STATE__ is valid) or RESET (__STATE__ is invalid)
  */
#define IS_SMARTCARD_FIFOMODE_STATE(__STATE__) (((__STATE__) == SMARTCARD_FIFOMODE_DISABLE ) || \
                                                ((__STATE__) == SMARTCARD_FIFOMODE_ENABLE))
stm32l4xx_hal_smartcard_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 290 : 
  * @param __THRESHOLD__ SMARTCARD TXFIFO threshold level.
  * @retval SET (__THRESHOLD__ is valid) or RESET (__THRESHOLD__ is invalid)
  */
#define IS_SMARTCARD_TXFIFO_THRESHOLD(__THRESHOLD__) (((__THRESHOLD__) == SMARTCARD_TXFIFO_THRESHOLD_1_8) || \
                                                      ((__THRESHOLD__) == SMARTCARD_TXFIFO_THRESHOLD_1_4) || \
stm32l4xx_hal_smartcard_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 301 : 
  * @param __THRESHOLD__ SMARTCARD RXFIFO threshold level.
  * @retval SET (__THRESHOLD__ is valid) or RESET (__THRESHOLD__ is invalid)
  */
#define IS_SMARTCARD_RXFIFO_THRESHOLD(__THRESHOLD__) (((__THRESHOLD__) == SMARTCARD_RXFIFO_THRESHOLD_1_8) || \
                                                      ((__THRESHOLD__) == SMARTCARD_RXFIFO_THRESHOLD_1_4) || \
stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 111 : 
    [..]
     Use function @ref HAL_SMBUS_UnRegisterCallback to reset a callback to the default
     weak function.
     @ref HAL_SMBUS_UnRegisterCallback takes as parameters the HAL peripheral handle,
     and the Callback ID.
     This function allows to reset following callbacks:
       (+) MasterTxCpltCallback : callback for Master transmission end of transfer.
       (+) MasterRxCpltCallback : callback for Master reception end of transfer.
       (+) SlaveTxCpltCallback  : callback for Slave transmission end of transfer.
stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 127 : 
    [..]
     By default, after the @ref HAL_SMBUS_Init() and when the state is @ref HAL_I2C_STATE_RESET
     all callbacks are set to the corresponding weak functions:
     examples @ref HAL_SMBUS_MasterTxCpltCallback(), @ref HAL_SMBUS_MasterRxCpltCallback().
     Exception done for MspInit and MspDeInit functions that are
     reset to the legacy weak functions in the @ref HAL_SMBUS_Init()/ @ref HAL_SMBUS_DeInit() only when
     these callbacks are null (not registered beforehand).
     If MspInit or MspDeInit are not null, the @ref HAL_SMBUS_Init()/ @ref HAL_SMBUS_DeInit()
     keep and use the user MspInit/MspDeInit callbacks (registered beforehand) whatever the state.
stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 138 : 
     Exception done MspInit/MspDeInit functions that can be registered/unregistered
     in @ref HAL_I2C_STATE_READY or @ref HAL_I2C_STATE_RESET state,
     thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
     Then, the user first registers the MspInit/MspDeInit user callbacks
     using @ref HAL_SMBUS_RegisterCallback() before calling @ref HAL_SMBUS_DeInit()
HAL_SMBUS_Init in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (hsmbus->State == HAL_SMBUS_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hsmbus->Lock = HAL_UNLOCKED;
HAL_SMBUS_DeInit in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  hsmbus->ErrorCode = HAL_SMBUS_ERROR_NONE;
  hsmbus->PreviousState =  HAL_SMBUS_STATE_RESET;
  hsmbus->State = HAL_SMBUS_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(hsmbus);
HAL_SMBUS_ConfigAnalogFilter in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset ANOFF bit */
    hsmbus->Instance->CR1 &= ~(I2C_CR1_ANFOFF);

    /* Set analog filter bit*/
HAL_SMBUS_ConfigDigitalFilter in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset I2C DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);

    /* Set I2Cx DNF coefficient */
HAL_SMBUS_RegisterCallback in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (HAL_SMBUS_STATE_RESET == hsmbus->State)
  {
    switch (CallbackID)
    {
HAL_SMBUS_UnRegisterCallback in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (HAL_SMBUS_STATE_RESET == hsmbus->State)
  {
    switch (CallbackID)
    {
HAL_SMBUS_Slave_Receive_IT in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* else need to set RELOAD bit mode to generate an automatic ACK at each byte Received */
    /* This RELOAD bit will be reset for last BYTE to be receive in SMBUS_Slave_ISR */
    if (((SMBUS_GET_PEC_MODE(hsmbus) != 0UL) && (hsmbus->XferSize == 2U)) || (hsmbus->XferSize == 1U))
    {
      SMBUS_TransferConfig(hsmbus, 0, (uint8_t)hsmbus->XferSize, hsmbus->XferOptions, SMBUS_NO_STARTSTOP);
HAL_SMBUS_IsDeviceReady in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    if (__HAL_SMBUS_GET_FLAG(hsmbus, SMBUS_FLAG_BUSY) != RESET)
    {
      return HAL_BUSY;
    }
HAL_SMBUS_IsDeviceReady in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

      while ((tmp1 == RESET) && (tmp2 == RESET))
      {
        if (Timeout != HAL_MAX_DELAY)
        {
HAL_SMBUS_IsDeviceReady in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      /* Check if the NACKF flag has not been set */
      if (__HAL_SMBUS_GET_FLAG(hsmbus, SMBUS_FLAG_AF) == RESET)
      {
        /* Wait until STOPF flag is reset */
        if (SMBUS_WaitOnFlagUntilTimeout(hsmbus, SMBUS_FLAG_STOPF, RESET, Timeout) != HAL_OK)
        {
          return HAL_ERROR;
        }
HAL_SMBUS_IsDeviceReady in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      {
        /* Wait until STOPF flag is reset */
        if (SMBUS_WaitOnFlagUntilTimeout(hsmbus, SMBUS_FLAG_STOPF, RESET, Timeout) != HAL_OK)
        {
          return HAL_ERROR;
        }
HAL_SMBUS_IsDeviceReady in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

        /* Wait until STOPF flag is reset */
        if (SMBUS_WaitOnFlagUntilTimeout(hsmbus, SMBUS_FLAG_STOPF, RESET, Timeout) != HAL_OK)
        {
          return HAL_ERROR;
        }
HAL_SMBUS_EV_IRQHandler in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* SMBUS in mode Transmitter ---------------------------------------------------*/
  if ((SMBUS_CHECK_IT_SOURCE(tmpcr1value, (SMBUS_IT_TCI | SMBUS_IT_STOPI | SMBUS_IT_NACKI | SMBUS_IT_TXI)) != RESET) && ((SMBUS_CHECK_FLAG(tmpisrvalue, SMBUS_FLAG_TXIS) != RESET) || (SMBUS_CHECK_FLAG(tmpisrvalue, SMBUS_FLAG_TCR) != RESET) || (SMBUS_CHECK_FLAG(tmpisrvalue, SMBUS_FLAG_TC) != RESET) || (SMBUS_CHECK_FLAG(tmpisrvalue, SMBUS_FLAG_STOPF) != RESET) || (SMBUS_CHECK_FLAG(tmpisrvalue, SMBUS_FLAG_AF) != RESET)))
  {
    /* Slave mode selected */
    if ((hsmbus->State & HAL_SMBUS_STATE_SLAVE_BUSY_TX) == HAL_SMBUS_STATE_SLAVE_BUSY_TX)
HAL_SMBUS_EV_IRQHandler in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* SMBUS in mode Receiver ----------------------------------------------------*/
  if ((SMBUS_CHECK_IT_SOURCE(tmpcr1value, (SMBUS_IT_TCI | SMBUS_IT_STOPI | SMBUS_IT_NACKI | SMBUS_IT_RXI)) != RESET) && ((SMBUS_CHECK_FLAG(tmpisrvalue, SMBUS_FLAG_RXNE) != RESET) || (SMBUS_CHECK_FLAG(tmpisrvalue, SMBUS_FLAG_TCR) != RESET) || (SMBUS_CHECK_FLAG(tmpisrvalue, SMBUS_FLAG_TC) != RESET) || (SMBUS_CHECK_FLAG(tmpisrvalue, SMBUS_FLAG_STOPF) != RESET) || (SMBUS_CHECK_FLAG(tmpisrvalue, SMBUS_FLAG_AF) != RESET)))
  {
    /* Slave mode selected */
    if ((hsmbus->State & HAL_SMBUS_STATE_SLAVE_BUSY_RX) == HAL_SMBUS_STATE_SLAVE_BUSY_RX)
HAL_SMBUS_EV_IRQHandler in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* SMBUS in mode Listener Only --------------------------------------------------*/
  if (((SMBUS_CHECK_IT_SOURCE(tmpcr1value, SMBUS_IT_ADDRI) != RESET) || (SMBUS_CHECK_IT_SOURCE(tmpcr1value, SMBUS_IT_STOPI) != RESET) || (SMBUS_CHECK_IT_SOURCE(tmpcr1value, SMBUS_IT_NACKI) != RESET)) && ((SMBUS_CHECK_FLAG(tmpisrvalue, SMBUS_FLAG_ADDR) != RESET) || (SMBUS_CHECK_FLAG(tmpisrvalue, SMBUS_FLAG_STOPF) != RESET) || (SMBUS_CHECK_FLAG(tmpisrvalue, SMBUS_FLAG_AF) != RESET)))
  {
    if ((hsmbus->State & HAL_SMBUS_STATE_LISTEN) == HAL_SMBUS_STATE_LISTEN)
    {
SMBUS_Master_ISR in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (SMBUS_CHECK_FLAG(StatusFlags, SMBUS_FLAG_AF) != RESET)
  {
    /* Clear NACK Flag */
    __HAL_SMBUS_CLEAR_FLAG(hsmbus, SMBUS_FLAG_AF);
SMBUS_Master_ISR in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (SMBUS_CHECK_FLAG(StatusFlags, SMBUS_FLAG_STOPF) != RESET)
  {
    /* Check and treat errors if errors occurs during STOP process */
    SMBUS_ITErrorHandler(hsmbus);
SMBUS_Master_ISR in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      /* Clear Configuration Register 2 */
      SMBUS_RESET_CR2(hsmbus);

      /* Flush remaining data in Fifo register in case of error occurs before TXEmpty */
      /* Disable the selected SMBUS peripheral */
SMBUS_Master_ISR in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      /* Store Last receive data if any */
      if (SMBUS_CHECK_FLAG(StatusFlags, SMBUS_FLAG_RXNE) != RESET)
      {
        /* Read data from RXDR */
        *hsmbus->pBuffPtr = (uint8_t)(hsmbus->Instance->RXDR);
SMBUS_Master_ISR in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      /* Clear Configuration Register 2 */
      SMBUS_RESET_CR2(hsmbus);

      hsmbus->PreviousState = HAL_SMBUS_STATE_READY;
      hsmbus->State = HAL_SMBUS_STATE_READY;
SMBUS_Master_ISR in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (SMBUS_CHECK_FLAG(StatusFlags, SMBUS_FLAG_RXNE) != RESET)
  {
    /* Read data from RXDR */
    *hsmbus->pBuffPtr = (uint8_t)(hsmbus->Instance->RXDR);
SMBUS_Master_ISR in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (SMBUS_CHECK_FLAG(StatusFlags, SMBUS_FLAG_TXIS) != RESET)
  {
    /* Write data to TXDR */
    hsmbus->Instance->TXDR = *hsmbus->pBuffPtr;
SMBUS_Master_ISR in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (SMBUS_CHECK_FLAG(StatusFlags, SMBUS_FLAG_TCR) != RESET)
  {
    if ((hsmbus->XferCount != 0U) && (hsmbus->XferSize == 0U))
    {
SMBUS_Master_ISR in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (SMBUS_CHECK_FLAG(StatusFlags, SMBUS_FLAG_TC) != RESET)
  {
    if (hsmbus->XferCount == 0U)
    {
SMBUS_Slave_ISR in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (SMBUS_CHECK_FLAG(StatusFlags, SMBUS_FLAG_AF) != RESET)
  {
    /* Check that SMBUS transfer finished */
    /* if yes, normal usecase, a NACK is sent by the HOST when Transfer is finished */
SMBUS_Slave_ISR in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      /* Set HAL State to "Idle" State, mean to LISTEN state */
      /* So reset Slave Busy state */
      hsmbus->PreviousState = hsmbus->State;
      hsmbus->State &= ~((uint32_t)HAL_SMBUS_STATE_SLAVE_BUSY_TX);
      hsmbus->State &= ~((uint32_t)HAL_SMBUS_STATE_SLAVE_BUSY_RX);
SMBUS_Slave_ISR in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (SMBUS_CHECK_FLAG(StatusFlags, SMBUS_FLAG_ADDR) != RESET)
  {
    TransferDirection = (uint8_t)(SMBUS_GET_DIR(hsmbus));
    SlaveAddrCode = (uint16_t)(SMBUS_GET_ADDR_MATCH(hsmbus));
SMBUS_Slave_ISR in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if ((SMBUS_CHECK_FLAG(StatusFlags, SMBUS_FLAG_RXNE) != RESET) || (SMBUS_CHECK_FLAG(StatusFlags, SMBUS_FLAG_TCR) != RESET))
  {
    if ((hsmbus->State & HAL_SMBUS_STATE_SLAVE_BUSY_RX) == HAL_SMBUS_STATE_SLAVE_BUSY_RX)
    {
SMBUS_Slave_ISR in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
        /* or only the last Byte of Transfer */
        /* So reset the RELOAD bit mode */
        hsmbus->XferOptions &= ~SMBUS_RELOAD_MODE;
        SMBUS_TransferConfig(hsmbus, 0, 1, hsmbus->XferOptions, SMBUS_NO_STARTSTOP);
      }
SMBUS_Slave_ISR in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (SMBUS_CHECK_FLAG(StatusFlags, SMBUS_FLAG_TXIS) != RESET)
  {
    /* Write data to TXDR only if XferCount not reach "0" */
    /* A TXIS flag can be set, during STOP treatment      */
SMBUS_Slave_ISR in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Check if STOPF is set */
  if (SMBUS_CHECK_FLAG(StatusFlags, SMBUS_FLAG_STOPF) != RESET)
  {
    if ((hsmbus->State & HAL_SMBUS_STATE_LISTEN) == HAL_SMBUS_STATE_LISTEN)
    {
      /* Store Last receive data if any */
      if (__HAL_SMBUS_GET_FLAG(hsmbus, SMBUS_FLAG_RXNE) != RESET)
      {
        /* Read data from RXDR */
        *hsmbus->pBuffPtr = (uint8_t)(hsmbus->Instance->RXDR);
SMBUS_Slave_ISR in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      /* Clear Configuration Register 2 */
      SMBUS_RESET_CR2(hsmbus);

      /* Clear STOP Flag */
      __HAL_SMBUS_CLEAR_FLAG(hsmbus, SMBUS_FLAG_STOPF);
SMBUS_ITErrorHandler in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Do not Reset the HAL state in case of ALERT error */
    if ((tmperror & HAL_SMBUS_ERROR_ALERT) != HAL_SMBUS_ERROR_ALERT)
    {
      /* Store current volatile hsmbus->State, misra rule */
SMBUS_ITErrorHandler in stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      {
        /* Reset only HAL_SMBUS_STATE_SLAVE_BUSY_XX */
        /* keep HAL_SMBUS_STATE_LISTEN if set */
        hsmbus->PreviousState = HAL_SMBUS_STATE_READY;
        hsmbus->State = HAL_SMBUS_STATE_LISTEN;
stm32l4xx_hal_smbus.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 2552 : 
  * @param  Flag Specifies the SMBUS flag to check.
  * @param  Status The new Flag status (SET or RESET).
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
stm32l4xx_hal_smbus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 95 : 
  */
#define HAL_SMBUS_STATE_RESET           (0x00000000U)  /*!< SMBUS not yet initialized or disabled         */
#define HAL_SMBUS_STATE_READY           (0x00000001U)  /*!< SMBUS initialized and ready for use           */
#define HAL_SMBUS_STATE_BUSY            (0x00000002U)  /*!< SMBUS internal process is ongoing             */
#define HAL_SMBUS_STATE_MASTER_BUSY_TX  (0x00000012U)  /*!< Master Data Transmission process is ongoing   */
stm32l4xx_hal_smbus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 399 : 

/** @brief  Reset SMBUS handle state.
  * @param  __HANDLE__ specifies the SMBUS Handle.
  * @retval None
  */
#if (USE_HAL_SMBUS_REGISTER_CALLBACKS == 1)
#define __HAL_SMBUS_RESET_HANDLE_STATE(__HANDLE__)           do{                                                   \
                                                                (__HANDLE__)->State = HAL_SMBUS_STATE_RESET;       \
                                                                (__HANDLE__)->MspInitCallback = NULL;            \
                                                                (__HANDLE__)->MspDeInitCallback = NULL;          \
                                                             } while(0)
#else
#define __HAL_SMBUS_RESET_HANDLE_STATE(__HANDLE__)         ((__HANDLE__)->State = HAL_SMBUS_STATE_RESET)
#endif

/** @brief  Enable the specified SMBUS interrupts.
stm32l4xx_hal_smbus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 457 : 
  *
  * @retval The new state of __IT__ (SET or RESET).
  */
#define __HAL_SMBUS_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((((__HANDLE__)->Instance->CR1 & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)

/** @brief  Check whether the specified SMBUS flag is set or not.
  * @param  __HANDLE__ specifies the SMBUS Handle.
stm32l4xx_hal_smbus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 482 : 
  *
  * @retval The new state of __FLAG__ (SET or RESET).
  */
#define SMBUS_FLAG_MASK  (0x0001FFFFU)
#define __HAL_SMBUS_GET_FLAG(__HANDLE__, __FLAG__) (((((__HANDLE__)->Instance->ISR) & ((__FLAG__) & SMBUS_FLAG_MASK)) == ((__FLAG__) & SMBUS_FLAG_MASK)) ? SET : RESET)

/** @brief  Clear the SMBUS pending flags which are cleared by writing 1 in a specific bit.
  * @param  __HANDLE__ specifies the SMBUS Handle.
stm32l4xx_hal_smbus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 597 : 

#define SMBUS_RESET_CR1(__HANDLE__)                       ((__HANDLE__)->Instance->CR1 &= (uint32_t)~((uint32_t)(I2C_CR1_SMBHEN | I2C_CR1_SMBDEN | I2C_CR1_PECEN)))
#define SMBUS_RESET_CR2(__HANDLE__)                       ((__HANDLE__)->Instance->CR2 &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_HEAD10R | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_RD_WRN)))

#define SMBUS_GENERATE_START(__ADDMODE__,__ADDRESS__)     (((__ADDMODE__) == SMBUS_ADDRESSINGMODE_7BIT) ? (uint32_t)((((uint32_t)(__ADDRESS__) & (I2C_CR2_SADD)) | (I2C_CR2_START) | (I2C_CR2_AUTOEND)) & (~I2C_CR2_RD_WRN)) : \
                                                                  (uint32_t)((((uint32_t)(__ADDRESS__) & (I2C_CR2_SADD)) | (I2C_CR2_ADD10) | (I2C_CR2_START)) & (~I2C_CR2_RD_WRN)))
stm32l4xx_hal_smbus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 609 : 

#define SMBUS_CHECK_FLAG(__ISR__, __FLAG__)             ((((__ISR__) & ((__FLAG__) & SMBUS_FLAG_MASK)) == ((__FLAG__) & SMBUS_FLAG_MASK)) ? SET : RESET)
#define SMBUS_CHECK_IT_SOURCE(__CR1__, __IT__)          ((((__CR1__) & (__IT__)) == (__IT__)) ? SET : RESET)

#define IS_SMBUS_OWN_ADDRESS1(ADDRESS1)                         ((ADDRESS1) <= 0x000003FFU)
#define IS_SMBUS_OWN_ADDRESS2(ADDRESS2)                         ((ADDRESS2) <= (uint16_t)0x00FFU)
stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 81 : 

      (#) Use function HAL_SPI_UnRegisterCallback to reset a callback to the default
          weak function.
          HAL_SPI_UnRegisterCallback takes as parameters the HAL peripheral handle,
          and the Callback ID.
          This function allows to reset following callbacks:
            (+) TxCpltCallback        : SPI Tx Completed callback
            (+) RxCpltCallback        : SPI Rx Completed callback
            (+) TxRxCpltCallback      : SPI TxRx Completed callback
stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 97 : 

       By default, after the HAL_SPI_Init() and when the state is HAL_SPI_STATE_RESET
       all callbacks are set to the corresponding weak functions:
       examples HAL_SPI_MasterTxCpltCallback(), HAL_SPI_MasterRxCpltCallback().
       Exception done for MspInit and MspDeInit functions that are
       reset to the legacy weak functions in the HAL_SPI_Init()/ HAL_SPI_DeInit() only when
       these callbacks are null (not registered beforehand).
       If MspInit or MspDeInit are not null, the HAL_SPI_Init()/ HAL_SPI_DeInit()
       keep and use the user MspInit/MspDeInit callbacks (registered beforehand) whatever the state.
stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 108 : 
       Exception done MspInit/MspDeInit functions that can be registered/unregistered
       in HAL_SPI_STATE_READY or HAL_SPI_STATE_RESET state,
       thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
       Then, the user first registers the MspInit/MspDeInit user callbacks
       using HAL_SPI_RegisterCallback() before calling HAL_SPI_DeInit()
HAL_SPI_Init in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (hspi->State == HAL_SPI_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
HAL_SPI_Init in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
#endif /* SPI_I2SCFGR_I2SMOD */

HAL_SPI_DeInit in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
  hspi->State = HAL_SPI_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(hspi);
HAL_SPI_RegisterCallback in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (HAL_SPI_STATE_RESET == hspi->State)
  {
    switch (CallbackID)
    {
HAL_SPI_UnRegisterCallback in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (HAL_SPI_STATE_RESET == hspi->State)
  {
    switch (CallbackID)
    {
HAL_SPI_Transmit in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_SPI_CRC != 0U)
  /* Reset CRC Calculation */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

HAL_SPI_Receive in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_SPI_CRC != 0U)
  /* Reset CRC Calculation */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    SPI_RESET_CRC(hspi);
    /* this is done to handle the CRCNEXT before the latest data */
    hspi->RxXferCount--;
  }
HAL_SPI_TransmitReceive in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_SPI_CRC != 0U)
  /* Reset CRC Calculation */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

HAL_SPI_TransmitReceive in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

      /* Wait until RXNE flag is reset */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
      {
        if (hspi->RxXferCount > 1U)
HAL_SPI_Transmit_IT in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_SPI_CRC != 0U)
  /* Reset CRC Calculation */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

HAL_SPI_Receive_IT in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_SPI_CRC != 0U)
  /* Reset CRC Calculation */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    hspi->CRCSize = 1U;
HAL_SPI_Receive_IT in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    }
    SPI_RESET_CRC(hspi);
  }
  else
  {
HAL_SPI_TransmitReceive_IT in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_SPI_CRC != 0U)
  /* Reset CRC Calculation */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    hspi->CRCSize = 1U;
HAL_SPI_TransmitReceive_IT in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    }
    SPI_RESET_CRC(hspi);
  }
  else
  {
HAL_SPI_Transmit_DMA in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_SPI_CRC != 0U)
  /* Reset CRC Calculation */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

HAL_SPI_Receive_DMA in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_SPI_CRC != 0U)
  /* Reset CRC Calculation */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

HAL_SPI_TransmitReceive_DMA in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_SPI_CRC != 0U)
  /* Reset CRC Calculation */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Reset the threshold bit */
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX | SPI_CR2_LDMARX);

  /* The packing mode management is enabled by the DMA settings according the spi data size */
HAL_SPI_Abort in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  HAL_StatusTypeDef errorcode;
  __IO uint32_t count, resetcount;

  /* Initialized local variable  */
  errorcode = HAL_OK;
  resetcount = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
  count = resetcount;

  /* Clear ERRIE interrupt to avoid error interrupts generation during Abort procedure */
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
HAL_SPI_Abort in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    while (hspi->State != HAL_SPI_STATE_ABORT);
    /* Reset Timeout Counter */
    count = resetcount;
  }

  if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE))
HAL_SPI_Abort in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    while (hspi->State != HAL_SPI_STATE_ABORT);
    /* Reset Timeout Counter */
    count = resetcount;
  }

  /* Disable the SPI DMA Tx request if enabled */
HAL_SPI_Abort in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      /* Control the BSY flag */
      if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
      {
        hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
      }
HAL_SPI_Abort in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  /* Reset Tx and Rx transfer counters */
  hspi->RxXferCount = 0U;
  hspi->TxXferCount = 0U;

HAL_SPI_Abort in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Reset errorCode */
    hspi->ErrorCode = HAL_SPI_ERROR_NONE;
  }

HAL_SPI_Abort_IT in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  uint32_t abortcplt ;
  __IO uint32_t count, resetcount;

  /* Initialized local variable  */
  errorcode = HAL_OK;
  abortcplt = 1U;
  resetcount = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
  count = resetcount;

  /* Clear ERRIE interrupt to avoid error interrupts generation during Abort procedure */
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
HAL_SPI_Abort_IT in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    while (hspi->State != HAL_SPI_STATE_ABORT);
    /* Reset Timeout Counter */
    count = resetcount;
  }

  if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE))
HAL_SPI_Abort_IT in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    while (hspi->State != HAL_SPI_STATE_ABORT);
    /* Reset Timeout Counter */
    count = resetcount;
  }

  /* If DMA Tx and/or DMA Rx Handles are associated to SPI Handle, DMA Abort complete callbacks should be initialised
HAL_SPI_Abort_IT in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Reset Tx and Rx transfer counters */
    hspi->RxXferCount = 0U;
    hspi->TxXferCount = 0U;

HAL_SPI_Abort_IT in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    {
      /* Reset errorCode */
      hspi->ErrorCode = HAL_SPI_ERROR_NONE;
    }

HAL_SPI_IRQHandler in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* SPI in mode Receiver ----------------------------------------------------*/
  if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) == RESET) &&
      (SPI_CHECK_FLAG(itflag, SPI_FLAG_RXNE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_RXNE) != RESET))
  {
    hspi->RxISR(hspi);
    return;
HAL_SPI_IRQHandler in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* SPI in mode Transmitter -------------------------------------------------*/
  if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_TXE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_TXE) != RESET))
  {
    hspi->TxISR(hspi);
    return;
HAL_SPI_IRQHandler in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* SPI in Error Treatment --------------------------------------------------*/
  if (((SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_ERR) != RESET))
  {
    /* SPI Overrun error interrupt occurred ----------------------------------*/
    if (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET)
    {
      if (hspi->State != HAL_SPI_STATE_BUSY_TX)
      {
HAL_SPI_IRQHandler in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* SPI Mode Fault error interrupt occurred -------------------------------*/
    if (SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET)
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
      __HAL_SPI_CLEAR_MODFFLAG(hspi);
HAL_SPI_IRQHandler in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* SPI Frame error interrupt occurred ------------------------------------*/
    if (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
      __HAL_SPI_CLEAR_FREFLAG(hspi);
SPI_DMATxAbortCallback in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Reset errorCode */
    hspi->ErrorCode = HAL_SPI_ERROR_NONE;
  }

SPI_DMARxAbortCallback in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Control the BSY flag */
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
  {
    hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
  }
SPI_DMARxAbortCallback in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Reset errorCode */
    hspi->ErrorCode = HAL_SPI_ERROR_NONE;
  }

SPI_WaitFlagStateUntilTimeout in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
{
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
  {
    if (Timeout != HAL_MAX_DELAY)
    {
SPI_WaitFlagStateUntilTimeout in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      {
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
        on both master and slave sides in order to resynchronize the master
        and slave for their respective CRC calculation */

SPI_WaitFlagStateUntilTimeout in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
        {
          SPI_RESET_CRC(hspi);
        }

        hspi->State = HAL_SPI_STATE_READY;
SPI_WaitFifoStateUntilTimeout in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      {
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
           on both master and slave sides in order to resynchronize the master
           and slave for their respective CRC calculation */

SPI_WaitFifoStateUntilTimeout in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
        {
          SPI_RESET_CRC(hspi);
        }

        hspi->State = HAL_SPI_STATE_READY;
SPI_EndRxTransaction in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Control the BSY flag */
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
SPI_EndRxTxTransaction in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Control the BSY flag */
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
SPI_CloseRxTx_ISR in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Check if CRC error occurred */
  if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
  {
    hspi->State = HAL_SPI_STATE_READY;
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
SPI_CloseRx_ISR in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Check if CRC error occurred */
  if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
    __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
SPI_AbortRx_ISR in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Control the BSY flag */
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
  {
    hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
  }
SPI_AbortTx_ISR in stm32l4xx_hal_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Control the BSY flag */
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
    {
      hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
    }
stm32l4xx_hal_spi.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 102 : 
{
  HAL_SPI_STATE_RESET      = 0x00U,    /*!< Peripheral not Initialized                         */
  HAL_SPI_STATE_READY      = 0x01U,    /*!< Peripheral Initialized and ready for use           */
  HAL_SPI_STATE_BUSY       = 0x02U,    /*!< an internal process is ongoing                     */
  HAL_SPI_STATE_BUSY_TX    = 0x03U,    /*!< Data Transmission process is ongoing               */
stm32l4xx_hal_spi.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 422 : 

/** @brief  Reset SPI handle state.
  * @param  __HANDLE__ specifies the SPI Handle.
  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
  * @retval None
stm32l4xx_hal_spi.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 428 : 
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
#define __HAL_SPI_RESET_HANDLE_STATE(__HANDLE__)                do{                                                  \
                                                                    (__HANDLE__)->State = HAL_SPI_STATE_RESET;       \
                                                                    (__HANDLE__)->MspInitCallback = NULL;            \
                                                                    (__HANDLE__)->MspDeInitCallback = NULL;          \
                                                                  } while(0)
#else
#define __HAL_SPI_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_SPI_STATE_RESET)
#endif

/** @brief  Enable the specified SPI interrupts.
stm32l4xx_hal_spi.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 471 : 
  */
#define __HAL_SPI_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((((__HANDLE__)->Instance->CR2 & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)

/** @brief  Check whether the specified SPI flag is set or not.
  * @param  __HANDLE__ specifies the SPI Handle.
stm32l4xx_hal_spi.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 573 : 

/** @brief  Reset the CRC calculation of the SPI.
  * @param  __HANDLE__ specifies the SPI Handle.
  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
  * @retval None
  */
#define SPI_RESET_CRC(__HANDLE__) do{CLEAR_BIT((__HANDLE__)->Instance->CR1, SPI_CR1_CRCEN);\
                                       SET_BIT((__HANDLE__)->Instance->CR1, SPI_CR1_CRCEN);}while(0U)

/** @brief  Check whether the specified SPI flag is set or not.
stm32l4xx_hal_spi.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 594 : 
  *            @arg SPI_FLAG_FRLVL: SPI fifo reception level
  * @retval SET or RESET.
  */
#define SPI_CHECK_FLAG(__SR__, __FLAG__)         ((((__SR__) & ((__FLAG__) & SPI_FLAG_MASK)) == ((__FLAG__) & SPI_FLAG_MASK)) ? SET : RESET)

/** @brief  Check whether the specified SPI Interrupt is set or not.
  * @param  __CR2__  copy of SPI CR2 regsiter.
stm32l4xx_hal_spi.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 605 : 
  *            @arg SPI_IT_ERR: Error interrupt enable
  * @retval SET or RESET.
  */
#define SPI_CHECK_IT_SOURCE(__CR2__, __INTERRUPT__)      ((((__CR2__) & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)

/** @brief  Checks if SPI Mode parameter is in allowed range.
  * @param  __MODE__ specifies the SPI Mode.
HAL_SRAM_Init in stm32l4xx_hal_sram.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  
  if(hsram->State == HAL_SRAM_STATE_RESET)
  {  
    /* Allocate lock resource and initialize it */
    hsram->Lock = HAL_UNLOCKED;
HAL_SRAM_DeInit in stm32l4xx_hal_sram.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
   
  /* Configure the SRAM registers with their reset values */
  FMC_NORSRAM_DeInit(hsram->Instance, hsram->Extended, hsram->Init.NSBank);

  hsram->State = HAL_SRAM_STATE_RESET;
  
  /* Release Lock */
  __HAL_UNLOCK(hsram);
stm32l4xx_hal_sram.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 49 : 
{
  HAL_SRAM_STATE_RESET     = 0x00U,  /*!< SRAM not yet initialized or disabled           */
  HAL_SRAM_STATE_READY     = 0x01U,  /*!< SRAM initialized and ready for use             */
  HAL_SRAM_STATE_BUSY      = 0x02U,  /*!< SRAM internal process is ongoing               */
  HAL_SRAM_STATE_ERROR     = 0x03U,  /*!< SRAM error state                               */
stm32l4xx_hal_sram.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 85 : 

/** @brief Reset SRAM handle state
  * @param  __HANDLE__ SRAM handle
  * @retval None
  */
#define __HAL_SRAM_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_SRAM_STATE_RESET)

/**
  * @}
stm32l4xx_hal_swpmi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 119 : 
    [..]
    Use function HAL_SWPMI_UnRegisterCallback() to reset a callback to the default
    weak (surcharged) function.
    HAL_SWPMI_UnRegisterCallback() takes as parameters the HAL peripheral handle,
    and the callback ID.
    This function allows to reset following callbacks:
      (+) RxCpltCallback     : SWPMI receive complete.
      (+) RxHalfCpltCallback : SWPMI receive half complete.
      (+) TxCpltCallback     : SWPMI transmit complete.
stm32l4xx_hal_swpmi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 132 : 
    [..]
    By default, after the HAL_SWPMI_Init and if the state is HAL_SWPMI_STATE_RESET
    all callbacks are reset to the corresponding legacy weak (surcharged) functions:
    examples HAL_SWPMI_RxCpltCallback(), HAL_SWPMI_ErrorCallback().
    Exception done for MspInit and MspDeInit callbacks that are respectively
    reset to the legacy weak (surcharged) functions in the HAL_SWPMI_Init
    and HAL_SWPMI_DeInit only when these callbacks are null (not registered beforehand).
    If not, MspInit or MspDeInit are not null, the HAL_SWPMI_Init and HAL_SWPMI_DeInit
    keep and use the user MspInit/MspDeInit callbacks (registered beforehand).
stm32l4xx_hal_swpmi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 143 : 
    Exception done for MspInit/MspDeInit callbacks that can be registered/unregistered
    in READY or RESET state, thus registered (user) MspInit/DeInit callbacks can be used
    during the Init/DeInit.
    In that case first register the MspInit/MspDeInit user callbacks
    using HAL_SWPMI_RegisterCallback before calling @ref HAL_SWPMI_DeInit
HAL_SWPMI_Init in stm32l4xx_hal_swpmi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    if(hswpmi->State == HAL_SWPMI_STATE_RESET)
    {
      /* Allocate lock resource and initialize it */
      hswpmi->Lock = HAL_UNLOCKED;
HAL_SWPMI_Init in stm32l4xx_hal_swpmi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_HAL_SWPMI_REGISTER_CALLBACKS == 1)
      /* Reset callback pointers to the weak predefined callbacks */
      hswpmi->RxCpltCallback     = HAL_SWPMI_RxCpltCallback;
      hswpmi->RxHalfCpltCallback = HAL_SWPMI_RxHalfCpltCallback;
      hswpmi->TxCpltCallback     = HAL_SWPMI_TxCpltCallback;
HAL_SWPMI_DeInit in stm32l4xx_hal_swpmi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    hswpmi->ErrorCode = HAL_SWPMI_ERROR_NONE;
    hswpmi->State = HAL_SWPMI_STATE_RESET;

    /* Release Lock */
    __HAL_UNLOCK(hswpmi);
HAL_SWPMI_RegisterCallback in stm32l4xx_hal_swpmi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    }
    else if(hswpmi->State == HAL_SWPMI_STATE_RESET)
    {
      switch (CallbackID)
      {
HAL_SWPMI_UnRegisterCallback in stm32l4xx_hal_swpmi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if(hswpmi->State == HAL_SWPMI_STATE_RESET)
  {
    switch (CallbackID)
    {
HAL_SWPMI_DisableLoopback in stm32l4xx_hal_swpmi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Make sure the SWPMI interface is not enabled to reset the loopback mode */
  CLEAR_BIT(hswpmi->Instance->CR, SWPMI_CR_SWPACT);

  /* Reset Loopback */
  CLEAR_BIT(hswpmi->Instance->CR, SWPMI_CR_LPBK);

  /* Re-enable SWPMI interface in normal mode */
stm32l4xx_hal_swpmi.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 73 : 
{
  HAL_SWPMI_STATE_RESET             = 0x00,    /*!< Peripheral Reset state                             */
  HAL_SWPMI_STATE_READY             = 0x01,    /*!< Peripheral Initialized and ready for use           */
  HAL_SWPMI_STATE_BUSY              = 0x02,    /*!< an internal process is ongoing                     */
  HAL_SWPMI_STATE_BUSY_TX           = 0x12,    /*!< Data Transmission process is ongoing               */
stm32l4xx_hal_swpmi.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 254 : 

/** @brief Reset SWPMI handle state.
  * @param  __HANDLE__ specifies the SWPMI Handle.
  * @retval None
  */
#if (USE_HAL_SWPMI_REGISTER_CALLBACKS == 1)
#define __HAL_SWPMI_RESET_HANDLE_STATE(__HANDLE__) do{                                            \
                                                     (__HANDLE__)->State = HAL_SWPMI_STATE_RESET; \
                                                     (__HANDLE__)->MspInitCallback = NULL;        \
                                                     (__HANDLE__)->MspDeInitCallback = NULL;      \
                                                   } while(0)
#else
#define __HAL_SWPMI_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_SWPMI_STATE_RESET)
#endif

/**
stm32l4xx_hal_swpmi.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 382 : 
  */
#define __HAL_SWPMI_GET_IT_SOURCE(__HANDLE__, __IT__) ((READ_BIT((__HANDLE__)->Instance->IER, (__IT__)) == (__IT__)) ? SET : RESET)

/**
  * @}
stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 110 : 
  [..]
  Use function @ref HAL_TIM_UnRegisterCallback() to reset a callback to the default
  weak function.
  @ref HAL_TIM_UnRegisterCallback takes as parameters the HAL peripheral handle,
  and the Callback ID.
stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 147 : 
  [..]
By default, after the Init and when the state is HAL_TIM_STATE_RESET
all interrupt callbacks are set to the corresponding weak functions:
  examples @ref HAL_TIM_TriggerCallback(), @ref HAL_TIM_ErrorCallback().

  [..]
  Exception done for MspInit and MspDeInit functions that are reset to the legacy weak
  functionalities in the Init / DeInit only when these callbacks are null
  (not registered beforehand). If not, MspInit or MspDeInit are not null, the Init / DeInit
    keep and use the user MspInit / MspDeInit callbacks(registered beforehand)
stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 160 : 
    Exception done MspInit / MspDeInit that can be registered / unregistered
    in HAL_TIM_STATE_READY or HAL_TIM_STATE_RESET state,
    thus registered(user) MspInit / DeInit callbacks can be used during the Init / DeInit.
  In that case first register the MspInit/MspDeInit user callbacks
      using @ref HAL_TIM_RegisterCallback() before calling DeInit or Init function.
stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 261 : 
  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
  *         requires a timer reset to avoid unexpected direction
  *         due to DIR bit readonly in center aligned mode.
  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
HAL_TIM_Base_Init in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (htim->State == HAL_TIM_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
HAL_TIM_Base_Init in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    /* Reset interrupt callbacks to legacy weak callbacks */
    TIM_ResetCallback(htim);

    if (htim->Base_MspInitCallback == NULL)
    {
HAL_TIM_Base_DeInit in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Change TIM state */
  htim->State = HAL_TIM_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(htim);
stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 593 : 
  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
  *         requires a timer reset to avoid unexpected direction
  *         due to DIR bit readonly in center aligned mode.
  *         Ex: call @ref HAL_TIM_OC_DeInit() before HAL_TIM_OC_Init()
  * @param  htim TIM Output Compare handle
HAL_TIM_OC_Init in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (htim->State == HAL_TIM_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
HAL_TIM_OC_Init in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    /* Reset interrupt callbacks to legacy weak callbacks */
    TIM_ResetCallback(htim);

    if (htim->OC_MspInitCallback == NULL)
    {
HAL_TIM_OC_DeInit in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Change TIM state */
  htim->State = HAL_TIM_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(htim);
HAL_TIM_OC_Start in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
  {
    /* Enable the main output */
    __HAL_TIM_MOE_ENABLE(htim);
HAL_TIM_OC_Stop in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
  {
    /* Disable the Main Output */
    __HAL_TIM_MOE_DISABLE(htim);
HAL_TIM_OC_Start_IT in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
  {
    /* Enable the main output */
    __HAL_TIM_MOE_ENABLE(htim);
HAL_TIM_OC_Stop_IT in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
  {
    /* Disable the Main Output */
    __HAL_TIM_MOE_DISABLE(htim);
HAL_TIM_OC_Start_DMA in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
  {
    /* Enable the main output */
    __HAL_TIM_MOE_ENABLE(htim);
HAL_TIM_OC_Stop_DMA in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
  {
    /* Disable the Main Output */
    __HAL_TIM_MOE_DISABLE(htim);
stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 1170 : 
  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
  *         requires a timer reset to avoid unexpected direction
  *         due to DIR bit readonly in center aligned mode.
  *         Ex: call @ref HAL_TIM_PWM_DeInit() before HAL_TIM_PWM_Init()
  * @param  htim TIM PWM handle
HAL_TIM_PWM_Init in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (htim->State == HAL_TIM_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
HAL_TIM_PWM_Init in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    /* Reset interrupt callbacks to legacy weak callbacks */
    TIM_ResetCallback(htim);

    if (htim->PWM_MspInitCallback == NULL)
    {
HAL_TIM_PWM_DeInit in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Change TIM state */
  htim->State = HAL_TIM_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(htim);
HAL_TIM_PWM_Start in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
  {
    /* Enable the main output */
    __HAL_TIM_MOE_ENABLE(htim);
HAL_TIM_PWM_Stop in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
  {
    /* Disable the Main Output */
    __HAL_TIM_MOE_DISABLE(htim);
HAL_TIM_PWM_Start_IT in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
  {
    /* Enable the main output */
    __HAL_TIM_MOE_ENABLE(htim);
HAL_TIM_PWM_Stop_IT in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
  {
    /* Disable the Main Output */
    __HAL_TIM_MOE_DISABLE(htim);
HAL_TIM_PWM_Start_DMA in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
  {
    /* Enable the main output */
    __HAL_TIM_MOE_ENABLE(htim);
HAL_TIM_PWM_Stop_DMA in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
  {
    /* Disable the Main Output */
    __HAL_TIM_MOE_DISABLE(htim);
stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 1748 : 
  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
  *         requires a timer reset to avoid unexpected direction
  *         due to DIR bit readonly in center aligned mode.
  *         Ex: call @ref HAL_TIM_IC_DeInit() before HAL_TIM_IC_Init()
  * @param  htim TIM Input Capture handle
HAL_TIM_IC_Init in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (htim->State == HAL_TIM_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
HAL_TIM_IC_Init in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    /* Reset interrupt callbacks to legacy weak callbacks */
    TIM_ResetCallback(htim);

    if (htim->IC_MspInitCallback == NULL)
    {
HAL_TIM_IC_DeInit in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Change TIM state */
  htim->State = HAL_TIM_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(htim);
stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 2283 : 
  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
  *         requires a timer reset to avoid unexpected direction
  *         due to DIR bit readonly in center aligned mode.
  *         Ex: call @ref HAL_TIM_OnePulse_DeInit() before HAL_TIM_OnePulse_Init()
  * @param  htim TIM One Pulse handle
HAL_TIM_OnePulse_Init in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (htim->State == HAL_TIM_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
HAL_TIM_OnePulse_Init in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    /* Reset interrupt callbacks to legacy weak callbacks */
    TIM_ResetCallback(htim);

    if (htim->OnePulse_MspInitCallback == NULL)
    {
HAL_TIM_OnePulse_Init in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset the OPM Bit */
  htim->Instance->CR1 &= ~TIM_CR1_OPM;

  /* Configure the OPM Mode */
HAL_TIM_OnePulse_DeInit in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Change TIM state */
  htim->State = HAL_TIM_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(htim);
HAL_TIM_OnePulse_Start in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
  {
    /* Enable the main output */
    __HAL_TIM_MOE_ENABLE(htim);
HAL_TIM_OnePulse_Stop in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
  {
    /* Disable the Main Output */
    __HAL_TIM_MOE_DISABLE(htim);
HAL_TIM_OnePulse_Start_IT in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
  {
    /* Enable the main output */
    __HAL_TIM_MOE_ENABLE(htim);
HAL_TIM_OnePulse_Stop_IT in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
  {
    /* Disable the Main Output */
    __HAL_TIM_MOE_DISABLE(htim);
stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 2596 : 
  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
  *         requires a timer reset to avoid unexpected direction
  *         due to DIR bit readonly in center aligned mode.
  *         Ex: call @ref HAL_TIM_Encoder_DeInit() before HAL_TIM_Encoder_Init()
  * @note   Encoder mode and External clock mode 2 are not compatible and must not be selected together
HAL_TIM_Encoder_Init in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (htim->State == HAL_TIM_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
HAL_TIM_Encoder_Init in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    /* Reset interrupt callbacks to legacy weak callbacks */
    TIM_ResetCallback(htim);

    if (htim->Encoder_MspInitCallback == NULL)
    {
HAL_TIM_Encoder_Init in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset the SMS and ECE bits */
  htim->Instance->SMCR &= ~(TIM_SMCR_SMS | TIM_SMCR_ECE);

  /* Configure the Time base in the Encoder Mode */
HAL_TIM_Encoder_DeInit in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Change TIM state */
  htim->State = HAL_TIM_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(htim);
HAL_TIM_IRQHandler in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Capture compare 1 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
HAL_TIM_IRQHandler in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Capture compare 2 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
HAL_TIM_IRQHandler in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Capture compare 3 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
HAL_TIM_IRQHandler in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Capture compare 4 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
HAL_TIM_IRQHandler in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* TIM Update event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
HAL_TIM_IRQHandler in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* TIM Break input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
HAL_TIM_IRQHandler in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* TIM Break2 input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
HAL_TIM_IRQHandler in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* TIM Trigger detection event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
HAL_TIM_IRQHandler in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* TIM commutation event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
HAL_TIM_IC_ConfigChannel in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset the IC1PSC Bits */
    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;

    /* Set the IC1PSC value */
HAL_TIM_IC_ConfigChannel in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset the IC2PSC Bits */
    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;

    /* Set the IC2PSC value */
HAL_TIM_IC_ConfigChannel in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset the IC3PSC Bits */
    htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;

    /* Set the IC3PSC value */
HAL_TIM_IC_ConfigChannel in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset the IC4PSC Bits */
    htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;

    /* Set the IC4PSC value */
HAL_TIM_OnePulse_ConfigChannel in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

        /* Reset the IC1PSC Bits */
        htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;

        /* Select the Trigger source */
HAL_TIM_OnePulse_ConfigChannel in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

        /* Reset the IC2PSC Bits */
        htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;

        /* Select the Trigger source */
HAL_TIM_ConfigClockSource in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
  tmpsmcr = htim->Instance->SMCR;
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
HAL_TIM_ConfigTI1Input in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset the TI1 selection */
  tmpcr2 &= ~TIM_CR2_TI1S;

  /* Set the TI1 selection */
stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 4791 : 
  *         timer input or external trigger input) and the Slave mode
  *         (Disable, Reset, Gated, Trigger, External clock mode 1).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef *sSlaveConfig)
stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 4831 : 
  *         timer input or external trigger input) and the Slave mode
  *         (Disable, Reset, Gated, Trigger, External clock mode 1).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro_IT(TIM_HandleTypeDef *htim,
HAL_TIM_RegisterCallback in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (htim->State == HAL_TIM_STATE_RESET)
  {
    switch (CallbackID)
    {
HAL_TIM_UnRegisterCallback in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (htim->State == HAL_TIM_STATE_RESET)
  {
    switch (CallbackID)
    {
TIM_OC1_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;

  /* Get the TIMx CCER register value */
TIM_OC1_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
TIM_OC1_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
TIM_OC1_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
  }

TIM_OC1_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
    /* Set the Output Idle state */
TIM_OC2_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;

  /* Get the TIMx CCER register value */
TIM_OC2_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
  tmpccmrx &= ~TIM_CCMR1_CC2S;

TIM_OC2_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4U);
TIM_OC2_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC2NP;
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 4U);
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC2NE;

  }
TIM_OC2_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS2;
    tmpcr2 &= ~TIM_CR2_OIS2N;
    /* Set the Output Idle state */
TIM_OC3_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;

  /* Get the TIMx CCER register value */
TIM_OC3_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;
  /* Select the Output Compare Mode */
TIM_OC3_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
TIM_OC3_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8U);
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
  }

TIM_OC3_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
    /* Set the Output Idle state */
TIM_OC4_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;

  /* Get the TIMx CCER register value */
TIM_OC4_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;

TIM_OC4_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
TIM_OC4_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;

    /* Set the Output Idle state */
TIM_OC5_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC5E;

  /* Get the TIMx CCER register value */
TIM_OC5_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 16U);
TIM_OC5_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS5;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
TIM_OC6_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC6E;

  /* Get the TIMx CCER register value */
TIM_OC6_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);

  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20U);
TIM_OC6_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS6;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
TIM_SlaveTimer_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset the Trigger Selection Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
  /* Set the Input Trigger source */
  tmpsmcr |= sSlaveConfig->InputTrigger;

  /* Reset the slave mode Bits */
  tmpsmcr &= ~TIM_SMCR_SMS;
  /* Set the slave mode */
  tmpsmcr |= sSlaveConfig->SlaveMode;
TIM_SlaveTimer_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

      /* Disable the Channel 1: Reset the CC1E Bit */
      tmpccer = htim->Instance->CCER;
      htim->Instance->CCER &= ~TIM_CCER_CC1E;
      tmpccmr1 = htim->Instance->CCMR1;
TIM_TI1_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
TIM_TI1_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Select the Input */
  if (IS_TIM_CC2_INSTANCE(TIMx) != RESET)
  {
    tmpccmr1 &= ~TIM_CCMR1_CC1S;
    tmpccmr1 |= TIM_ICSelection;
TIM_TI1_ConfigInputStage in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
  TIMx->CCER &= ~TIM_CCER_CC1E;
  tmpccmr1 = TIMx->CCMR1;
TIM_TI2_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
TIM_TI2_ConfigInputStage in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
TIM_TI3_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
  tmpccmr2 = TIMx->CCMR2;
  tmpccer = TIMx->CCER;
TIM_TI4_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
  tmpccmr2 = TIMx->CCMR2;
  tmpccer = TIMx->CCER;
TIM_ITRx_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  tmpsmcr = TIMx->SMCR;
  /* Reset the TS Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
  /* Set the Input Trigger source and the slave mode*/
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
TIM_ETR_SetConfig in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);

  /* Set the Prescaler, the Filter value and the Polarity */
TIM_CCxChannelCmd in stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;

  /* Set or reset the CCxE Bit */
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
}

stm32l4xx_hal_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 6866 : 
/**
  * @brief  Reset interrupt callbacks to the legacy weak callbacks.
  * @param  htim pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
void TIM_ResetCallback(TIM_HandleTypeDef *htim)
{
  /* Reset the TIM callback to the legacy weak callbacks */
  htim->PeriodElapsedCallback             = HAL_TIM_PeriodElapsedCallback;             /* Legacy weak PeriodElapsedCallback             */
  htim->PeriodElapsedHalfCpltCallback     = HAL_TIM_PeriodElapsedHalfCpltCallback;     /* Legacy weak PeriodElapsedHalfCpltCallback     */
  htim->TriggerCallback                   = HAL_TIM_TriggerCallback;                   /* Legacy weak TriggerCallback                   */
{anonTIM_BreakDeadTimeConfigTypeDef} in stm32l4xx_hal_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) : 
  uint32_t AutomaticOutput;      /*!< TIM Automatic Output Enable state
                                      This parameter can be a value of @ref TIM_AOE_Bit_Set_Reset */
} TIM_BreakDeadTimeConfigTypeDef;

/**
stm32l4xx_hal_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 294 : 
{
  HAL_TIM_STATE_RESET             = 0x00U,    /*!< Peripheral not yet initialized or disabled  */
  HAL_TIM_STATE_READY             = 0x01U,    /*!< Peripheral Initialized and ready for use    */
  HAL_TIM_STATE_BUSY              = 0x02U,    /*!< An internal process is ongoing              */
  HAL_TIM_STATE_TIMEOUT           = 0x03U,    /*!< Timeout state                               */
stm32l4xx_hal_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 588 : 
#define TIM_OCIDLESTATE_SET                TIM_CR2_OIS1                         /*!< Output Idle state: OCx=1 when MOE=0 */
#define TIM_OCIDLESTATE_RESET              0x00000000U                          /*!< Output Idle state: OCx=0 when MOE=0 */
/**
  * @}
  */
stm32l4xx_hal_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 597 : 
#define TIM_OCNIDLESTATE_SET               TIM_CR2_OIS1N                        /*!< Complementary output Idle state: OCxN=1 when MOE=0 */
#define TIM_OCNIDLESTATE_RESET             0x00000000U                          /*!< Complementary output Idle state: OCxN=0 when MOE=0 */
/**
  * @}
  */
stm32l4xx_hal_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 853 : 

/** @defgroup TIM_AOE_Bit_Set_Reset TIM Automatic Output Enable
  * @{
  */
#define TIM_AUTOMATICOUTPUT_DISABLE        0x00000000U                          /*!< MOE can be set only by software */
stm32l4xx_hal_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 877 : 
  */
#define TIM_TRGO_RESET            0x00000000U                                      /*!< TIMx_EGR.UG bit is used as trigger output (TRGO)              */
#define TIM_TRGO_ENABLE           TIM_CR2_MMS_0                                    /*!< TIMx_CR1.CEN bit is used as trigger output (TRGO)             */
#define TIM_TRGO_UPDATE           TIM_CR2_MMS_1                                    /*!< Update event is used as trigger output (TRGO)                 */
#define TIM_TRGO_OC1              (TIM_CR2_MMS_1 | TIM_CR2_MMS_0)                  /*!< Capture or a compare match 1 is used as trigger output (TRGO) */
stm32l4xx_hal_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 892 : 
  */
#define TIM_TRGO2_RESET                          0x00000000U                                                         /*!< TIMx_EGR.UG bit is used as trigger output (TRGO2)              */
#define TIM_TRGO2_ENABLE                         TIM_CR2_MMS2_0                                                      /*!< TIMx_CR1.CEN bit is used as trigger output (TRGO2)             */
#define TIM_TRGO2_UPDATE                         TIM_CR2_MMS2_1                                                      /*!< Update event is used as trigger output (TRGO2)                 */
#define TIM_TRGO2_OC1                            (TIM_CR2_MMS2_1 | TIM_CR2_MMS2_0)                                   /*!< Capture or a compare match 1 is used as trigger output (TRGO2) */
stm32l4xx_hal_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 925 : 
#define TIM_SLAVEMODE_DISABLE                0x00000000U                                        /*!< Slave mode disabled           */
#define TIM_SLAVEMODE_RESET                  TIM_SMCR_SMS_2                                     /*!< Reset Mode                    */
#define TIM_SLAVEMODE_GATED                  (TIM_SMCR_SMS_2 | TIM_SMCR_SMS_0)                  /*!< Gated Mode                    */
#define TIM_SLAVEMODE_TRIGGER                (TIM_SMCR_SMS_2 | TIM_SMCR_SMS_1)                  /*!< Trigger Mode                  */
#define TIM_SLAVEMODE_EXTERNAL1              (TIM_SMCR_SMS_2 | TIM_SMCR_SMS_1 | TIM_SMCR_SMS_0) /*!< External Clock Mode 1         */
#define TIM_SLAVEMODE_COMBINED_RESETTRIGGER  TIM_SMCR_SMS_3                                     /*!< Combined reset + trigger mode */
/**
  * @}
  */
stm32l4xx_hal_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1074 : 

/** @brief  Reset TIM handle state.
  * @param  __HANDLE__ TIM handle.
  * @retval None
  */
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
#define __HAL_TIM_RESET_HANDLE_STATE(__HANDLE__) do {                                                        \
                                                      (__HANDLE__)->State             = HAL_TIM_STATE_RESET; \
                                                      (__HANDLE__)->Base_MspInitCallback         = NULL;     \
                                                      (__HANDLE__)->Base_MspDeInitCallback       = NULL;     \
                                                      (__HANDLE__)->IC_MspInitCallback           = NULL;     \
stm32l4xx_hal_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1097 : 
#else
#define __HAL_TIM_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_TIM_STATE_RESET)
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */

/**
stm32l4xx_hal_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1278 : 
  *            @arg TIM_IT_BREAK: Break interrupt
  * @retval The state of TIM_IT (SET or RESET).
  */
#define __HAL_TIM_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((((__HANDLE__)->Instance->DIER & (__INTERRUPT__)) \
                                                             == (__INTERRUPT__)) ? SET : RESET)

/** @brief Clear the TIM interrupt pending bits.
  * @param  __HANDLE__ TIM handle
__HAL_TIM_SET_ICPRESCALER in stm32l4xx_hal_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) : 
  do{                                                    \
    TIM_RESET_ICPRESCALERVALUE((__HANDLE__), (__CHANNEL__));  \
    TIM_SET_ICPRESCALERVALUE((__HANDLE__), (__CHANNEL__), (__ICPSC__)); \
  } while(0)

stm32l4xx_hal_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1486 : 
/**
  * @brief  Reset the TIM Output compare preload.
  * @param  __HANDLE__ TIM handle.
  * @param  __CHANNEL__ TIM Channels to be configured.
  *          This parameter can be one of the following values:
stm32l4xx_hal_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1517 : 
/**
  * @brief  Reset the Update Request Source (URS) bit of the TIMx_CR1 register.
  * @param  __HANDLE__ TIM handle.
  * @note  When the URS bit of the TIMx_CR1 register is reset, any of the
  *        following events generate an update interrupt or DMA request (if
  *        enabled):
  *           _ Counter overflow underflow
__HAL_TIM_SET_CAPTUREPOLARITY in stm32l4xx_hal_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) : 
  do{                                                                     \
    TIM_RESET_CAPTUREPOLARITY((__HANDLE__), (__CHANNEL__));               \
    TIM_SET_CAPTUREPOLARITY((__HANDLE__), (__CHANNEL__), (__POLARITY__)); \
  }while(0)

stm32l4xx_hal_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1626 : 
#define IS_TIM_OCIDLE_STATE(__STATE__)     (((__STATE__) == TIM_OCIDLESTATE_SET) || \
                                            ((__STATE__) == TIM_OCIDLESTATE_RESET))

#define IS_TIM_OCNIDLE_STATE(__STATE__)    (((__STATE__) == TIM_OCNIDLESTATE_SET) || \
                                            ((__STATE__) == TIM_OCNIDLESTATE_RESET))

#define IS_TIM_IC_POLARITY(__POLARITY__)   (((__POLARITY__) == TIM_ICPOLARITY_RISING)   || \
                                            ((__POLARITY__) == TIM_ICPOLARITY_FALLING)  || \
stm32l4xx_hal_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1733 : 

#define IS_TIM_TRGO_SOURCE(__SOURCE__) (((__SOURCE__) == TIM_TRGO_RESET)  || \
                                        ((__SOURCE__) == TIM_TRGO_ENABLE) || \
                                        ((__SOURCE__) == TIM_TRGO_UPDATE) || \
                                        ((__SOURCE__) == TIM_TRGO_OC1)    || \
stm32l4xx_hal_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1742 : 

#define IS_TIM_TRGO2_SOURCE(__SOURCE__) (((__SOURCE__) == TIM_TRGO2_RESET)                        || \
                                         ((__SOURCE__) == TIM_TRGO2_ENABLE)                       || \
                                         ((__SOURCE__) == TIM_TRGO2_UPDATE)                       || \
                                         ((__SOURCE__) == TIM_TRGO2_OC1)                          || \
stm32l4xx_hal_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1764 : 
#define IS_TIM_SLAVE_MODE(__MODE__) (((__MODE__) == TIM_SLAVEMODE_DISABLE)   || \
                                     ((__MODE__) == TIM_SLAVEMODE_RESET)     || \
                                     ((__MODE__) == TIM_SLAVEMODE_GATED)     || \
                                     ((__MODE__) == TIM_SLAVEMODE_TRIGGER)   || \
                                     ((__MODE__) == TIM_SLAVEMODE_EXTERNAL1) || \
                                     ((__MODE__) == TIM_SLAVEMODE_COMBINED_RESETTRIGGER))

#define IS_TIM_PWM_MODE(__MODE__) (((__MODE__) == TIM_OCMODE_PWM1)               || \
                                   ((__MODE__) == TIM_OCMODE_PWM2)               || \
stm32l4xx_hal_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1846 : 
#define IS_TIM_SLAVEMODE_TRIGGER_ENABLED(__TRIGGER__) (((__TRIGGER__) == TIM_SLAVEMODE_TRIGGER) || \
                                                       ((__TRIGGER__) == TIM_SLAVEMODE_COMBINED_RESETTRIGGER))

#define TIM_SET_ICPRESCALERVALUE(__HANDLE__, __CHANNEL__, __ICPSC__) \
  (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 |= (__ICPSC__)) :\
stm32l4xx_hal_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1854 : 

#define TIM_RESET_ICPRESCALERVALUE(__HANDLE__, __CHANNEL__) \
  (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC) :\
   ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC) :\
   ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC) :\
stm32l4xx_hal_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1866 : 

#define TIM_RESET_CAPTUREPOLARITY(__HANDLE__, __CHANNEL__) \
  (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCER &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP)) :\
   ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCER &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP)) :\
   ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCER &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP)) :\
stm32l4xx_hal_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 2118 : 
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
void TIM_ResetCallback(TIM_HandleTypeDef *htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */

/**
stm32l4xx_hal_timebase_tim_template.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 65 : 
  * @note   This function is called  automatically at the beginning of program after
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig(). 
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
stm32l4xx_hal_tim_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 26 : 
        interconnect several timers together.
    (#) Break input to put the timer output signals in reset state or in a known state.
    (#) Supports incremental (quadrature) encoder and hall-sensor circuitry for
        positioning purposes

HAL_TIMEx_HallSensor_Init in stm32l4xx_hal_tim_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (htim->State == HAL_TIM_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
HAL_TIMEx_HallSensor_Init in stm32l4xx_hal_tim_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    /* Reset interrupt callbacks to legacy week callbacks */
    TIM_ResetCallback(htim);

    if (htim->HallSensor_MspInitCallback == NULL)
    {
HAL_TIMEx_HallSensor_Init in stm32l4xx_hal_tim_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset the IC1PSC Bits */
  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
  /* Set the IC1PSC value */
  htim->Instance->CCMR1 |= sConfig->IC1Prescaler;
HAL_TIMEx_HallSensor_Init in stm32l4xx_hal_tim_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Use the TIM_TS_TI1F_ED signal to reset the TIM counter each edge detection */
  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
  htim->Instance->SMCR |= TIM_SLAVEMODE_RESET;

  /* Program channel 2 in PWM 2 mode with the desired Commutation_Delay*/
  OC_Config.OCFastMode = TIM_OCFAST_DISABLE;
  OC_Config.OCIdleState = TIM_OCIDLESTATE_RESET;
  OC_Config.OCMode = TIM_OCMODE_PWM2;
  OC_Config.OCNIdleState = TIM_OCNIDLESTATE_RESET;
  OC_Config.OCNPolarity = TIM_OCNPOLARITY_HIGH;
  OC_Config.OCPolarity = TIM_OCPOLARITY_HIGH;
  OC_Config.Pulse = sConfig->Commutation_Delay;
HAL_TIMEx_HallSensor_DeInit in stm32l4xx_hal_tim_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Change TIM state */
  htim->State = HAL_TIM_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(htim);
HAL_TIMEx_OCN_Stop_IT in stm32l4xx_hal_tim_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  tmpccer = htim->Instance->CCER;
  if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == (uint32_t)RESET)
  {
    __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
  }
HAL_TIMEx_PWMN_Stop_IT in stm32l4xx_hal_tim_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  tmpccer = htim->Instance->CCER;
  if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == (uint32_t)RESET)
  {
    __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
  }
HAL_TIMEx_MasterConfigSynchronization in stm32l4xx_hal_tim_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;

  /* Reset the MSM Bit */
  tmpsmcr &= ~TIM_SMCR_MSM;
  /* Set master mode */
  tmpsmcr |= sMasterConfig->MasterSlaveMode;
TIM_CCxNChannelCmd in stm32l4xx_hal_tim_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset the CCxNE Bit */
  TIMx->CCER &=  ~tmp;

  /* Set or reset the CCxNE Bit */
  TIMx->CCER |= (uint32_t)(ChannelNState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
}
/**
stm32l4xx_hal_tsc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 97 : 
  [..]
     Use function @ref HAL_TSC_UnRegisterCallback to reset a callback to the default
     weak function.
     @ref HAL_TSC_UnRegisterCallback takes as parameters the HAL peripheral handle,
     and the Callback ID.
  [..]
     This function allows to reset following callbacks:
       (+) ConvCpltCallback   : callback for conversion complete process.
       (+) ErrorCallback      : callback for error detection.
       (+) MspInitCallback    : callback for Msp Init.
stm32l4xx_hal_tsc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 109 : 
  [..]
     By default, after the @ref HAL_TSC_Init() and when the state is @ref HAL_TSC_STATE_RESET
     all callbacks are set to the corresponding weak functions:
     examples @ref HAL_TSC_ConvCpltCallback(), @ref HAL_TSC_ErrorCallback().
     Exception done for MspInit and MspDeInit functions that are
     reset to the legacy weak functions in the @ref HAL_TSC_Init()/ @ref HAL_TSC_DeInit() only when
     these callbacks are null (not registered beforehand).
     If MspInit or MspDeInit are not null, the @ref HAL_TSC_Init()/ @ref HAL_TSC_DeInit()
     keep and use the user MspInit/MspDeInit callbacks (registered beforehand) whatever the state.
stm32l4xx_hal_tsc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 121 : 
     Exception done MspInit/MspDeInit functions that can be registered/unregistered
     in @ref HAL_TSC_STATE_READY or @ref HAL_TSC_STATE_RESET state,
     thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
     Then, the user first registers the MspInit/MspDeInit user callbacks
     using @ref HAL_TSC_RegisterCallback() before calling @ref HAL_TSC_DeInit()
HAL_TSC_Init in stm32l4xx_hal_tsc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (htsc->State == HAL_TSC_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    htsc->Lock = HAL_UNLOCKED;
stm32l4xx_hal_tsc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 345 : 
/**
  * @brief  Deinitialize the TSC peripheral registers to their default reset values.
  * @param  htsc TSC handle
  * @retval HAL status
  */
HAL_TSC_DeInit in stm32l4xx_hal_tsc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Change TSC state */
  htsc->State = HAL_TSC_STATE_RESET;

  /* Process unlocked */
  __HAL_UNLOCK(htsc);
HAL_TSC_RegisterCallback in stm32l4xx_hal_tsc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (HAL_TSC_STATE_RESET == htsc->State)
  {
    switch (CallbackID)
    {
HAL_TSC_UnRegisterCallback in stm32l4xx_hal_tsc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (HAL_TSC_STATE_RESET == htsc->State)
  {
    switch (CallbackID)
    {
HAL_TSC_GetState in stm32l4xx_hal_tsc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Check end of acquisition flag */
    if (__HAL_TSC_GET_FLAG(htsc, TSC_FLAG_EOA) != RESET)
    {
      /* Check max count error flag */
      if (__HAL_TSC_GET_FLAG(htsc, TSC_FLAG_MCE) != RESET)
      {
        /* Change TSC state */
        htsc->State = HAL_TSC_STATE_ERROR;
HAL_TSC_IRQHandler in stm32l4xx_hal_tsc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Check if the end of acquisition occurred */
  if (__HAL_TSC_GET_FLAG(htsc, TSC_FLAG_EOA) != RESET)
  {
    /* Clear EOA flag */
    __HAL_TSC_CLEAR_FLAG(htsc, TSC_FLAG_EOA);
HAL_TSC_IRQHandler in stm32l4xx_hal_tsc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Check if max count error occurred */
  if (__HAL_TSC_GET_FLAG(htsc, TSC_FLAG_MCE) != RESET)
  {
    /* Clear MCE flag */
    __HAL_TSC_CLEAR_FLAG(htsc, TSC_FLAG_MCE);
stm32l4xx_hal_tsc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 48 : 
{
  HAL_TSC_STATE_RESET  = 0x00UL, /*!< TSC registers have their reset value */
  HAL_TSC_STATE_READY  = 0x01UL, /*!< TSC registers are initialized or acquisition is completed with success */
  HAL_TSC_STATE_BUSY   = 0x02UL, /*!< TSC initialization or acquisition is on-going */
  HAL_TSC_STATE_ERROR  = 0x03UL  /*!< Acquisition is completed with max count error */
stm32l4xx_hal_tsc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 425 : 

/** @brief Reset TSC handle state.
  * @param  __HANDLE__ TSC handle
  * @retval None
  */
#if (USE_HAL_TSC_REGISTER_CALLBACKS == 1)
#define __HAL_TSC_RESET_HANDLE_STATE(__HANDLE__)                   do{                                                   \
                                                                       (__HANDLE__)->State = HAL_TSC_STATE_RESET;       \
                                                                       (__HANDLE__)->MspInitCallback = NULL;            \
                                                                       (__HANDLE__)->MspDeInitCallback = NULL;          \
                                                                     } while(0)
#else
#define __HAL_TSC_RESET_HANDLE_STATE(__HANDLE__)                   ((__HANDLE__)->State = HAL_TSC_STATE_RESET)
#endif

/**
stm32l4xx_hal_tsc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 514 : 
  * @param  __INTERRUPT__ TSC interrupt
  * @retval SET or RESET
  */
#define __HAL_TSC_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)         ((((__HANDLE__)->Instance->IER & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)

/**
  * @brief Check whether the specified TSC flag is set or not.
stm32l4xx_hal_tsc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 522 : 
  * @param  __FLAG__ TSC flag
  * @retval SET or RESET
  */
#define __HAL_TSC_GET_FLAG(__HANDLE__, __FLAG__)                   ((((__HANDLE__)->Instance->ISR & (__FLAG__)) == (__FLAG__)) ? SET : RESET)

/**
  * @brief Clear the TSC's pending flag.
stm32l4xx_hal_tsc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 617 : 
  * @param  __GX_INDEX__ Group index
  * @retval SET or RESET
  */
#define __HAL_TSC_GET_GROUP_STATUS(__HANDLE__, __GX_INDEX__) \
((((__HANDLE__)->Instance->IOGCSR & (uint32_t)(1UL << (((__GX_INDEX__) & 0xFUL) + 16UL))) == (uint32_t)(1UL << (((__GX_INDEX__) & 0xFUL) + 16UL))) ? TSC_GROUP_COMPLETED : TSC_GROUP_ONGOING)
stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 96 : 
    [..]
    Use function @ref HAL_UART_UnRegisterCallback() to reset a callback to the default
    weak (surcharged) function.
    @ref HAL_UART_UnRegisterCallback() takes as parameters the HAL peripheral handle,
    and the Callback ID.
    This function allows to reset following callbacks:
    (+) TxHalfCpltCallback        : Tx Half Complete Callback.
    (+) TxCpltCallback            : Tx Complete Callback.
    (+) RxHalfCpltCallback        : Rx Half Complete Callback.
stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 116 : 
    [..]
    By default, after the @ref HAL_UART_Init() and when the state is HAL_UART_STATE_RESET
    all callbacks are set to the corresponding weak (surcharged) functions:
    examples @ref HAL_UART_TxCpltCallback(), @ref HAL_UART_RxHalfCpltCallback().
    Exception done for MspInit and MspDeInit functions that are respectively
    reset to the legacy weak (surcharged) functions in the @ref HAL_UART_Init()
    and @ref HAL_UART_DeInit() only when these callbacks are null (not registered beforehand).
    If not, MspInit or MspDeInit are not null, the @ref HAL_UART_Init() and @ref HAL_UART_DeInit()
    keep and use the user MspInit/MspDeInit callbacks (registered beforehand).
stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 128 : 
    Exception done MspInit/MspDeInit that can be registered/unregistered
    in HAL_UART_STATE_READY or HAL_UART_STATE_RESET state, thus registered (user)
    MspInit/DeInit callbacks can be used during the Init/DeInit.
    In that case first register the MspInit/MspDeInit user callbacks
    using @ref HAL_UART_RegisterCallback() before calling @ref HAL_UART_DeInit()
HAL_UART_Init in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (huart->gState == HAL_UART_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
HAL_HalfDuplex_Init in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (huart->gState == HAL_UART_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
HAL_LIN_Init in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (huart->gState == HAL_UART_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
HAL_MultiProcessor_Init in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (huart->gState == HAL_UART_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
HAL_UART_DeInit in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  huart->ErrorCode = HAL_UART_ERROR_NONE;
  huart->gState = HAL_UART_STATE_RESET;
  huart->RxState = HAL_UART_STATE_RESET;

  __HAL_UNLOCK(huart);

HAL_UART_RegisterCallback in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (huart->gState == HAL_UART_STATE_RESET)
  {
    switch (CallbackID)
    {
HAL_UART_UnRegisterCallback in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (HAL_UART_STATE_RESET == huart->gState)
  {
    switch (CallbackID)
    {
HAL_UART_Transmit in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
      {
        return HAL_TIMEOUT;
      }
HAL_UART_Transmit in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
    {
      return HAL_TIMEOUT;
    }
HAL_UART_Receive in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
      {
        return HAL_TIMEOUT;
      }
HAL_UART_Abort in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset Tx and Rx transfer counters */
  huart->TxXferCount = 0U;
  huart->RxXferCount = 0U;

HAL_UART_AbortTransmit in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset Tx transfer counter */
  huart->TxXferCount = 0U;

#if defined(USART_CR1_FIFOEN)
HAL_UART_AbortReceive in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset Rx transfer counter */
  huart->RxXferCount = 0U;

  /* Clear the Error flags in the ICR register */
HAL_UART_Abort_IT in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Reset Tx and Rx transfer counters */
    huart->TxXferCount = 0U;
    huart->RxXferCount = 0U;

HAL_UART_Abort_IT in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset errorCode */
    huart->ErrorCode = HAL_UART_ERROR_NONE;

    /* Clear the Error flags in the ICR register */
HAL_UART_AbortTransmit_IT in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    {
      /* Reset Tx transfer counter */
      huart->TxXferCount = 0U;

      /* Clear TxISR function pointers */
HAL_UART_AbortTransmit_IT in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Reset Tx transfer counter */
    huart->TxXferCount = 0U;

    /* Clear TxISR function pointers */
HAL_UART_AbortReceive_IT in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    {
      /* Reset Rx transfer counter */
      huart->RxXferCount = 0U;

      /* Clear RxISR function pointer */
HAL_UART_AbortReceive_IT in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Reset Rx transfer counter */
    huart->RxXferCount = 0U;

    /* Clear RxISR function pointer */
HAL_UART_IRQHandler in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* UART Rx state is not reset as a reception process might be ongoing.
       If UART handle state fields need to be reset to READY, this could be done in Wakeup callback */

#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    /* Call registered Wakeup Callback */
UART_CheckIdleState in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
UART_CheckIdleState in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 3272 : 
  * @param Flag      Specifies the UART flag to check
  * @param Status    Flag status (SET or RESET)
  * @param Tickstart Tick start value
  * @param Timeout   Timeout duration
  * @retval HAL status
UART_WaitOnFlagUntilTimeout in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
UART_EndRxTransfer in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
}

UART_DMATransmitCplt in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Disable the DMA transfer for transmit request by resetting the DMAT bit
       in the UART CR3 register */
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);

UART_DMAReceiveCplt in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
       in the UART CR3 register */
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);

UART_DMATxAbortCallback in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset errorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;

  /* Clear the Error flags in the ICR register */
UART_DMARxAbortCallback in stm32l4xx_hal_uart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset errorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;

  /* Clear the Error flags in the ICR register */
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 151 : 
  *          b5     Peripheral initialization status
  *             0  : Reset (Peripheral not initialized)
  *             1  : Init done (Peripheral not initialized. HAL UART Init function already called)
  *          b4-b3  (not used)
  *             xx : Should be set to 00
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 168 : 
  *          b5     Peripheral initialization status
  *             0  : Reset (Peripheral not initialized)
  *             1  : Init done (Peripheral not initialized)
  *          b4-b2  (not used)
  *            xxx : Should be set to 000
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 311 : 
  */
#define  HAL_UART_STATE_RESET         0x00000000U    /*!< Peripheral is not initialized
                                                          Value is allowed for gState and RxState */
#define  HAL_UART_STATE_READY         0x00000020U    /*!< Peripheral Initialized and ready for use
                                                          Value is allowed for gState and RxState */
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 813 : 

/** @brief  Reset UART handle states.
  * @param  __HANDLE__ UART handle.
  * @retval None
  */
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
#define __HAL_UART_RESET_HANDLE_STATE(__HANDLE__)  do{                                                   \
                                                       (__HANDLE__)->gState = HAL_UART_STATE_RESET;      \
                                                       (__HANDLE__)->RxState = HAL_UART_STATE_RESET;     \
                                                       (__HANDLE__)->MspInitCallback = NULL;             \
                                                       (__HANDLE__)->MspDeInitCallback = NULL;           \
                                                     } while(0U)
#else
#define __HAL_UART_RESET_HANDLE_STATE(__HANDLE__)  do{                                                   \
                                                       (__HANDLE__)->gState = HAL_UART_STATE_RESET;      \
                                                       (__HANDLE__)->RxState = HAL_UART_STATE_RESET;     \
                                                     } while(0U)
#endif /*USE_HAL_UART_REGISTER_CALLBACKS */

stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1004 : 
  *            @arg @ref UART_IT_ERR   Error interrupt (Frame error, noise error, overrun error)
  * @retval The new state of __INTERRUPT__ (SET or RESET).
  */
#define __HAL_UART_GET_IT(__HANDLE__, __INTERRUPT__) ((((__HANDLE__)->Instance->ISR\
                                                        & (1U << ((__INTERRUPT__)>> 8U))) != RESET) ? SET : RESET)

/** @brief  Check whether the specified UART interrupt source is enabled or not.
  * @param  __HANDLE__ specifies the UART Handle.
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1029 : 
  *            @arg @ref UART_IT_ERR   Error interrupt (Frame error, noise error, overrun error)
  * @retval The new state of __INTERRUPT__ (SET or RESET).
  */
#define __HAL_UART_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((((((((uint8_t)(__INTERRUPT__)) >> 5U) == 1U) ? (__HANDLE__)->Instance->CR1 : \
                                                                (((((uint8_t)(__INTERRUPT__)) >> 5U) == 2U) ? (__HANDLE__)->Instance->CR2 : \
                                                                 (__HANDLE__)->Instance->CR3)) & (1U << (((uint16_t)(__INTERRUPT__)) & UART_IT_MASK)))  != RESET) ? SET : RESET)

/** @brief  Clear the specified UART ISR flag, in setting the proper ICR register flag.
  * @param  __HANDLE__ specifies the UART Handle.
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1242 : 
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval SET (instance is LPUART) or RESET (instance isn't LPUART)
  */
#define UART_INSTANCE_LOWPOWER(__HANDLE__) (IS_LPUART_INSTANCE((__HANDLE__)->Instance))

stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1251 : 
  *          (i.e. 120 MHz on STM32L4Rx/L4Sx, 80 Mhz otherwise)
  * @retval SET (__BAUDRATE__ is valid) or RESET (__BAUDRATE__ is invalid)
  */
#if defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
#define IS_UART_BAUDRATE(__BAUDRATE__) ((__BAUDRATE__) < 15000001U)
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1274 : 
  * @param __STOPBITS__ UART frame number of stop bits.
  * @retval SET (__STOPBITS__ is valid) or RESET (__STOPBITS__ is invalid)
  */
#define IS_UART_STOPBITS(__STOPBITS__) (((__STOPBITS__) == UART_STOPBITS_0_5) || \
                                        ((__STOPBITS__) == UART_STOPBITS_1)   || \
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1284 : 
  * @param __STOPBITS__ LPUART frame number of stop bits.
  * @retval SET (__STOPBITS__ is valid) or RESET (__STOPBITS__ is invalid)
  */
#define IS_LPUART_STOPBITS(__STOPBITS__) (((__STOPBITS__) == UART_STOPBITS_1) || \
                                          ((__STOPBITS__) == UART_STOPBITS_2))
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1292 : 
  * @param __PARITY__ UART frame parity.
  * @retval SET (__PARITY__ is valid) or RESET (__PARITY__ is invalid)
  */
#define IS_UART_PARITY(__PARITY__) (((__PARITY__) == UART_PARITY_NONE) || \
                                    ((__PARITY__) == UART_PARITY_EVEN) || \
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1301 : 
  * @param __CONTROL__ UART hardware flow control.
  * @retval SET (__CONTROL__ is valid) or RESET (__CONTROL__ is invalid)
  */
#define IS_UART_HARDWARE_FLOW_CONTROL(__CONTROL__)\
  (((__CONTROL__) == UART_HWCONTROL_NONE) || \
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1312 : 
  * @param __MODE__ UART communication mode.
  * @retval SET (__MODE__ is valid) or RESET (__MODE__ is invalid)
  */
#define IS_UART_MODE(__MODE__) ((((__MODE__) & (~((uint32_t)(UART_MODE_TX_RX)))) == 0x00U) && ((__MODE__) != 0x00U))

stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1319 : 
  * @param __STATE__ UART state.
  * @retval SET (__STATE__ is valid) or RESET (__STATE__ is invalid)
  */
#define IS_UART_STATE(__STATE__) (((__STATE__) == UART_STATE_DISABLE) || \
                                  ((__STATE__) == UART_STATE_ENABLE))
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1327 : 
  * @param __SAMPLING__ UART oversampling.
  * @retval SET (__SAMPLING__ is valid) or RESET (__SAMPLING__ is invalid)
  */
#define IS_UART_OVERSAMPLING(__SAMPLING__) (((__SAMPLING__) == UART_OVERSAMPLING_16) || \
                                            ((__SAMPLING__) == UART_OVERSAMPLING_8))
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1335 : 
  * @param __ONEBIT__ UART frame sampling.
  * @retval SET (__ONEBIT__ is valid) or RESET (__ONEBIT__ is invalid)
  */
#define IS_UART_ONE_BIT_SAMPLE(__ONEBIT__) (((__ONEBIT__) == UART_ONE_BIT_SAMPLE_DISABLE) || \
                                            ((__ONEBIT__) == UART_ONE_BIT_SAMPLE_ENABLE))
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1343 : 
  * @param __MODE__ UART auto Baud rate detection mode.
  * @retval SET (__MODE__ is valid) or RESET (__MODE__ is invalid)
  */
#define IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(__MODE__)  (((__MODE__) == UART_ADVFEATURE_AUTOBAUDRATE_ONSTARTBIT)    || \
                                                        ((__MODE__) == UART_ADVFEATURE_AUTOBAUDRATE_ONFALLINGEDGE) || \
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1353 : 
  * @param __TIMEOUT__ UART receiver timeout setting.
  * @retval SET (__TIMEOUT__ is valid) or RESET (__TIMEOUT__ is invalid)
  */
#define IS_UART_RECEIVER_TIMEOUT(__TIMEOUT__) (((__TIMEOUT__) == UART_RECEIVER_TIMEOUT_DISABLE) || \
                                               ((__TIMEOUT__) == UART_RECEIVER_TIMEOUT_ENABLE))
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1361 : 
  * @param __LIN__ UART LIN state.
  * @retval SET (__LIN__ is valid) or RESET (__LIN__ is invalid)
  */
#define IS_UART_LIN(__LIN__)        (((__LIN__) == UART_LIN_DISABLE) || \
                                     ((__LIN__) == UART_LIN_ENABLE))
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1369 : 
  * @param __LENGTH__ UART LIN break detection length.
  * @retval SET (__LENGTH__ is valid) or RESET (__LENGTH__ is invalid)
  */
#define IS_UART_LIN_BREAK_DETECT_LENGTH(__LENGTH__) (((__LENGTH__) == UART_LINBREAKDETECTLENGTH_10B) || \
                                                     ((__LENGTH__) == UART_LINBREAKDETECTLENGTH_11B))
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1377 : 
  * @param __DMATX__ UART DMA TX state.
  * @retval SET (__DMATX__ is valid) or RESET (__DMATX__ is invalid)
  */
#define IS_UART_DMA_TX(__DMATX__)     (((__DMATX__) == UART_DMA_TX_DISABLE) || \
                                       ((__DMATX__) == UART_DMA_TX_ENABLE))
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1385 : 
  * @param __DMARX__ UART DMA RX state.
  * @retval SET (__DMARX__ is valid) or RESET (__DMARX__ is invalid)
  */
#define IS_UART_DMA_RX(__DMARX__)     (((__DMARX__) == UART_DMA_RX_DISABLE) || \
                                       ((__DMARX__) == UART_DMA_RX_ENABLE))
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1393 : 
  * @param __HDSEL__ UART half-duplex state.
  * @retval SET (__HDSEL__ is valid) or RESET (__HDSEL__ is invalid)
  */
#define IS_UART_HALF_DUPLEX(__HDSEL__)     (((__HDSEL__) == UART_HALF_DUPLEX_DISABLE) || \
                                            ((__HDSEL__) == UART_HALF_DUPLEX_ENABLE))
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1401 : 
  * @param __WAKEUP__ UART wake-up method .
  * @retval SET (__WAKEUP__ is valid) or RESET (__WAKEUP__ is invalid)
  */
#define IS_UART_WAKEUPMETHOD(__WAKEUP__) (((__WAKEUP__) == UART_WAKEUPMETHOD_IDLELINE) || \
                                          ((__WAKEUP__) == UART_WAKEUPMETHOD_ADDRESSMARK))
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1409 : 
  * @param __PARAM__ UART request parameter.
  * @retval SET (__PARAM__ is valid) or RESET (__PARAM__ is invalid)
  */
#define IS_UART_REQUEST_PARAMETER(__PARAM__) (((__PARAM__) == UART_AUTOBAUD_REQUEST)     || \
                                              ((__PARAM__) == UART_SENDBREAK_REQUEST)    || \
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1420 : 
  * @param __INIT__ UART advanced features initialization.
  * @retval SET (__INIT__ is valid) or RESET (__INIT__ is invalid)
  */
#define IS_UART_ADVFEATURE_INIT(__INIT__)   ((__INIT__) <= (UART_ADVFEATURE_NO_INIT                | \
                                                            UART_ADVFEATURE_TXINVERT_INIT          | \
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1435 : 
  * @param __TXINV__ UART frame TX inversion setting.
  * @retval SET (__TXINV__ is valid) or RESET (__TXINV__ is invalid)
  */
#define IS_UART_ADVFEATURE_TXINV(__TXINV__) (((__TXINV__) == UART_ADVFEATURE_TXINV_DISABLE) || \
                                             ((__TXINV__) == UART_ADVFEATURE_TXINV_ENABLE))
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1443 : 
  * @param __RXINV__ UART frame RX inversion setting.
  * @retval SET (__RXINV__ is valid) or RESET (__RXINV__ is invalid)
  */
#define IS_UART_ADVFEATURE_RXINV(__RXINV__) (((__RXINV__) == UART_ADVFEATURE_RXINV_DISABLE) || \
                                             ((__RXINV__) == UART_ADVFEATURE_RXINV_ENABLE))
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1451 : 
  * @param __DATAINV__ UART frame data inversion setting.
  * @retval SET (__DATAINV__ is valid) or RESET (__DATAINV__ is invalid)
  */
#define IS_UART_ADVFEATURE_DATAINV(__DATAINV__) (((__DATAINV__) == UART_ADVFEATURE_DATAINV_DISABLE) || \
                                                 ((__DATAINV__) == UART_ADVFEATURE_DATAINV_ENABLE))
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1459 : 
  * @param __SWAP__ UART frame RX/TX pins swap setting.
  * @retval SET (__SWAP__ is valid) or RESET (__SWAP__ is invalid)
  */
#define IS_UART_ADVFEATURE_SWAP(__SWAP__) (((__SWAP__) == UART_ADVFEATURE_SWAP_DISABLE) || \
                                           ((__SWAP__) == UART_ADVFEATURE_SWAP_ENABLE))
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1467 : 
  * @param __OVERRUN__ UART frame overrun setting.
  * @retval SET (__OVERRUN__ is valid) or RESET (__OVERRUN__ is invalid)
  */
#define IS_UART_OVERRUN(__OVERRUN__)     (((__OVERRUN__) == UART_ADVFEATURE_OVERRUN_ENABLE) || \
                                          ((__OVERRUN__) == UART_ADVFEATURE_OVERRUN_DISABLE))
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1475 : 
  * @param __AUTOBAUDRATE__ UART auto Baud rate state.
  * @retval SET (__AUTOBAUDRATE__ is valid) or RESET (__AUTOBAUDRATE__ is invalid)
  */
#define IS_UART_ADVFEATURE_AUTOBAUDRATE(__AUTOBAUDRATE__)  (((__AUTOBAUDRATE__) == UART_ADVFEATURE_AUTOBAUDRATE_DISABLE) || \
                                                            ((__AUTOBAUDRATE__) == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE))
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1483 : 
  * @param __DMA__ UART DMA enabling or disabling on error setting.
  * @retval SET (__DMA__ is valid) or RESET (__DMA__ is invalid)
  */
#define IS_UART_ADVFEATURE_DMAONRXERROR(__DMA__)  (((__DMA__) == UART_ADVFEATURE_DMA_ENABLEONRXERROR) || \
                                                   ((__DMA__) == UART_ADVFEATURE_DMA_DISABLEONRXERROR))
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1491 : 
  * @param __MSBFIRST__ UART frame MSB first setting.
  * @retval SET (__MSBFIRST__ is valid) or RESET (__MSBFIRST__ is invalid)
  */
#define IS_UART_ADVFEATURE_MSBFIRST(__MSBFIRST__) (((__MSBFIRST__) == UART_ADVFEATURE_MSBFIRST_DISABLE) || \
                                                   ((__MSBFIRST__) == UART_ADVFEATURE_MSBFIRST_ENABLE))
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1499 : 
  * @param __STOPMODE__ UART stop mode state.
  * @retval SET (__STOPMODE__ is valid) or RESET (__STOPMODE__ is invalid)
  */
#define IS_UART_ADVFEATURE_STOPMODE(__STOPMODE__) (((__STOPMODE__) == UART_ADVFEATURE_STOPMODE_DISABLE) || \
                                                   ((__STOPMODE__) == UART_ADVFEATURE_STOPMODE_ENABLE))
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1507 : 
  * @param __MUTE__ UART mute mode state.
  * @retval SET (__MUTE__ is valid) or RESET (__MUTE__ is invalid)
  */
#define IS_UART_MUTE_MODE(__MUTE__)       (((__MUTE__) == UART_ADVFEATURE_MUTEMODE_DISABLE) || \
                                           ((__MUTE__) == UART_ADVFEATURE_MUTEMODE_ENABLE))
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1515 : 
  * @param __WAKE__ UART wake-up selection.
  * @retval SET (__WAKE__ is valid) or RESET (__WAKE__ is invalid)
  */
#define IS_UART_WAKEUP_SELECTION(__WAKE__) (((__WAKE__) == UART_WAKEUP_ON_ADDRESS)           || \
                                            ((__WAKE__) == UART_WAKEUP_ON_STARTBIT)          || \
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1524 : 
  * @param __POLARITY__ UART driver enable polarity.
  * @retval SET (__POLARITY__ is valid) or RESET (__POLARITY__ is invalid)
  */
#define IS_UART_DE_POLARITY(__POLARITY__)    (((__POLARITY__) == UART_DE_POLARITY_HIGH) || \
                                              ((__POLARITY__) == UART_DE_POLARITY_LOW))
stm32l4xx_hal_uart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1533 : 
  * @param __CLOCKPRESCALER__ UART Prescaler value.
  * @retval SET (__CLOCKPRESCALER__ is valid) or RESET (__CLOCKPRESCALER__ is invalid)
  */
#define IS_UART_PRESCALER(__CLOCKPRESCALER__) (((__CLOCKPRESCALER__) == UART_PRESCALER_DIV1)   || \
                                               ((__CLOCKPRESCALER__) == UART_PRESCALER_DIV2)   || \
HAL_RS485Ex_Init in stm32l4xx_hal_uart_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (huart->gState == HAL_UART_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
HAL_UARTEx_StopModeWakeUpSourceConfig in stm32l4xx_hal_uart_ex.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Wait until REACK flag is set */
  if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
  {
    status = HAL_TIMEOUT;
  }
stm32l4xx_hal_uart_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 673 : 
  * @param __LENGTH__ UART frame length.
  * @retval SET (__LENGTH__ is valid) or RESET (__LENGTH__ is invalid)
  */
#define IS_UART_WORD_LENGTH(__LENGTH__) (((__LENGTH__) == UART_WORDLENGTH_7B) || \
                                         ((__LENGTH__) == UART_WORDLENGTH_8B) || \
stm32l4xx_hal_uart_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 682 : 
  * @param __ADDRESS__ UART wake-up address length.
  * @retval SET (__ADDRESS__ is valid) or RESET (__ADDRESS__ is invalid)
  */
#define IS_UART_ADDRESSLENGTH_DETECT(__ADDRESS__) (((__ADDRESS__) == UART_ADDRESS_DETECT_4B) || \
                                                   ((__ADDRESS__) == UART_ADDRESS_DETECT_7B))
stm32l4xx_hal_uart_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 691 : 
  * @param __THRESHOLD__ UART TXFIFO threshold level.
  * @retval SET (__THRESHOLD__ is valid) or RESET (__THRESHOLD__ is invalid)
  */
#define IS_UART_TXFIFO_THRESHOLD(__THRESHOLD__) (((__THRESHOLD__) == UART_TXFIFO_THRESHOLD_1_8) || \
                                                 ((__THRESHOLD__) == UART_TXFIFO_THRESHOLD_1_4) || \
stm32l4xx_hal_uart_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 703 : 
  * @param __THRESHOLD__ UART RXFIFO threshold level.
  * @retval SET (__THRESHOLD__ is valid) or RESET (__THRESHOLD__ is invalid)
  */
#define IS_UART_RXFIFO_THRESHOLD(__THRESHOLD__) (((__THRESHOLD__) == UART_RXFIFO_THRESHOLD_1_8) || \
                                                 ((__THRESHOLD__) == UART_RXFIFO_THRESHOLD_1_4) || \
stm32l4xx_hal_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 80 : 
    [..]
    Use function @ref HAL_USART_UnRegisterCallback() to reset a callback to the default
    weak (surcharged) function.
    @ref HAL_USART_UnRegisterCallback() takes as parameters the HAL peripheral handle,
    and the Callback ID.
    This function allows to reset following callbacks:
    (+) TxHalfCpltCallback        : Tx Half Complete Callback.
    (+) TxCpltCallback            : Tx Complete Callback.
    (+) RxHalfCpltCallback        : Rx Half Complete Callback.
stm32l4xx_hal_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 98 : 
    [..]
    By default, after the @ref HAL_USART_Init() and when the state is HAL_USART_STATE_RESET
    all callbacks are set to the corresponding weak (surcharged) functions:
    examples @ref HAL_USART_TxCpltCallback(), @ref HAL_USART_RxHalfCpltCallback().
    Exception done for MspInit and MspDeInit functions that are respectively
    reset to the legacy weak (surcharged) functions in the @ref HAL_USART_Init()
    and @ref HAL_USART_DeInit() only when these callbacks are null (not registered beforehand).
    If not, MspInit or MspDeInit are not null, the @ref HAL_USART_Init() and @ref HAL_USART_DeInit()
    keep and use the user MspInit/MspDeInit callbacks (registered beforehand).
stm32l4xx_hal_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 110 : 
    Exception done MspInit/MspDeInit that can be registered/unregistered
    in HAL_USART_STATE_READY or HAL_USART_STATE_RESET state, thus registered (user)
    MspInit/DeInit callbacks can be used during the Init/DeInit.
    In that case first register the MspInit/MspDeInit user callbacks
    using @ref HAL_USART_RegisterCallback() before calling @ref HAL_USART_DeInit()
HAL_USART_Init in stm32l4xx_hal_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  if (husart->State == HAL_USART_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    husart->Lock = HAL_UNLOCKED;
HAL_USART_DeInit in stm32l4xx_hal_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  husart->ErrorCode = HAL_USART_ERROR_NONE;
  husart->State = HAL_USART_STATE_RESET;

  /* Process Unlock */
  __HAL_UNLOCK(husart);
HAL_USART_RegisterCallback in stm32l4xx_hal_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (husart->State == HAL_USART_STATE_RESET)
  {
    switch (CallbackID)
    {
HAL_USART_UnRegisterCallback in stm32l4xx_hal_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  }
  else if (HAL_USART_STATE_RESET == husart->State)
  {
    switch (CallbackID)
    {
HAL_USART_Transmit in stm32l4xx_hal_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    {
      if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
      {
        return HAL_TIMEOUT;
      }
HAL_USART_Transmit in stm32l4xx_hal_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
    {
      return HAL_TIMEOUT;
    }
HAL_USART_Receive in stm32l4xx_hal_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
        * can be written for all the cases. */
        if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
        {
          return HAL_TIMEOUT;
        }
HAL_USART_Receive in stm32l4xx_hal_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      /* Wait for RXNE Flag */
      if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
      {
        return HAL_TIMEOUT;
      }
HAL_USART_TransmitReceive in stm32l4xx_hal_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
      /* Wait until TXE flag is set to send data */
      if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
      {
        return HAL_TIMEOUT;
      }
HAL_USART_TransmitReceive in stm32l4xx_hal_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
        /* Wait until TXE flag is set to send data */
        if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
        {
          return HAL_TIMEOUT;
        }
HAL_USART_TransmitReceive in stm32l4xx_hal_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
        /* Wait for RXNE Flag */
        if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
        {
          return HAL_TIMEOUT;
        }
HAL_USART_Abort in stm32l4xx_hal_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset Tx and Rx transfer counters */
  husart->TxXferCount = 0U;
  husart->RxXferCount = 0U;

HAL_USART_Abort in stm32l4xx_hal_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset Handle ErrorCode to No Error */
  husart->ErrorCode = HAL_USART_ERROR_NONE;

  return HAL_OK;
HAL_USART_Abort_IT in stm32l4xx_hal_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Reset Tx and Rx transfer counters */
    husart->TxXferCount = 0U;
    husart->RxXferCount = 0U;

    /* Reset errorCode */
    husart->ErrorCode = HAL_USART_ERROR_NONE;

    /* Clear the Error flags in the ICR register */
USART_DMATransmitCplt in stm32l4xx_hal_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    {
      /* Disable the DMA transfer for transmit request by resetting the DMAT bit
         in the USART CR3 register */
      CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);

USART_DMAReceiveCplt in stm32l4xx_hal_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Disable the DMA RX transfer for the receiver request by resetting the DMAR bit
       in USART CR3 register */
    CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
    /* similarly, disable the DMA TX transfer that was started to provide the
USART_DMATxAbortCallback in stm32l4xx_hal_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset errorCode */
  husart->ErrorCode = HAL_USART_ERROR_NONE;

  /* Clear the Error flags in the ICR register */
USART_DMARxAbortCallback in stm32l4xx_hal_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset errorCode */
  husart->ErrorCode = HAL_USART_ERROR_NONE;

  /* Clear the Error flags in the ICR register */
stm32l4xx_hal_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 2880 : 
  * @param  Flag Specifies the USART flag to check.
  * @param  Status the Flag status (SET or RESET).
  * @param  Tickstart Tick start value
  * @param  Timeout timeout duration.
  * @retval HAL status
USART_WaitOnFlagUntilTimeout in stm32l4xx_hal_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Wait until flag is set */
  while ((__HAL_USART_GET_FLAG(husart, Flag) ? SET : RESET) == Status)
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
USART_CheckIdleState in stm32l4xx_hal_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Wait until TEACK flag is set */
    if (USART_WaitOnFlagUntilTimeout(husart, USART_ISR_TEACK, RESET, tickstart, USART_TEACK_REACK_TIMEOUT) != HAL_OK)
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
USART_CheckIdleState in stm32l4xx_hal_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* Wait until REACK flag is set */
    if (USART_WaitOnFlagUntilTimeout(husart, USART_ISR_REACK, RESET, tickstart, USART_TEACK_REACK_TIMEOUT) != HAL_OK)
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
stm32l4xx_hal_usart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 93 : 
{
  HAL_USART_STATE_RESET             = 0x00U,    /*!< Peripheral is not initialized                  */
  HAL_USART_STATE_READY             = 0x01U,    /*!< Peripheral Initialized and ready for use       */
  HAL_USART_STATE_BUSY              = 0x02U,    /*!< an internal process is ongoing                 */
  HAL_USART_STATE_BUSY_TX           = 0x12U,    /*!< Data Transmission process is ongoing           */
stm32l4xx_hal_usart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 469 : 

/** @brief Reset USART handle state.
  * @param  __HANDLE__ USART handle.
  * @retval None
  */
#if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
#define __HAL_USART_RESET_HANDLE_STATE(__HANDLE__)  do{                                            \
                                                        (__HANDLE__)->State = HAL_USART_STATE_RESET; \
                                                        (__HANDLE__)->MspInitCallback = NULL;        \
                                                        (__HANDLE__)->MspDeInitCallback = NULL;      \
                                                      } while(0U)
#else
#define __HAL_USART_RESET_HANDLE_STATE(__HANDLE__)  ((__HANDLE__)->State = HAL_USART_STATE_RESET)
#endif /* USE_HAL_USART_REGISTER_CALLBACKS */

/** @brief  Check whether the specified USART flag is set or not.
stm32l4xx_hal_usart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 634 : 
  *            @arg @ref USART_IT_PE    Parity Error interrupt
  * @retval The new state of __INTERRUPT__ (SET or RESET).
  */
#define __HAL_USART_GET_IT(__HANDLE__, __INTERRUPT__) ((((__HANDLE__)->Instance->ISR\
                                                         & ((uint32_t)0x01U << (((__INTERRUPT__) & USART_ISR_MASK)>> USART_ISR_POS))) != 0U) ? SET : RESET)

/** @brief  Check whether the specified USART interrupt source is enabled or not.
  * @param  __HANDLE__ specifies the USART Handle.
stm32l4xx_hal_usart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 657 : 
  *            @arg @ref USART_IT_PE    Parity Error interrupt
  * @retval The new state of __INTERRUPT__ (SET or RESET).
  */
#define __HAL_USART_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((((((((uint8_t)(__INTERRUPT__)) >> 0x05U) == 0x01U) ? (__HANDLE__)->Instance->CR1 : \
                                                                 (((((uint8_t)(__INTERRUPT__)) >> 0x05U) == 0x02U) ? (__HANDLE__)->Instance->CR2 : \
                                                                  (__HANDLE__)->Instance->CR3)) & (0x01U << (((uint16_t)(__INTERRUPT__)) & USART_IT_MASK)))  != 0U) ? SET : RESET)


/** @brief  Clear the specified USART ISR flag, in setting the proper ICR register flag.
stm32l4xx_hal_usart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 765 : 
  *          (i.e. 120 MHz on STM32L4Rx/L4Sx, 80 Mhz otherwise)
  * @retval SET (__BAUDRATE__ is valid) or RESET (__BAUDRATE__ is invalid)
  */
#if defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
#define IS_USART_BAUDRATE(__BAUDRATE__) ((__BAUDRATE__) <= 15000000U)
stm32l4xx_hal_usart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 776 : 
  * @param __STOPBITS__ USART frame number of stop bits.
  * @retval SET (__STOPBITS__ is valid) or RESET (__STOPBITS__ is invalid)
  */
#define IS_USART_STOPBITS(__STOPBITS__) (((__STOPBITS__) == USART_STOPBITS_0_5) || \
                                         ((__STOPBITS__) == USART_STOPBITS_1)   || \
stm32l4xx_hal_usart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 786 : 
  * @param __PARITY__ USART frame parity.
  * @retval SET (__PARITY__ is valid) or RESET (__PARITY__ is invalid)
  */
#define IS_USART_PARITY(__PARITY__) (((__PARITY__) == USART_PARITY_NONE) || \
                                     ((__PARITY__) == USART_PARITY_EVEN) || \
stm32l4xx_hal_usart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 795 : 
  * @param __MODE__ USART communication mode.
  * @retval SET (__MODE__ is valid) or RESET (__MODE__ is invalid)
  */
#define IS_USART_MODE(__MODE__) ((((__MODE__) & 0xFFFFFFF3U) == 0x00U) && ((__MODE__) != 0x00U))

stm32l4xx_hal_usart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 802 : 
  * @param __SAMPLING__ USART oversampling.
  * @retval SET (__SAMPLING__ is valid) or RESET (__SAMPLING__ is invalid)
  */
#define IS_USART_OVERSAMPLING(__SAMPLING__) (((__SAMPLING__) == USART_OVERSAMPLING_16) || \
                                             ((__SAMPLING__) == USART_OVERSAMPLING_8))
stm32l4xx_hal_usart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 810 : 
  * @param __CLOCK__ USART clock state.
  * @retval SET (__CLOCK__ is valid) or RESET (__CLOCK__ is invalid)
  */
#define IS_USART_CLOCK(__CLOCK__) (((__CLOCK__) == USART_CLOCK_DISABLE) || \
                                   ((__CLOCK__) == USART_CLOCK_ENABLE))
stm32l4xx_hal_usart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 818 : 
  * @param __CPOL__ USART frame polarity.
  * @retval SET (__CPOL__ is valid) or RESET (__CPOL__ is invalid)
  */
#define IS_USART_POLARITY(__CPOL__) (((__CPOL__) == USART_POLARITY_LOW) || ((__CPOL__) == USART_POLARITY_HIGH))

stm32l4xx_hal_usart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 825 : 
  * @param __CPHA__ USART frame phase.
  * @retval SET (__CPHA__ is valid) or RESET (__CPHA__ is invalid)
  */
#define IS_USART_PHASE(__CPHA__) (((__CPHA__) == USART_PHASE_1EDGE) || ((__CPHA__) == USART_PHASE_2EDGE))

stm32l4xx_hal_usart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 832 : 
  * @param __LASTBIT__ USART frame last bit clock pulse setting.
  * @retval SET (__LASTBIT__ is valid) or RESET (__LASTBIT__ is invalid)
  */
#define IS_USART_LASTBIT(__LASTBIT__) (((__LASTBIT__) == USART_LASTBIT_DISABLE) || \
                                       ((__LASTBIT__) == USART_LASTBIT_ENABLE))
stm32l4xx_hal_usart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 840 : 
  * @param __PARAM__ USART request parameter.
  * @retval SET (__PARAM__ is valid) or RESET (__PARAM__ is invalid)
  */
#define IS_USART_REQUEST_PARAMETER(__PARAM__) (((__PARAM__) == USART_RXDATA_FLUSH_REQUEST) || \
                                               ((__PARAM__) == USART_TXDATA_FLUSH_REQUEST))
stm32l4xx_hal_usart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 849 : 
  * @param __CLOCKPRESCALER__ USART Prescaler value.
  * @retval SET (__CLOCKPRESCALER__ is valid) or RESET (__CLOCKPRESCALER__ is invalid)
  */
#define IS_USART_PRESCALER(__CLOCKPRESCALER__) (((__CLOCKPRESCALER__) == USART_PRESCALER_DIV1) || \
                                                ((__CLOCKPRESCALER__) == USART_PRESCALER_DIV2) || \
stm32l4xx_hal_usart_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 307 : 
  * @param __LENGTH__ USART frame length.
  * @retval SET (__LENGTH__ is valid) or RESET (__LENGTH__ is invalid)
  */
#define IS_USART_WORD_LENGTH(__LENGTH__) (((__LENGTH__) == USART_WORDLENGTH_7B) || \
                                          ((__LENGTH__) == USART_WORDLENGTH_8B) || \
stm32l4xx_hal_usart_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 317 : 
  * @param __NSS__ USART Negative Slave Select pin management.
  * @retval SET (__NSS__ is valid) or RESET (__NSS__ is invalid)
  */
#define IS_USART_NSS(__NSS__) (((__NSS__) == USART_NSS_HARD) || \
                               ((__NSS__) == USART_NSS_SOFT))
stm32l4xx_hal_usart_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 325 : 
  * @param __STATE__ USART Slave Mode.
  * @retval SET (__STATE__ is valid) or RESET (__STATE__ is invalid)
  */
#define IS_USART_SLAVEMODE(__STATE__)   (((__STATE__) == USART_SLAVEMODE_DISABLE ) || \
                                         ((__STATE__) == USART_SLAVEMODE_ENABLE))
stm32l4xx_hal_usart_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 335 : 
  * @param __STATE__ USART FIFO mode.
  * @retval SET (__STATE__ is valid) or RESET (__STATE__ is invalid)
  */
#define IS_USART_FIFO_MODE_STATE(__STATE__) (((__STATE__) == USART_FIFOMODE_DISABLE ) || \
                                             ((__STATE__) == USART_FIFOMODE_ENABLE))
stm32l4xx_hal_usart_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 343 : 
  * @param __THRESHOLD__ USART TXFIFO threshold level.
  * @retval SET (__THRESHOLD__ is valid) or RESET (__THRESHOLD__ is invalid)
  */
#define IS_USART_TXFIFO_THRESHOLD(__THRESHOLD__)  (((__THRESHOLD__) == USART_TXFIFO_THRESHOLD_1_8)  || \
                                                   ((__THRESHOLD__) == USART_TXFIFO_THRESHOLD_1_4)  || \
stm32l4xx_hal_usart_ex.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 355 : 
  * @param __THRESHOLD__ USART RXFIFO threshold level.
  * @retval SET (__THRESHOLD__ is valid) or RESET (__THRESHOLD__ is invalid)
  */
#define IS_USART_RXFIFO_THRESHOLD(__THRESHOLD__)  (((__THRESHOLD__) == USART_RXFIFO_THRESHOLD_1_8)  || \
                                                   ((__THRESHOLD__) == USART_RXFIFO_THRESHOLD_1_4)  || \
stm32l4xx_hal_wwdg.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 14 : 
  [..]
    Once enabled the WWDG generates a system reset on expiry of a programmed
    time period, unless the program refreshes the counter (T[6;0] downcounter)
    before reaching 0x3F value (i.e. a reset is generated when the counter
    value rolls down from 0x40 to 0x3F).

    (+) An MCU reset is also generated if the counter value is refreshed
        before the counter has reached the refresh window value. This
        implies that the counter must be refreshed in a limited window.
    (+) Once enabled the WWDG cannot be disabled except by a system reset.
    (+) WWDGRST flag in RCC CSR register can be used to inform when a WWDG
        reset occurs.
    (+) The WWDG counter input clock is derived from the APB clock divided
        by a programmable prescaler.
    (+) WWDG clock (Hz) = PCLK1 / (4096 * Prescaler)
stm32l4xx_hal_wwdg.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 35 : 
        (++) Counter min (T[5;0] = 0x00) @80 MHz(PCLK1) with zero prescaler:
             max timeout before reset: ~51.2 
        (++) Counter max (T[5;0] = 0x3F) @80 MHz(PCLK1) with prescaler dividing by 128:
             max timeout before reset: ~26.22 ms

  ==============================================================================
                     ##### How to use this driver #####
stm32l4xx_hal_wwdg.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 50 : 
        When the WWDG is enabled the counter value should be configured to
        a value greater than 0x40 to prevent generating an immediate reset.
    (+) Optionally you can enable the Early Wakeup Interrupt (EWI) which is
        generated when the counter reaches 0x40, and then start the WWDG using
        HAL_WWDG_Start_IT(). At EWI HAL_WWDG_WakeupCallback is executed and user can
        add his own code by customization of callback HAL_WWDG_WakeupCallback.
        Once enabled, EWI interrupt cannot be disabled except by a system reset.
    (+) Then the application program must refresh the WWDG counter at regular
        intervals during normal operation to prevent an MCU reset, using
        HAL_WWDG_Refresh() function. This operation must occur only when
        the counter is lower than the refresh window value already programmed.

stm32l4xx_hal_wwdg.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 75 : 

    (+) Use function @ref HAL_WWDG_UnRegisterCallback() to reset a callback to
    the default weak (surcharged) function. @ref HAL_WWDG_UnRegisterCallback()
    takes as parameters the HAL peripheral handle and the Callback ID.
    This function allows to reset following callbacks:
        (++) EwiCallback : callback for  Early WakeUp Interrupt.
        (++) MspInitCallback : WWDG MspInit.

    When calling @ref HAL_WWDG_Init function, callbacks are reset to the
    corresponding legacy weak (surcharged) functions: 
    @ref HAL_WWDG_EarlyWakeupCallback() and HAL_WWDG_MspInit() only if they have
    not been registered before.
HAL_WWDG_Init in stm32l4xx_hal_wwdg.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if (USE_HAL_WWDG_REGISTER_CALLBACKS == 1)
  /* Reset Callback pointers */
  if(hwwdg->EwiCallback == NULL)
  {
    hwwdg->EwiCallback = HAL_WWDG_EarlyWakeupCallback;
stm32l4xx_hal_wwdg.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 341 : 
  * @note   The Early Wakeup Interrupt (EWI) can be used if specific safety operations
  *         or data logging must be performed before the actual reset is generated.
  *         The EWI interrupt is enabled by calling HAL_WWDG_Init function with
  *         EWIMode set to WWDG_EWI_ENABLE.
  *         When the downcounter reaches the value 0x40, and EWI interrupt is
stm32l4xx_hal_wwdg.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 347 : 
  *         be used to trigger specific actions (such as communications or data
  *         logging), before resetting the device.
  * @param  hwwdg  pointer to a WWDG_HandleTypeDef structure that contains
  *                the configuration information for the specified WWDG module.
  * @retval None
HAL_WWDG_IRQHandler in stm32l4xx_hal_wwdg.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Check if Early Wakeup Interrupt is enable */
  if (__HAL_WWDG_GET_IT_SOURCE(hwwdg, WWDG_IT_EWI) != RESET)
  {
    /* Check if WWDG Early Wakeup Interrupt occurred */
    if (__HAL_WWDG_GET_FLAG(hwwdg, WWDG_FLAG_EWIF) != RESET)
    {
      /* Clear the WWDG Early Wakeup flag */
      __HAL_WWDG_CLEAR_FLAG(hwwdg, WWDG_FLAG_EWIF);
stm32l4xx_hal_wwdg.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 186 : 
  *            @arg WWDG_IT_EWI: Early wakeup interrupt
  * @note   Once enabled this interrupt cannot be disabled except by a system reset.
  * @retval None
  */
#define __HAL_WWDG_ENABLE_IT(__HANDLE__, __INTERRUPT__)       SET_BIT((__HANDLE__)->Instance->CFR, (__INTERRUPT__))
stm32l4xx_hal_wwdg.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 197 : 
  *            @arg WWDG_FLAG_EWIF: Early wakeup interrupt IT
  * @retval The new state of WWDG_FLAG (SET or RESET).
  */
#define __HAL_WWDG_GET_IT(__HANDLE__, __INTERRUPT__)        __HAL_WWDG_GET_FLAG((__HANDLE__),(__INTERRUPT__))

stm32l4xx_hal_wwdg.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 216 : 
  *            @arg WWDG_FLAG_EWIF: Early wakeup interrupt flag
  * @retval The new state of WWDG_FLAG (SET or RESET).
  */
#define __HAL_WWDG_GET_FLAG(__HANDLE__, __FLAG__)           (((__HANDLE__)->Instance->SR & (__FLAG__)) == (__FLAG__))

stm32l4xx_ll_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 295 : 
  * @brief  De-initialize registers of all ADC instances belonging to
  *         the same ADC common instance to their default reset values.
  * @note   This function is performing a hard reset, using high level
  *         clock source RCC ADC reset.
  *         Caution: On this STM32 serie, if several ADC instances are available
  *         on the selected device, RCC ADC reset will reset
  *         all ADC instances belonging to the common ADC instance.
  *         To de-initialize only 1 ADC instance, use
  *         function @ref LL_ADC_DeInit().
LL_ADC_CommonDeInit in stm32l4xx_ll_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Force reset of ADC clock (core clock) */
  LL_AHB2_GRP1_ForceReset(LL_AHB2_GRP1_PERIPH_ADC);
  
  /* Release reset of ADC clock (core clock) */
  LL_AHB2_GRP1_ReleaseReset(LL_AHB2_GRP1_PERIPH_ADC);
  
  return SUCCESS;
}
stm32l4xx_ll_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 437 : 
  * @brief  De-initialize registers of the selected ADC instance
  *         to their default reset values.
  * @note   To reset all ADC instances quickly (perform a hard reset),
  *         use function @ref LL_ADC_CommonDeInit().
  * @note   If this functions returns error status, it means that ADC instance
  *         is in an unknown state.
  *         In this case, perform a hard reset using high level
  *         clock source RCC ADC reset.
  *         Caution: On this STM32 serie, if several ADC instances are available
  *         on the selected device, RCC ADC reset will reset
  *         all ADC instances belonging to the common ADC instance.
  *         Refer to function @ref LL_ADC_CommonDeInit().
  * @param  ADCx ADC instance
LL_ADC_DeInit in stm32l4xx_ll_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* ========== Reset ADC registers ========== */
    /* Reset register IER */
    CLEAR_BIT(ADCx->IER,
              (LL_ADC_IT_ADRDY
               | LL_ADC_IT_EOC
LL_ADC_DeInit in stm32l4xx_ll_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset register ISR */
    SET_BIT(ADCx->ISR,
            (LL_ADC_FLAG_ADRDY
             | LL_ADC_FLAG_EOC
LL_ADC_DeInit in stm32l4xx_ll_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset register CR */
    /*  - Bits ADC_CR_JADSTP, ADC_CR_ADSTP, ADC_CR_JADSTART, ADC_CR_ADSTART,  */
    /*    ADC_CR_ADCAL, ADC_CR_ADDIS, ADC_CR_ADEN are in                      */
    /*    access mode "read-set": no direct reset applicable.                 */
    /*  - Reset Calibration mode to default setting (single ended).           */
    /*  - Disable ADC internal voltage regulator.                             */
    /*  - Enable ADC deep power down.                                         */
    /*    Note: ADC internal voltage regulator disable and ADC deep power     */
LL_ADC_DeInit in stm32l4xx_ll_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset register CFGR */
    MODIFY_REG(ADCx->CFGR,
               (ADC_CFGR_AWD1CH  | ADC_CFGR_JAUTO   | ADC_CFGR_JAWD1EN
                | ADC_CFGR_AWD1EN  | ADC_CFGR_AWD1SGL | ADC_CFGR_JQM
LL_ADC_DeInit in stm32l4xx_ll_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset register CFGR2 */
    CLEAR_BIT(ADCx->CFGR2,
              (ADC_CFGR2_ROVSM  | ADC_CFGR2_TROVS | ADC_CFGR2_OVSS
               | ADC_CFGR2_OVSR   | ADC_CFGR2_JOVSE | ADC_CFGR2_ROVSE)
LL_ADC_DeInit in stm32l4xx_ll_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset register SMPR1 */
    CLEAR_BIT(ADCx->SMPR1,
              (ADC_SMPR1_SMP9 | ADC_SMPR1_SMP8 | ADC_SMPR1_SMP7
               | ADC_SMPR1_SMP6 | ADC_SMPR1_SMP5 | ADC_SMPR1_SMP4
LL_ADC_DeInit in stm32l4xx_ll_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset register SMPR2 */
    CLEAR_BIT(ADCx->SMPR2,
              (ADC_SMPR2_SMP18 | ADC_SMPR2_SMP17 | ADC_SMPR2_SMP16
               | ADC_SMPR2_SMP15 | ADC_SMPR2_SMP14 | ADC_SMPR2_SMP13
LL_ADC_DeInit in stm32l4xx_ll_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset register TR1 */
    MODIFY_REG(ADCx->TR1, ADC_TR1_HT1 | ADC_TR1_LT1, ADC_TR1_HT1);

    /* Reset register TR2 */
    MODIFY_REG(ADCx->TR2, ADC_TR2_HT2 | ADC_TR2_LT2, ADC_TR2_HT2);

    /* Reset register TR3 */
    MODIFY_REG(ADCx->TR3, ADC_TR3_HT3 | ADC_TR3_LT3, ADC_TR3_HT3);

    /* Reset register SQR1 */
    CLEAR_BIT(ADCx->SQR1,
              (ADC_SQR1_SQ4 | ADC_SQR1_SQ3 | ADC_SQR1_SQ2
               | ADC_SQR1_SQ1 | ADC_SQR1_L)
LL_ADC_DeInit in stm32l4xx_ll_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset register SQR2 */
    CLEAR_BIT(ADCx->SQR2,
              (ADC_SQR2_SQ9 | ADC_SQR2_SQ8 | ADC_SQR2_SQ7
               | ADC_SQR2_SQ6 | ADC_SQR2_SQ5)
LL_ADC_DeInit in stm32l4xx_ll_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset register SQR3 */
    CLEAR_BIT(ADCx->SQR3,
              (ADC_SQR3_SQ14 | ADC_SQR3_SQ13 | ADC_SQR3_SQ12
               | ADC_SQR3_SQ11 | ADC_SQR3_SQ10)
LL_ADC_DeInit in stm32l4xx_ll_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset register SQR4 */
    CLEAR_BIT(ADCx->SQR4, ADC_SQR4_SQ16 | ADC_SQR4_SQ15);

    /* Reset register JSQR */
    CLEAR_BIT(ADCx->JSQR,
              (ADC_JSQR_JL
               | ADC_JSQR_JEXTSEL | ADC_JSQR_JEXTEN
LL_ADC_DeInit in stm32l4xx_ll_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset register DR */
    /* Note: bits in access mode read only, no direct reset applicable */

    /* Reset register OFR1 */
    CLEAR_BIT(ADCx->OFR1, ADC_OFR1_OFFSET1_EN | ADC_OFR1_OFFSET1_CH | ADC_OFR1_OFFSET1);
    /* Reset register OFR2 */
    CLEAR_BIT(ADCx->OFR2, ADC_OFR2_OFFSET2_EN | ADC_OFR2_OFFSET2_CH | ADC_OFR2_OFFSET2);
    /* Reset register OFR3 */
    CLEAR_BIT(ADCx->OFR3, ADC_OFR3_OFFSET3_EN | ADC_OFR3_OFFSET3_CH | ADC_OFR3_OFFSET3);
    /* Reset register OFR4 */
    CLEAR_BIT(ADCx->OFR4, ADC_OFR4_OFFSET4_EN | ADC_OFR4_OFFSET4_CH | ADC_OFR4_OFFSET4);
    
    /* Reset registers JDR1, JDR2, JDR3, JDR4 */
    /* Note: bits in access mode read only, no direct reset applicable */

    /* Reset register AWD2CR */
    CLEAR_BIT(ADCx->AWD2CR, ADC_AWD2CR_AWD2CH);

    /* Reset register AWD3CR */
    CLEAR_BIT(ADCx->AWD3CR, ADC_AWD3CR_AWD3CH);

    /* Reset register DIFSEL */
    CLEAR_BIT(ADCx->DIFSEL, ADC_DIFSEL_DIFSEL);

    /* Reset register CALFACT */
    CLEAR_BIT(ADCx->CALFACT, ADC_CALFACT_CALFACT_D | ADC_CALFACT_CALFACT_S);
  }
  else
LL_ADC_DeInit in stm32l4xx_ll_adc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* ADC instance is in an unknown state */
    /* Need to performing a hard reset of ADC instance, using high level      */
    /* clock source RCC ADC reset.                                            */
    /* Caution: On this STM32 serie, if several ADC instances are available   */
    /*          on the selected device, RCC ADC reset will reset              */
    /*          all ADC instances belonging to the common ADC instance.       */
    /* Caution: On this STM32 serie, if several ADC instances are available   */
    /*          on the selected device, RCC ADC reset will reset              */
    /*          all ADC instances belonging to the common ADC instance.       */
    status = ERROR;
  }
stm32l4xx_ll_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 5384 : 
  *         temporary stopped and continued, or resumed from start
  *         (oversampler buffer reset).
  * @note   On this STM32 serie, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
stm32l4xx_ll_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 5414 : 
  *         temporary stopped and continued, or resumed from start
  *         (oversampler buffer reset).
  * @rmtoll CFGR2    ROVSE          LL_ADC_GetOverSamplingScope\n
  *         CFGR2    JOVSE          LL_ADC_GetOverSamplingScope\n
  *         CFGR2    ROVSM          LL_ADC_GetOverSamplingScope
LL_ADC_EnableDeepPowerDown in stm32l4xx_ll_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) : 
{
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
LL_ADC_DisableDeepPowerDown in stm32l4xx_ll_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) : 
{
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
LL_ADC_EnableInternalRegulator in stm32l4xx_ll_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) : 
{
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
LL_ADC_Enable in stm32l4xx_ll_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) : 
{
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
LL_ADC_Disable in stm32l4xx_ll_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) : 
{
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
LL_ADC_StartCalibration in stm32l4xx_ll_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) : 
{
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
LL_ADC_REG_StartConversion in stm32l4xx_ll_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) : 
{
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
LL_ADC_REG_StopConversion in stm32l4xx_ll_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) : 
{
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
LL_ADC_INJ_StartConversion in stm32l4xx_ll_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) : 
{
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
LL_ADC_INJ_StopConversion in stm32l4xx_ll_adc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) : 
{
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
stm32l4xx_ll_bus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 391 : 
/**
  * @brief  Force AHB1 peripherals reset.
  * @rmtoll AHB1RSTR     DMA1RST       LL_AHB1_GRP1_ForceReset\n
  *         AHB1RSTR     DMA2RST       LL_AHB1_GRP1_ForceReset\n
  *         AHB1RSTR     DMAMUX1RST     LL_AHB1_GRP1_ForceReset\n
  *         AHB1RSTR     FLASHRST      LL_AHB1_GRP1_ForceReset\n
  *         AHB1RSTR     CRCRST        LL_AHB1_GRP1_ForceReset\n
  *         AHB1RSTR     TSCRST        LL_AHB1_GRP1_ForceReset\n
  *         AHB1RSTR     DMA2DRST      LL_AHB1_GRP1_ForceReset\n
  *         AHB1RSTR     GFXMMURST     LL_AHB1_GRP1_ForceReset
  * @param  Periphs This parameter can be a combination of the following values:
  *         @arg @ref LL_AHB1_GRP1_PERIPH_ALL
  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMA1
stm32l4xx_ll_bus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 414 : 
*/
__STATIC_INLINE void LL_AHB1_GRP1_ForceReset(uint32_t Periphs)
{
  SET_BIT(RCC->AHB1RSTR, Periphs);
}
stm32l4xx_ll_bus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 420 : 
/**
  * @brief  Release AHB1 peripherals reset.
  * @rmtoll AHB1RSTR     DMA1RST       LL_AHB1_GRP1_ReleaseReset\n
  *         AHB1RSTR     DMA2RST       LL_AHB1_GRP1_ReleaseReset\n
  *         AHB1RSTR     DMAMUX1RST     LL_AHB1_GRP1_ReleaseReset\n
  *         AHB1RSTR     FLASHRST      LL_AHB1_GRP1_ReleaseReset\n
  *         AHB1RSTR     CRCRST        LL_AHB1_GRP1_ReleaseReset\n
  *         AHB1RSTR     TSCRST        LL_AHB1_GRP1_ReleaseReset\n
  *         AHB1RSTR     DMA2DRST      LL_AHB1_GRP1_ReleaseReset\n
  *         AHB1RSTR     GFXMMURST     LL_AHB1_GRP1_ReleaseReset
  * @param  Periphs This parameter can be a combination of the following values:
  *         @arg @ref LL_AHB1_GRP1_PERIPH_ALL
  *         @arg @ref LL_AHB1_GRP1_PERIPH_DMA1
stm32l4xx_ll_bus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 443 : 
*/
__STATIC_INLINE void LL_AHB1_GRP1_ReleaseReset(uint32_t Periphs)
{
  CLEAR_BIT(RCC->AHB1RSTR, Periphs);
}
stm32l4xx_ll_bus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 663 : 
/**
  * @brief  Force AHB2 peripherals reset.
  * @rmtoll AHB2RSTR     GPIOARST      LL_AHB2_GRP1_ForceReset\n
  *         AHB2RSTR     GPIOBRST      LL_AHB2_GRP1_ForceReset\n
  *         AHB2RSTR     GPIOCRST      LL_AHB2_GRP1_ForceReset\n
  *         AHB2RSTR     GPIODRST      LL_AHB2_GRP1_ForceReset\n
  *         AHB2RSTR     GPIOERST      LL_AHB2_GRP1_ForceReset\n
  *         AHB2RSTR     GPIOFRST      LL_AHB2_GRP1_ForceReset\n
  *         AHB2RSTR     GPIOGRST      LL_AHB2_GRP1_ForceReset\n
  *         AHB2RSTR     GPIOHRST      LL_AHB2_GRP1_ForceReset\n
  *         AHB2RSTR     GPIOIRST      LL_AHB2_GRP1_ForceReset\n
  *         AHB2RSTR     OTGFSRST      LL_AHB2_GRP1_ForceReset\n
  *         AHB2RSTR     ADCRST        LL_AHB2_GRP1_ForceReset\n
  *         AHB2RSTR     DCMIRST       LL_AHB2_GRP1_ForceReset\n
  *         AHB2RSTR     AESRST        LL_AHB2_GRP1_ForceReset\n
  *         AHB2RSTR     HASHRST       LL_AHB2_GRP1_ForceReset\n
  *         AHB2RSTR     RNGRST        LL_AHB2_GRP1_ForceReset\n
  *         AHB2RSTR     OSPIMRST      LL_AHB2_GRP1_ForceReset\n
  *         AHB2RSTR     SDMMC1RST     LL_AHB2_GRP1_ForceReset
  * @param  Periphs This parameter can be a combination of the following values:
  *         @arg @ref LL_AHB2_GRP1_PERIPH_ALL
  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOA
stm32l4xx_ll_bus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 704 : 
*/
__STATIC_INLINE void LL_AHB2_GRP1_ForceReset(uint32_t Periphs)
{
  SET_BIT(RCC->AHB2RSTR, Periphs);
}
stm32l4xx_ll_bus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 710 : 
/**
  * @brief  Release AHB2 peripherals reset.
  * @rmtoll AHB2RSTR     GPIOARST      LL_AHB2_GRP1_ReleaseReset\n
  *         AHB2RSTR     GPIOBRST      LL_AHB2_GRP1_ReleaseReset\n
  *         AHB2RSTR     GPIOCRST      LL_AHB2_GRP1_ReleaseReset\n
  *         AHB2RSTR     GPIODRST      LL_AHB2_GRP1_ReleaseReset\n
  *         AHB2RSTR     GPIOERST      LL_AHB2_GRP1_ReleaseReset\n
  *         AHB2RSTR     GPIOFRST      LL_AHB2_GRP1_ReleaseReset\n
  *         AHB2RSTR     GPIOGRST      LL_AHB2_GRP1_ReleaseReset\n
  *         AHB2RSTR     GPIOHRST      LL_AHB2_GRP1_ReleaseReset\n
  *         AHB2RSTR     GPIOIRST      LL_AHB2_GRP1_ReleaseReset\n
  *         AHB2RSTR     OTGFSRST      LL_AHB2_GRP1_ReleaseReset\n
  *         AHB2RSTR     ADCRST        LL_AHB2_GRP1_ReleaseReset\n
  *         AHB2RSTR     DCMIRST       LL_AHB2_GRP1_ReleaseReset\n
  *         AHB2RSTR     AESRST        LL_AHB2_GRP1_ReleaseReset\n
  *         AHB2RSTR     HASHRST       LL_AHB2_GRP1_ReleaseReset\n
  *         AHB2RSTR     RNGRST        LL_AHB2_GRP1_ReleaseReset\n
  *         AHB2RSTR     OSPIMRST      LL_AHB2_GRP1_ReleaseReset\n
  *         AHB2RSTR     SDMMC1RST     LL_AHB2_GRP1_ReleaseReset
  * @param  Periphs This parameter can be a combination of the following values:
  *         @arg @ref LL_AHB2_GRP1_PERIPH_ALL
  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOA
stm32l4xx_ll_bus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 751 : 
*/
__STATIC_INLINE void LL_AHB2_GRP1_ReleaseReset(uint32_t Periphs)
{
  CLEAR_BIT(RCC->AHB2RSTR, Periphs);
}
stm32l4xx_ll_bus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 933 : 
/**
  * @brief  Force AHB3 peripherals reset.
  * @rmtoll AHB3RSTR     FMCRST        LL_AHB3_GRP1_ForceReset\n
  *         AHB3RSTR     QSPIRST       LL_AHB3_GRP1_ForceReset\n
  *         AHB3RSTR     OSPI1RST      LL_AHB3_GRP1_ForceReset\n
  *         AHB3RSTR     OSPI2RST      LL_AHB3_GRP1_ForceReset
  * @param  Periphs This parameter can be a combination of the following values:
  *         @arg @ref LL_AHB3_GRP1_PERIPH_ALL
  *         @arg @ref LL_AHB3_GRP1_PERIPH_FMC (*)
stm32l4xx_ll_bus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 948 : 
*/
__STATIC_INLINE void LL_AHB3_GRP1_ForceReset(uint32_t Periphs)
{
  SET_BIT(RCC->AHB3RSTR, Periphs);
}
stm32l4xx_ll_bus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 954 : 
/**
  * @brief  Release AHB3 peripherals reset.
  * @rmtoll AHB3RSTR     FMCRST        LL_AHB3_GRP1_ReleaseReset\n
  *         AHB3RSTR     QSPIRST       LL_AHB3_GRP1_ReleaseReset\n
  *         AHB3RSTR     OSPI1RST      LL_AHB3_GRP1_ReleaseReset\n
  *         AHB3RSTR     OSPI2RST      LL_AHB3_GRP1_ReleaseReset
  * @param  Periphs This parameter can be a combination of the following values:
  *         @arg @ref LL_AHB2_GRP1_PERIPH_ALL
  *         @arg @ref LL_AHB3_GRP1_PERIPH_FMC (*)
stm32l4xx_ll_bus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 969 : 
*/
__STATIC_INLINE void LL_AHB3_GRP1_ReleaseReset(uint32_t Periphs)
{
  CLEAR_BIT(RCC->AHB3RSTR, Periphs);
}
stm32l4xx_ll_bus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1287 : 
/**
  * @brief  Force APB1 peripherals reset.
  * @rmtoll APB1RSTR1    TIM2RST       LL_APB1_GRP1_ForceReset\n
  *         APB1RSTR1    TIM3RST       LL_APB1_GRP1_ForceReset\n
  *         APB1RSTR1    TIM4RST       LL_APB1_GRP1_ForceReset\n
  *         APB1RSTR1    TIM5RST       LL_APB1_GRP1_ForceReset\n
  *         APB1RSTR1    TIM6RST       LL_APB1_GRP1_ForceReset\n
  *         APB1RSTR1    TIM7RST       LL_APB1_GRP1_ForceReset\n
  *         APB1RSTR1    LCDRST        LL_APB1_GRP1_ForceReset\n
  *         APB1RSTR1    SPI2RST       LL_APB1_GRP1_ForceReset\n
  *         APB1RSTR1    SPI3RST       LL_APB1_GRP1_ForceReset\n
  *         APB1RSTR1    USART2RST     LL_APB1_GRP1_ForceReset\n
  *         APB1RSTR1    USART3RST     LL_APB1_GRP1_ForceReset\n
  *         APB1RSTR1    UART4RST      LL_APB1_GRP1_ForceReset\n
  *         APB1RSTR1    UART5RST      LL_APB1_GRP1_ForceReset\n
  *         APB1RSTR1    I2C1RST       LL_APB1_GRP1_ForceReset\n
  *         APB1RSTR1    I2C2RST       LL_APB1_GRP1_ForceReset\n
  *         APB1RSTR1    I2C3RST       LL_APB1_GRP1_ForceReset\n
  *         APB1RSTR1    CRSRST        LL_APB1_GRP1_ForceReset\n
  *         APB1RSTR1    CAN1RST       LL_APB1_GRP1_ForceReset\n
  *         APB1RSTR1    USBFSRST      LL_APB1_GRP1_ForceReset\n
  *         APB1RSTR1    CAN2RST       LL_APB1_GRP1_ForceReset\n
  *         APB1RSTR1    PWRRST        LL_APB1_GRP1_ForceReset\n
  *         APB1RSTR1    DAC1RST       LL_APB1_GRP1_ForceReset\n
  *         APB1RSTR1    OPAMPRST      LL_APB1_GRP1_ForceReset\n
  *         APB1RSTR1    LPTIM1RST     LL_APB1_GRP1_ForceReset
  * @param  Periphs This parameter can be a combination of the following values:
  *         @arg @ref LL_APB1_GRP1_PERIPH_ALL
  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM2
stm32l4xx_ll_bus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1342 : 
*/
__STATIC_INLINE void LL_APB1_GRP1_ForceReset(uint32_t Periphs)
{
  SET_BIT(RCC->APB1RSTR1, Periphs);
}
stm32l4xx_ll_bus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1348 : 
/**
  * @brief  Force APB1 peripherals reset.
  * @rmtoll APB1RSTR2    LPUART1RST    LL_APB1_GRP2_ForceReset\n
  *         APB1RSTR2    I2C4RST       LL_APB1_GRP2_ForceReset\n
  *         APB1RSTR2    SWPMI1RST     LL_APB1_GRP2_ForceReset\n
  *         APB1RSTR2    LPTIM2RST     LL_APB1_GRP2_ForceReset
  * @param  Periphs This parameter can be a combination of the following values:
  *         @arg @ref LL_APB1_GRP2_PERIPH_ALL
  *         @arg @ref LL_APB1_GRP2_PERIPH_LPUART1
stm32l4xx_ll_bus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1363 : 
*/
__STATIC_INLINE void LL_APB1_GRP2_ForceReset(uint32_t Periphs)
{
  SET_BIT(RCC->APB1RSTR2, Periphs);
}
stm32l4xx_ll_bus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1369 : 
/**
  * @brief  Release APB1 peripherals reset.
  * @rmtoll APB1RSTR1    TIM2RST       LL_APB1_GRP1_ReleaseReset\n
  *         APB1RSTR1    TIM3RST       LL_APB1_GRP1_ReleaseReset\n
  *         APB1RSTR1    TIM4RST       LL_APB1_GRP1_ReleaseReset\n
  *         APB1RSTR1    TIM5RST       LL_APB1_GRP1_ReleaseReset\n
  *         APB1RSTR1    TIM6RST       LL_APB1_GRP1_ReleaseReset\n
  *         APB1RSTR1    TIM7RST       LL_APB1_GRP1_ReleaseReset\n
  *         APB1RSTR1    LCDRST        LL_APB1_GRP1_ReleaseReset\n
  *         APB1RSTR1    SPI2RST       LL_APB1_GRP1_ReleaseReset\n
  *         APB1RSTR1    SPI3RST       LL_APB1_GRP1_ReleaseReset\n
  *         APB1RSTR1    USART2RST     LL_APB1_GRP1_ReleaseReset\n
  *         APB1RSTR1    USART3RST     LL_APB1_GRP1_ReleaseReset\n
  *         APB1RSTR1    UART4RST      LL_APB1_GRP1_ReleaseReset\n
  *         APB1RSTR1    UART5RST      LL_APB1_GRP1_ReleaseReset\n
  *         APB1RSTR1    I2C1RST       LL_APB1_GRP1_ReleaseReset\n
  *         APB1RSTR1    I2C2RST       LL_APB1_GRP1_ReleaseReset\n
  *         APB1RSTR1    I2C3RST       LL_APB1_GRP1_ReleaseReset\n
  *         APB1RSTR1    CRSRST        LL_APB1_GRP1_ReleaseReset\n
  *         APB1RSTR1    CAN1RST       LL_APB1_GRP1_ReleaseReset\n
  *         APB1RSTR1    USBFSRST      LL_APB1_GRP1_ReleaseReset\n
  *         APB1RSTR1    CAN2RST       LL_APB1_GRP1_ReleaseReset\n
  *         APB1RSTR1    PWRRST        LL_APB1_GRP1_ReleaseReset\n
  *         APB1RSTR1    DAC1RST       LL_APB1_GRP1_ReleaseReset\n
  *         APB1RSTR1    OPAMPRST      LL_APB1_GRP1_ReleaseReset\n
  *         APB1RSTR1    LPTIM1RST     LL_APB1_GRP1_ReleaseReset
  * @param  Periphs This parameter can be a combination of the following values:
  *         @arg @ref LL_APB1_GRP1_PERIPH_ALL
  *         @arg @ref LL_APB1_GRP1_PERIPH_TIM2
stm32l4xx_ll_bus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1424 : 
*/
__STATIC_INLINE void LL_APB1_GRP1_ReleaseReset(uint32_t Periphs)
{
  CLEAR_BIT(RCC->APB1RSTR1, Periphs);
}
stm32l4xx_ll_bus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1430 : 
/**
  * @brief  Release APB1 peripherals reset.
  * @rmtoll APB1RSTR2    LPUART1RST    LL_APB1_GRP2_ReleaseReset\n
  *         APB1RSTR2    I2C4RST       LL_APB1_GRP2_ReleaseReset\n
  *         APB1RSTR2    SWPMI1RST     LL_APB1_GRP2_ReleaseReset\n
  *         APB1RSTR2    LPTIM2RST     LL_APB1_GRP2_ReleaseReset
  * @param  Periphs This parameter can be a combination of the following values:
  *         @arg @ref LL_APB1_GRP2_PERIPH_ALL
  *         @arg @ref LL_APB1_GRP2_PERIPH_LPUART1
stm32l4xx_ll_bus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1445 : 
*/
__STATIC_INLINE void LL_APB1_GRP2_ReleaseReset(uint32_t Periphs)
{
  CLEAR_BIT(RCC->APB1RSTR2, Periphs);
}
stm32l4xx_ll_bus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1763 : 
/**
  * @brief  Force APB2 peripherals reset.
  * @rmtoll APB2RSTR     SYSCFGRST     LL_APB2_GRP1_ForceReset\n
  *         APB2RSTR     SDMMC1RST     LL_APB2_GRP1_ForceReset\n
  *         APB2RSTR     TIM1RST       LL_APB2_GRP1_ForceReset\n
  *         APB2RSTR     SPI1RST       LL_APB2_GRP1_ForceReset\n
  *         APB2RSTR     TIM8RST       LL_APB2_GRP1_ForceReset\n
  *         APB2RSTR     USART1RST     LL_APB2_GRP1_ForceReset\n
  *         APB2RSTR     TIM15RST      LL_APB2_GRP1_ForceReset\n
  *         APB2RSTR     TIM16RST      LL_APB2_GRP1_ForceReset\n
  *         APB2RSTR     TIM17RST      LL_APB2_GRP1_ForceReset\n
  *         APB2RSTR     SAI1RST       LL_APB2_GRP1_ForceReset\n
  *         APB2RSTR     SAI2RST       LL_APB2_GRP1_ForceReset\n
  *         APB2RSTR     DFSDM1RST     LL_APB2_GRP1_ForceReset\n
  *         APB2RSTR     LTDCRST       LL_APB2_GRP1_ForceReset\n
  *         APB2RSTR     DSIRST        LL_APB2_GRP1_ForceReset
  * @param  Periphs This parameter can be a combination of the following values:
  *         @arg @ref LL_APB2_GRP1_PERIPH_ALL
  *         @arg @ref LL_APB2_GRP1_PERIPH_SYSCFG
stm32l4xx_ll_bus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1798 : 
*/
__STATIC_INLINE void LL_APB2_GRP1_ForceReset(uint32_t Periphs)
{
  SET_BIT(RCC->APB2RSTR, Periphs);
}
stm32l4xx_ll_bus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1804 : 
/**
  * @brief  Release APB2 peripherals reset.
  * @rmtoll APB2RSTR     SYSCFGRST     LL_APB2_GRP1_ReleaseReset\n
  *         APB2RSTR     SDMMC1RST     LL_APB2_GRP1_ReleaseReset\n
  *         APB2RSTR     TIM1RST       LL_APB2_GRP1_ReleaseReset\n
  *         APB2RSTR     SPI1RST       LL_APB2_GRP1_ReleaseReset\n
  *         APB2RSTR     TIM8RST       LL_APB2_GRP1_ReleaseReset\n
  *         APB2RSTR     USART1RST     LL_APB2_GRP1_ReleaseReset\n
  *         APB2RSTR     TIM15RST      LL_APB2_GRP1_ReleaseReset\n
  *         APB2RSTR     TIM16RST      LL_APB2_GRP1_ReleaseReset\n
  *         APB2RSTR     TIM17RST      LL_APB2_GRP1_ReleaseReset\n
  *         APB2RSTR     SAI1RST       LL_APB2_GRP1_ReleaseReset\n
  *         APB2RSTR     SAI2RST       LL_APB2_GRP1_ReleaseReset\n
  *         APB2RSTR     DFSDM1RST     LL_APB2_GRP1_ReleaseReset\n
  *         APB2RSTR     LTDCRST       LL_APB2_GRP1_ReleaseReset\n
  *         APB2RSTR     DSIRST        LL_APB2_GRP1_ReleaseReset
  * @param  Periphs This parameter can be a combination of the following values:
  *         @arg @ref LL_APB2_GRP1_PERIPH_ALL
  *         @arg @ref LL_APB2_GRP1_PERIPH_SYSCFG
stm32l4xx_ll_bus.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1839 : 
*/
__STATIC_INLINE void LL_APB2_GRP1_ReleaseReset(uint32_t Periphs)
{
  CLEAR_BIT(RCC->APB2RSTR, Periphs);
}
stm32l4xx_ll_comp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 184 : 
  * @brief  De-initialize registers of the selected COMP instance
  *         to their default reset values.
  * @note   If comparator is locked, de-initialization by software is
  *         not possible.
  *         The only way to unlock the comparator is a device hardware reset.
  * @param  COMPx COMP instance
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: COMP registers are de-initialized
LL_COMP_DeInit in stm32l4xx_ll_comp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    /* not possible.                                                           */
    /* The only way to unlock the comparator is a device hardware reset.       */
    status = ERROR;
  }

stm32l4xx_ll_comp.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 789 : 
  * @note   Once locked, comparator configuration can be accessed in read-only.
  * @note   The only way to unlock the comparator is a device hardware reset.
  * @rmtoll CSR      LOCK           LL_COMP_Lock
  * @param  COMPx Comparator instance
  * @retval None
stm32l4xx_ll_comp.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 803 : 
  * @note   Once locked, comparator configuration can be accessed in read-only.
  * @note   The only way to unlock the comparator is a device hardware reset.
  * @rmtoll CSR      LOCK           LL_COMP_IsLocked
  * @param  COMPx Comparator instance
  * @retval State of bit (1 or 0).
LL_CRC_DeInit in stm32l4xx_ll_crc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Force CRC reset */
    LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_CRC);

    /* Release CRC reset */
    LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_CRC);
  }
  else
  {
stm32l4xx_ll_crc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 148 : 
/**
  * @brief  Reset the CRC calculation unit.
  * @note   If Programmable Initial CRC value feature
  *         is available, also set the Data Register to the value stored in the
  *         CRC_INIT register, otherwise, reset Data Register to its default value.
  * @rmtoll CR           RESET         LL_CRC_ResetCRCCalculationUnit
  * @param  CRCx CRC Instance
  * @retval None
  */
__STATIC_INLINE void LL_CRC_ResetCRCCalculationUnit(CRC_TypeDef *CRCx)
{
  SET_BIT(CRCx->CR, CRC_CR_RESET);
}

/**
stm32l4xx_ll_crs.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 50 : 
/**
  * @brief  De-Initializes CRS peripheral registers to their default reset values.
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: CRS registers are de-initialized
  *          - ERROR: not applicable
LL_CRS_DeInit in stm32l4xx_ll_crs.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
{
  LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_CRS);
  LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_CRS);

  return  SUCCESS;
}
stm32l4xx_ll_crs.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 125 : 
/**
  * @brief Reset value of the RELOAD field
  * @note The reset value of the RELOAD field corresponds to a target frequency of 48 MHz
  *       and a synchronization signal frequency of 1 kHz (SOF signal from USB)
  */
#define LL_CRS_RELOADVALUE_DEFAULT         ((uint32_t)0xBB7FU)
stm32l4xx_ll_crs.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 132 : 
/**
  * @brief Reset value of Frequency error limit.
  */
#define LL_CRS_ERRORLIMIT_DEFAULT          ((uint32_t)0x22U)

/**
  * @brief Reset value of the HSI48 Calibration field
  * @note The default value is 64 for STM32L412xx/L422xx, 32 otherwise, which corresponds
  *       to the middle of the trimming interval.
  *       The trimming step is around 67 kHz between two consecutive TRIM steps.
stm32l4xx_ll_dac.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 160 : 
  * @brief  De-initialize registers of the selected DAC instance
  *         to their default reset values.
  * @param  DACx DAC instance
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: DAC registers are de-initialized
LL_DAC_DeInit in stm32l4xx_ll_dac.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Force reset of DAC clock */
  LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_DAC1);

  /* Release reset of DAC clock */
  LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_DAC1);

  return SUCCESS;
}
stm32l4xx_ll_dac.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1190 : 
  * @note   Sample time must be set when DAC channel is disabled
  *         or during DAC operation when DAC channel flag BWSTx is reset,
  *         otherwise the setting is ignored.
  *         Check BWSTx flag state using function "LL_DAC_IsActiveFlag_BWSTx()".
  * @rmtoll SHSR1    TSAMPLE1       LL_DAC_SetSampleAndHoldSampleTime\n
stm32l4xx_ll_dma.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 147 : 
/**
  * @brief  De-initialize the DMA registers to their default reset values.
  * @param  DMAx DMAx Instance
  * @param  Channel This parameter can be one of the following values:
  *         @arg @ref LL_DMA_CHANNEL_1
LL_DMA_DeInit in stm32l4xx_ll_dma.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    {
      /* Force reset of DMA clock */
      LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_DMA1);

      /* Release reset of DMA clock */
      LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_DMA1);
    }
#if defined(DMA2)
    else if (DMAx == DMA2)
    {
      /* Force reset of DMA clock */
      LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_DMA2);

      /* Release reset of DMA clock */
      LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_DMA2);
    }
#endif
    else
LL_DMA_DeInit in stm32l4xx_ll_dma.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset DMAx_Channely control register */
    WRITE_REG(tmp->CCR, 0U);

    /* Reset DMAx_Channely remaining bytes register */
    WRITE_REG(tmp->CNDTR, 0U);

    /* Reset DMAx_Channely peripheral address register */
    WRITE_REG(tmp->CPAR, 0U);

    /* Reset DMAx_Channely memory 0 address register */
    WRITE_REG(tmp->CMAR, 0U);

#if defined(DMAMUX1)
    /* Reset Request register field for DMAx Channel */
    LL_DMA_SetPeriphRequest(DMAx, Channel, LL_DMAMUX_REQ_MEM2MEM);
#else
    /* Reset Request register field for DMAx Channel */
    LL_DMA_SetPeriphRequest(DMAx, Channel, LL_DMA_REQUEST_0);
#endif /* DMAMUX1 */

LL_DMA_DeInit in stm32l4xx_ll_dma.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    {
      /* Reset interrupt pending bits for DMAx Channel1 */
      LL_DMA_ClearFlag_GI1(DMAx);
    }
    else if (Channel == LL_DMA_CHANNEL_2)
    {
      /* Reset interrupt pending bits for DMAx Channel2 */
      LL_DMA_ClearFlag_GI2(DMAx);
    }
    else if (Channel == LL_DMA_CHANNEL_3)
    {
      /* Reset interrupt pending bits for DMAx Channel3 */
      LL_DMA_ClearFlag_GI3(DMAx);
    }
    else if (Channel == LL_DMA_CHANNEL_4)
    {
      /* Reset interrupt pending bits for DMAx Channel4 */
      LL_DMA_ClearFlag_GI4(DMAx);
    }
    else if (Channel == LL_DMA_CHANNEL_5)
    {
      /* Reset interrupt pending bits for DMAx Channel5 */
      LL_DMA_ClearFlag_GI5(DMAx);
    }

LL_DMA_DeInit in stm32l4xx_ll_dma.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    {
      /* Reset interrupt pending bits for DMAx Channel6 */
      LL_DMA_ClearFlag_GI6(DMAx);
    }
    else if (Channel == LL_DMA_CHANNEL_7)
    {
      /* Reset interrupt pending bits for DMAx Channel7 */
      LL_DMA_ClearFlag_GI7(DMAx);
    }
    else
LL_DMA2D_DeInit in stm32l4xx_ll_dma2d.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Force reset of DMA2D clock */
    LL_AHB1_GRP1_ForceReset(LL_AHB1_GRP1_PERIPH_DMA2D);

    /* Release reset of DMA2D clock */
    LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_DMA2D);
  }
  else
  {
stm32l4xx_ll_exti.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 75 : 
/**
  * @brief  De-initialize the EXTI registers to their default reset values.
  * @retval An ErrorStatus enumeration value:
  *          - 0x00: EXTI registers are de-initialized
  */
LL_EXTI_DeInit in stm32l4xx_ll_exti.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
{
  /* Interrupt mask register set to default reset values */
  LL_EXTI_WriteReg(IMR1,   0xFF820000U);
  /* Event mask register set to default reset values */
  LL_EXTI_WriteReg(EMR1,   0x00000000U);
  /* Rising Trigger selection register set to default reset values */
  LL_EXTI_WriteReg(RTSR1,  0x00000000U);
  /* Falling Trigger selection register set to default reset values */
  LL_EXTI_WriteReg(FTSR1,  0x00000000U);
  /* Software interrupt event register set to default reset values */
  LL_EXTI_WriteReg(SWIER1, 0x00000000U);
  /* Pending register clear */
  LL_EXTI_WriteReg(PR1,    0x007DFFFFU);

  /* Interrupt mask register 2 set to default reset values */
#if defined(LL_EXTI_LINE_40)
  LL_EXTI_WriteReg(IMR2,        0x00000187U);
#else
LL_EXTI_DeInit in stm32l4xx_ll_exti.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#endif
  /* Event mask register 2 set to default reset values */
  LL_EXTI_WriteReg(EMR2,        0x00000000U);
  /* Rising Trigger selection register 2 set to default reset values */
  LL_EXTI_WriteReg(RTSR2,       0x00000000U);
  /* Falling Trigger selection register 2 set to default reset values */
  LL_EXTI_WriteReg(FTSR2,       0x00000000U);
  /* Software interrupt event register 2 set to default reset values */
  LL_EXTI_WriteReg(SWIER2,      0x00000000U);
  /* Pending register 2 clear */
  LL_EXTI_WriteReg(PR2,         0x00000078U);
stm32l4xx_ll_exti.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 264 : 
  * @brief  Enable ExtiLine Interrupt request for Lines in range 0 to 31
  * @note The reset value for the direct or internal lines (see RM)
  *       is set to 1 in order to enable the interrupt by default.
  *       Bits are set automatically at Power on.
  * @rmtoll IMR1         IMx           LL_EXTI_EnableIT_0_31
stm32l4xx_ll_exti.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 311 : 
  * @brief  Enable ExtiLine Interrupt request for Lines in range 32 to 63
  * @note The reset value for the direct lines (lines from 32 to 34, line
  *       39) is set to 1 in order to enable the interrupt by default.
  *       Bits are set automatically at Power on.
  * @rmtoll IMR2         IMx           LL_EXTI_EnableIT_32_63
stm32l4xx_ll_exti.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 336 : 
  * @brief  Disable ExtiLine Interrupt request for Lines in range 0 to 31
  * @note The reset value for the direct or internal lines (see RM)
  *       is set to 1 in order to enable the interrupt by default.
  *       Bits are set automatically at Power on.
  * @rmtoll IMR1         IMx           LL_EXTI_DisableIT_0_31
stm32l4xx_ll_exti.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 384 : 
  * @brief  Disable ExtiLine Interrupt request for Lines in range 32 to 63
  * @note The reset value for the direct lines (lines from 32 to 34, line
  *       39) is set to 1 in order to enable the interrupt by default.
  *       Bits are set automatically at Power on.
  * @rmtoll IMR2         IMx           LL_EXTI_DisableIT_32_63
stm32l4xx_ll_exti.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 409 : 
  * @brief  Indicate if ExtiLine Interrupt request is enabled for Lines in range 0 to 31
  * @note The reset value for the direct or internal lines (see RM)
  *       is set to 1 in order to enable the interrupt by default.
  *       Bits are set automatically at Power on.
  * @rmtoll IMR1         IMx           LL_EXTI_IsEnabledIT_0_31
stm32l4xx_ll_exti.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 457 : 
  * @brief  Indicate if ExtiLine Interrupt request is enabled for Lines in range 32 to 63
  * @note The reset value for the direct lines (lines from 32 to 34, line
  *       39) is set to 1 in order to enable the interrupt by default.
  *       Bits are set automatically at Power on.
  * @rmtoll IMR2         IMx           LL_EXTI_IsEnabledIT_32_63
stm32l4xx_ll_fmc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 197 : 

    (+) FMC NORSRAM bank reset using the function FMC_NORSRAM_DeInit()
    (+) FMC NORSRAM bank control configuration using the function FMC_NORSRAM_Init()
    (+) FMC NORSRAM bank timing configuration using the function FMC_NORSRAM_Timing_Init()
    (+) FMC NORSRAM bank extended timing configuration using the function
stm32l4xx_ll_fmc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 523 : 

    (+) FMC NAND bank reset using the function FMC_NAND_DeInit()
    (+) FMC NAND bank control configuration using the function FMC_NAND_Init()
    (+) FMC NAND bank common space timing configuration using the function
        FMC_NAND_CommonSpace_Timing_Init()
FMC_NAND_DeInit in stm32l4xx_ll_fmc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* De-initialize the NAND Bank */
  /* Set the FMC_NAND_BANK3 registers to their reset values */
  WRITE_REG(Device->PCR,  0x00000018);
  WRITE_REG(Device->SR,   0x00000040);
  WRITE_REG(Device->PMEM, 0xFCFCFCFC);
FMC_NAND_GetECC in stm32l4xx_ll_fmc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* Wait until FIFO is empty */
  while (__FMC_NAND_GET_FLAG(Device, Bank, FMC_FLAG_FEMPT) == RESET)
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
stm32l4xx_ll_fmc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 730 : 
  *            @arg FMC_FLAG_FEMPT FIFO empty flag.
  * @retval The state of FLAG (SET or RESET).
  */
#define __FMC_NAND_GET_FLAG(__INSTANCE__, __BANK__, __FLAG__)  (((__INSTANCE__)->SR &(__FLAG__)) == (__FLAG__))

LL_GPIO_DeInit in stm32l4xx_ll_gpio.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Force and Release reset on clock of GPIOx Port */
  if (GPIOx == GPIOA)
  {
    LL_AHB2_GRP1_ForceReset(LL_AHB2_GRP1_PERIPH_GPIOA);
    LL_AHB2_GRP1_ReleaseReset(LL_AHB2_GRP1_PERIPH_GPIOA);
  }
  else if (GPIOx == GPIOB)
  {
    LL_AHB2_GRP1_ForceReset(LL_AHB2_GRP1_PERIPH_GPIOB);
    LL_AHB2_GRP1_ReleaseReset(LL_AHB2_GRP1_PERIPH_GPIOB);
  }
  else if (GPIOx == GPIOC)
  {
    LL_AHB2_GRP1_ForceReset(LL_AHB2_GRP1_PERIPH_GPIOC);
    LL_AHB2_GRP1_ReleaseReset(LL_AHB2_GRP1_PERIPH_GPIOC);
  }
#if defined(GPIOD)
  else if (GPIOx == GPIOD)
  {
    LL_AHB2_GRP1_ForceReset(LL_AHB2_GRP1_PERIPH_GPIOD);
    LL_AHB2_GRP1_ReleaseReset(LL_AHB2_GRP1_PERIPH_GPIOD);
  }
#endif /* GPIOD */
#if defined(GPIOE)
LL_GPIO_DeInit in stm32l4xx_ll_gpio.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    LL_AHB2_GRP1_ForceReset(LL_AHB2_GRP1_PERIPH_GPIOE);
    LL_AHB2_GRP1_ReleaseReset(LL_AHB2_GRP1_PERIPH_GPIOE);
  }
#endif /* GPIOE */
#if defined(GPIOF)
LL_GPIO_DeInit in stm32l4xx_ll_gpio.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    LL_AHB2_GRP1_ForceReset(LL_AHB2_GRP1_PERIPH_GPIOF);
    LL_AHB2_GRP1_ReleaseReset(LL_AHB2_GRP1_PERIPH_GPIOF);
  }
#endif /* GPIOF */
#if defined(GPIOG)
LL_GPIO_DeInit in stm32l4xx_ll_gpio.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    LL_AHB2_GRP1_ForceReset(LL_AHB2_GRP1_PERIPH_GPIOG);
    LL_AHB2_GRP1_ReleaseReset(LL_AHB2_GRP1_PERIPH_GPIOG);
  }
#endif /* GPIOG */
#if defined(GPIOH)
LL_GPIO_DeInit in stm32l4xx_ll_gpio.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    LL_AHB2_GRP1_ForceReset(LL_AHB2_GRP1_PERIPH_GPIOH);
    LL_AHB2_GRP1_ReleaseReset(LL_AHB2_GRP1_PERIPH_GPIOH);
  }
#endif /* GPIOH */
#if defined(GPIOI)
LL_GPIO_DeInit in stm32l4xx_ll_gpio.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    LL_AHB2_GRP1_ForceReset(LL_AHB2_GRP1_PERIPH_GPIOI);
    LL_AHB2_GRP1_ReleaseReset(LL_AHB2_GRP1_PERIPH_GPIOI);
  }
#endif /* GPIOI */
  else
LL_GPIO_StructInit in stm32l4xx_ll_gpio.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->Pin        = LL_GPIO_PIN_ALL;
  GPIO_InitStruct->Mode       = LL_GPIO_MODE_ANALOG;
  GPIO_InitStruct->Speed      = LL_GPIO_SPEED_FREQ_LOW;
stm32l4xx_ll_gpio.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 694 : 
  *         Only the IO which connected to the ADC input are effective.
  *         Other IO must be kept reset value
  * @rmtoll ASCR         ASCy          LL_GPIO_EnablePinAnalogControl
  * @param  GPIOx GPIO Port
  * @param  PinMask This parameter can be a combination of the following values:
stm32l4xx_ll_gpio.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 756 : 
  *         value of this port bit can no longer be modified until the
  *         next reset.
  * @note   Each lock bit freezes a specific configuration register
  *         (control and alternate function registers).
  * @rmtoll LCKR         LCKK          LL_GPIO_LockPin
stm32l4xx_ll_gpio.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 963 : 
  * @brief  Set several pins to low level on dedicated gpio port.
  * @rmtoll BRR          BRy           LL_GPIO_ResetOutputPin
  * @param  GPIOx GPIO Port
  * @param  PinMask This parameter can be a combination of the following values:
  *         @arg @ref LL_GPIO_PIN_0
stm32l4xx_ll_gpio.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 985 : 
  */
__STATIC_INLINE void LL_GPIO_ResetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
  WRITE_REG(GPIOx->BRR, PinMask);
}
stm32l4xx_ll_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 80 : 
/**
  * @brief  De-initialize the I2C registers to their default reset values.
  * @param  I2Cx I2C Instance.
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: I2C registers are de-initialized
LL_I2C_DeInit in stm32l4xx_ll_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Force reset of I2C clock */
    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_I2C1);

    /* Release reset of I2C clock */
    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_I2C1);
  }
#if defined(I2C2)
  else if (I2Cx == I2C2)
  {
    /* Force reset of I2C clock */
    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_I2C2);

    /* Release reset of I2C clock */
    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_I2C2);

  }
#endif
LL_I2C_DeInit in stm32l4xx_ll_i2c.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Force reset of I2C clock */
    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_I2C3);

    /* Release reset of I2C clock */
    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_I2C3);
  }
#if defined(I2C4)
  else if (I2Cx == I2C4)
  {
    /* Force reset of I2C clock */
    LL_APB1_GRP2_ForceReset(LL_APB1_GRP2_PERIPH_I2C4);

    /* Release reset of I2C clock */
    LL_APB1_GRP2_ReleaseReset(LL_APB1_GRP2_PERIPH_I2C4);
  }
#endif
  else
stm32l4xx_ll_i2c.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 398 : 
  * @note   When PE = 0, the I2C SCL and SDA lines are released.
  *         Internal state machines and status bits are put back to their reset value.
  *         When cleared, PE must be kept low for at least 3 APB clock cycles.
  * @rmtoll CR1          PE            LL_I2C_Disable
  * @param  I2Cx I2C Instance.
stm32l4xx_ll_i2c.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1504 : 
  * @brief  Indicate the status of Transmit data register empty flag.
  * @note   RESET: When next data is written in Transmit data register.
  *         SET: When Transmit data register is empty.
  * @rmtoll ISR          TXE           LL_I2C_IsActiveFlag_TXE
  * @param  I2Cx I2C Instance.
stm32l4xx_ll_i2c.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1517 : 
  * @brief  Indicate the status of Transmit interrupt flag.
  * @note   RESET: When next data is written in Transmit data register.
  *         SET: When Transmit data register is empty.
  * @rmtoll ISR          TXIS          LL_I2C_IsActiveFlag_TXIS
  * @param  I2Cx I2C Instance.
stm32l4xx_ll_i2c.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1530 : 
  * @brief  Indicate the status of Receive data register not empty flag.
  * @note   RESET: When Receive data register is read.
  *         SET: When the received data is copied in Receive data register.
  * @rmtoll ISR          RXNE          LL_I2C_IsActiveFlag_RXNE
  * @param  I2Cx I2C Instance.
stm32l4xx_ll_i2c.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1543 : 
  * @brief  Indicate the status of Address matched flag (slave mode).
  * @note   RESET: Clear default value.
  *         SET: When the received slave address matched with one of the enabled slave address.
  * @rmtoll ISR          ADDR          LL_I2C_IsActiveFlag_ADDR
  * @param  I2Cx I2C Instance.
stm32l4xx_ll_i2c.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1556 : 
  * @brief  Indicate the status of Not Acknowledge received flag.
  * @note   RESET: Clear default value.
  *         SET: When a NACK is received after a byte transmission.
  * @rmtoll ISR          NACKF         LL_I2C_IsActiveFlag_NACK
  * @param  I2Cx I2C Instance.
stm32l4xx_ll_i2c.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1569 : 
  * @brief  Indicate the status of Stop detection flag.
  * @note   RESET: Clear default value.
  *         SET: When a Stop condition is detected.
  * @rmtoll ISR          STOPF         LL_I2C_IsActiveFlag_STOP
  * @param  I2Cx I2C Instance.
stm32l4xx_ll_i2c.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1582 : 
  * @brief  Indicate the status of Transfer complete flag (master mode).
  * @note   RESET: Clear default value.
  *         SET: When RELOAD=0, AUTOEND=0 and NBYTES date have been transferred.
  * @rmtoll ISR          TC            LL_I2C_IsActiveFlag_TC
  * @param  I2Cx I2C Instance.
stm32l4xx_ll_i2c.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1595 : 
  * @brief  Indicate the status of Transfer complete flag (master mode).
  * @note   RESET: Clear default value.
  *         SET: When RELOAD=1 and NBYTES date have been transferred.
  * @rmtoll ISR          TCR           LL_I2C_IsActiveFlag_TCR
  * @param  I2Cx I2C Instance.
stm32l4xx_ll_i2c.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1608 : 
  * @brief  Indicate the status of Bus error flag.
  * @note   RESET: Clear default value.
  *         SET: When a misplaced Start or Stop condition is detected.
  * @rmtoll ISR          BERR          LL_I2C_IsActiveFlag_BERR
  * @param  I2Cx I2C Instance.
stm32l4xx_ll_i2c.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1621 : 
  * @brief  Indicate the status of Arbitration lost flag.
  * @note   RESET: Clear default value.
  *         SET: When arbitration lost.
  * @rmtoll ISR          ARLO          LL_I2C_IsActiveFlag_ARLO
  * @param  I2Cx I2C Instance.
stm32l4xx_ll_i2c.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1634 : 
  * @brief  Indicate the status of Overrun/Underrun flag (slave mode).
  * @note   RESET: Clear default value.
  *         SET: When an overrun/underrun error occurs (Clock Stretching Disabled).
  * @rmtoll ISR          OVR           LL_I2C_IsActiveFlag_OVR
  * @param  I2Cx I2C Instance.
stm32l4xx_ll_i2c.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1649 : 
  *         SMBus feature is supported by the I2Cx Instance.
  * @note   RESET: Clear default value.
  *         SET: When the received PEC does not match with the PEC register content.
  * @rmtoll ISR          PECERR        LL_I2C_IsActiveSMBusFlag_PECERR
  * @param  I2Cx I2C Instance.
stm32l4xx_ll_i2c.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1664 : 
  *         SMBus feature is supported by the I2Cx Instance.
  * @note   RESET: Clear default value.
  *         SET: When a timeout or extended clock timeout occurs.
  * @rmtoll ISR          TIMEOUT       LL_I2C_IsActiveSMBusFlag_TIMEOUT
  * @param  I2Cx I2C Instance.
stm32l4xx_ll_i2c.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1679 : 
  *         SMBus feature is supported by the I2Cx Instance.
  * @note   RESET: Clear default value.
  *         SET: When SMBus host configuration, SMBus alert enabled and
  *              a falling edge event occurs on SMBA pin.
  * @rmtoll ISR          ALERT         LL_I2C_IsActiveSMBusFlag_ALERT
stm32l4xx_ll_i2c.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1693 : 
  * @brief  Indicate the status of Bus Busy flag.
  * @note   RESET: Clear default value.
  *         SET: When a Start condition is detected.
  * @rmtoll ISR          BUSY          LL_I2C_IsActiveFlag_BUSY
  * @param  I2Cx I2C Instance.
stm32l4xx_ll_i2c.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 2099 : 
  * @brief  Indicate the value of transfer direction (slave mode).
  * @note   RESET: Write transfer, Slave enters in receiver mode.
  *         SET: Read transfer, Slave enters in transmitter mode.
  * @rmtoll ISR          DIR           LL_I2C_GetTransferDirection
  * @param  I2Cx I2C Instance.
stm32l4xx_ll_iwdg.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 304 : 
/**
  * @brief  Check if all flags Prescaler, Reload & Window Value Update are reset or not
  * @rmtoll SR           PVU           LL_IWDG_IsReady\n
  *         SR           WVU           LL_IWDG_IsReady\n
  *         SR           RVU           LL_IWDG_IsReady
stm32l4xx_ll_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 89 : 
/**
  * @brief  Set LPTIMx registers to their reset values.
  * @param  LPTIMx LP Timer instance
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: LPTIMx registers are de-initialized
LL_LPTIM_DeInit in stm32l4xx_ll_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_LPTIM1);
    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_LPTIM1);
  }
#if defined(LPTIM2)
  else if (LPTIMx == LPTIM2)
  {
    LL_APB1_GRP2_ForceReset(LL_APB1_GRP2_PERIPH_LPTIM2);
    LL_APB1_GRP2_ReleaseReset(LL_APB1_GRP2_PERIPH_LPTIM2);
  }
#endif /* LPTIM2 */
  else
LL_LPTIM_Init in stm32l4xx_ll_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /* The LPTIMx_CFGR register must only be modified when the LPTIM is disabled
     (ENABLE bit is reset to 0).
  */
  if (LL_LPTIM_IsEnabled(LPTIMx) == 1UL)
  {
LL_LPTIM_Disable in stm32l4xx_ll_lptim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /************* Reset LPTIM ************/
  (void)LL_LPTIM_DeInit(LPTIMx);

  /********* Restore LPTIM Config *******/
stm32l4xx_ll_lptim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 400 : 
/**
  * @brief  Enable reset after read.
  * @note After calling this function any read access to LPTIM_CNT
  *        register will asynchronously reset the LPTIM_CNT register content.
  * @rmtoll CR           RSTARE        LL_LPTIM_EnableResetAfterRead
  * @param  LPTIMx Low-Power Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_LPTIM_EnableResetAfterRead(LPTIM_TypeDef *LPTIMx)
{
  SET_BIT(LPTIMx->CR, LPTIM_CR_RSTARE);
}
stm32l4xx_ll_lptim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 413 : 
/**
  * @brief  Disable reset after read.
  * @rmtoll CR           RSTARE        LL_LPTIM_DisableResetAfterRead
  * @param  LPTIMx Low-Power Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_LPTIM_DisableResetAfterRead(LPTIM_TypeDef *LPTIMx)
{
  CLEAR_BIT(LPTIMx->CR, LPTIM_CR_RSTARE);
}
stm32l4xx_ll_lptim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 424 : 
/**
  * @brief  Indicate whether the reset after read feature is enabled.
  * @rmtoll CR           RSTARE        LL_LPTIM_DisableResetAfterRead
  * @param  LPTIMx Low-Power Timer instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_LPTIM_IsEnabledResetAfterRead(LPTIM_TypeDef *LPTIMx)
{
  return ((READ_BIT(LPTIMx->CR, LPTIM_CR_RSTARE) == LPTIM_CR_RSTARE) ? 1UL : 0UL);
}
stm32l4xx_ll_lptim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 437 : 
/**
  * @brief  Reset of the LPTIM_CNT counter register (synchronous).
  * @note Due to the synchronous nature of this reset, it only takes
  *       place after a synchronization delay of 3 LPTIM core clock cycles
  *      (LPTIM core clock may be different from APB clock).
  * @note COUNTRST is automatically cleared by hardware
  * @rmtoll CR           COUNTRST       LL_LPTIM_ResetCounter\n
  * @param  LPTIMx Low-Power Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_LPTIM_ResetCounter(LPTIM_TypeDef *LPTIMx)
{
  SET_BIT(LPTIMx->CR, LPTIM_CR_COUNTRST);
}
stm32l4xx_ll_lptim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 768 : 
  * @note The first trigger event will start the timer, any successive trigger
  *       event will reset the counter and the timer will restart.
  * @note The timeout value corresponds to the compare value; if no trigger
  *       occurs within the expected time frame, the MCU is waked-up by the
  *       compare match event.
LL_LPUART_DeInit in stm32l4xx_ll_lpuart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Force reset of LPUART peripheral */
    LL_APB1_GRP2_ForceReset(LL_APB1_GRP2_PERIPH_LPUART1);

    /* Release reset of LPUART peripheral */
    LL_APB1_GRP2_ReleaseReset(LL_APB1_GRP2_PERIPH_LPUART1);
  }
  else
  {
stm32l4xx_ll_lpuart.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 520 : 
  * @note   In order to go into low-power mode without generating errors on the line,
  *         the TE bit must be reset before and the software must wait
  *         for the TC bit in the LPUART_ISR to be set before resetting the UE bit.
  *         The DMA requests are also reset when UE = 0 so the DMA channel must
  *         be disabled before resetting the UE bit.
  * @rmtoll CR1          UE            LL_LPUART_Disable
  * @param  LPUARTx LPUART Instance
  * @retval None
stm32l4xx_ll_opamp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 98 : 
  * @brief  De-initialize registers of the selected OPAMP instance
  *         to their default reset values.
  * @param  OPAMPx OPAMP instance
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: OPAMP registers are de-initialized
stm32l4xx_ll_opamp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 118 : 
  * @brief  Initialize some features of OPAMP instance.
  * @note   This function reset bit of calibration mode to ensure
  *         to be in functional mode, in order to have OPAMP parameters
  *         (inputs selection, ...) set with the corresponding OPAMP mode
  *         to be effective.
LL_OPAMP_Init in stm32l4xx_ll_opamp.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  /*  - Input inverting                                                       */
  /* Note: Bit OPAMP_CSR_CALON reset to ensure to be in functional mode.      */
  if(OPAMP_InitStruct->FunctionalMode != LL_OPAMP_MODE_FOLLOWER)
  {
    MODIFY_REG(OPAMPx->CSR,
stm32l4xx_ll_opamp.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 487 : 
  *         OPAMP operation in standalone, follower, ...
  * @note   This function reset bit of calibration mode to ensure
  *         to be in functional mode, in order to have OPAMP parameters
  *         (inputs selection, ...) set with the corresponding OPAMP mode
  *         to be effective.
LL_OPAMP_SetFunctionalMode in stm32l4xx_ll_opamp.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) : 
{
  /* Note: Bit OPAMP_CSR_CALON reset to ensure to be in functional mode */
  MODIFY_REG(OPAMPx->CSR, OPAMP_CSR_OPAMODE | OPAMP_CSR_CALON, FunctionalMode);
}

stm32l4xx_ll_opamp.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 718 : 
  * @note   This functions returns:
  *         0 if OPAMP calibration output is reset
  *         1 if OPAMP calibration output is set
  * @rmtoll CSR      CALOUT         LL_OPAMP_IsCalibrationOutputSet
  * @param  OPAMPx OPAMP instance
stm32l4xx_ll_pwr.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 50 : 
/**
  * @brief  De-initialize the PWR registers to their default reset values.
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: PWR registers are de-initialized
  *          - ERROR: not applicable
LL_PWR_DeInit in stm32l4xx_ll_pwr.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
{
  /* Force reset of PWR clock */
  LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_PWR);

  /* Release reset of PWR clock */
  LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_PWR);

  return SUCCESS;
}
stm32l4xx_ll_rcc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 177 : 
/**
  * @brief  Reset the RCC clock configuration to the default reset state.
  * @note   The default reset state of the clock configuration is given below:
  *         - MSI  ON and used as system clock source
  *         - HSE, HSI, PLL, PLLSAI1 and PLLSAI2 OFF
  *         - AHB, APB1 and APB2 prescaler set to 1.
LL_RCC_DeInit in stm32l4xx_ll_rcc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Set MSITRIM bits to the reset value*/
  LL_RCC_MSI_SetCalibTrimming(0);

  /* Set HSITRIM bits to the reset value*/
  LL_RCC_HSI_SetCalibTrimming(0x10U);

  /* Reset CFGR register */
  LL_RCC_WriteReg(CFGR, 0x00000000U);

  /* Read CR register */
LL_RCC_DeInit in stm32l4xx_ll_rcc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset HSION, HSIKERON, HSIASFS, HSEON, PLLON bits */
  CLEAR_BIT(vl_mask,
            (RCC_CR_HSION | RCC_CR_HSIASFS | RCC_CR_HSIKERON  | RCC_CR_HSEON | RCC_CR_PLLON));

#if defined(RCC_PLLSAI1_SUPPORT)
  /* Reset PLLSAI1ON bit */
  CLEAR_BIT(vl_mask, RCC_CR_PLLSAI1ON);
#endif /*RCC_PLLSAI1_SUPPORT*/

#if defined(RCC_PLLSAI2_SUPPORT)
  /* Reset PLLSAI2ON bit */
  CLEAR_BIT(vl_mask, RCC_CR_PLLSAI2ON);
#endif /*RCC_PLLSAI2_SUPPORT*/

LL_RCC_DeInit in stm32l4xx_ll_rcc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#if defined(RCC_PLLSAI2_SUPPORT)
  /* Wait for PLLRDY, PLLSAI1RDY and PLLSAI2RDY bits to be reset */
  while(READ_BIT(RCC->CR, RCC_CR_PLLRDY | RCC_CR_PLLSAI1RDY | RCC_CR_PLLSAI2RDY) != 0U)
  {
  }
#elif defined(RCC_PLLSAI1_SUPPORT)
  /* Wait for PLLRDY and PLLSAI1RDY to be reset */
  while(READ_BIT(RCC->CR, RCC_CR_PLLRDY | RCC_CR_PLLSAI1RDY) != 0U)
  {
  }
#else
  /* Wait for PLLRDY bit to be reset */
  while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
  {
  }
LL_RCC_DeInit in stm32l4xx_ll_rcc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset PLLCFGR register */
  LL_RCC_WriteReg(PLLCFGR, 16U << RCC_PLLCFGR_PLLN_Pos);

#if defined(RCC_PLLSAI1_SUPPORT)
  /* Reset PLLSAI1CFGR register */
  LL_RCC_WriteReg(PLLSAI1CFGR, 16U << RCC_PLLSAI1CFGR_PLLSAI1N_Pos);
#endif /*RCC_PLLSAI1_SUPPORT*/

#if defined(RCC_PLLSAI2_SUPPORT)
  /* Reset PLLSAI2CFGR register */
  LL_RCC_WriteReg(PLLSAI2CFGR, 16U << RCC_PLLSAI2CFGR_PLLSAI2N_Pos);
#endif /*RCC_PLLSAI2_SUPPORT*/

  /* Reset HSEBYP bit */
  LL_RCC_HSE_DisableBypass();

  /* Disable all interrupts */
LL_RCC_DeInit in stm32l4xx_ll_rcc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Clear reset flags */
  LL_RCC_ClearResetFlags();

  return SUCCESS;
}
stm32l4xx_ll_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 185 : 
#define LL_RCC_CIFR_CSSF                   RCC_CIFR_CSSF        /*!< Clock Security System Interrupt flag */
#define LL_RCC_CSR_FWRSTF                  RCC_CSR_FWRSTF     /*!< Firewall reset flag */
#define LL_RCC_CSR_LPWRRSTF                RCC_CSR_LPWRRSTF   /*!< Low-Power reset flag */
#define LL_RCC_CSR_OBLRSTF                 RCC_CSR_OBLRSTF    /*!< OBL reset flag */
#define LL_RCC_CSR_PINRSTF                 RCC_CSR_PINRSTF    /*!< PIN reset flag */
#define LL_RCC_CSR_SFTRSTF                 RCC_CSR_SFTRSTF    /*!< Software Reset flag */
#define LL_RCC_CSR_IWDGRSTF                RCC_CSR_IWDGRSTF   /*!< Independent Watchdog reset flag */
#define LL_RCC_CSR_WWDGRSTF                RCC_CSR_WWDGRSTF   /*!< Window watchdog reset flag */
#define LL_RCC_CSR_BORRSTF                 RCC_CSR_BORRSTF    /*!< BOR reset flag */
/**
  * @}
  */
stm32l4xx_ll_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 2389 : 
  * @brief  Enable LSE oscillator propagation
  * @note A 2 LSE-clock delay is needed for LSESYSDIS resetting to be taken into account
  * @rmtoll BDCR         LSESYSDIS     LL_RCC_LSE_EnablePropagation
  * @retval None
  */
stm32l4xx_ll_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 2539 : 
  * @brief  Enable MSI clock range selection with MSIRANGE register
  * @note Write 0 has no effect. After a standby or a reset
  *       MSIRGSEL is at 0 and the MSI range value is provided by
  *       MSISRANGE
  * @rmtoll CR           MSIRGSEL      LL_RCC_MSI_EnableRangeSelection
stm32l4xx_ll_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 3637 : 
  * @note Once the RTC clock source has been selected, it cannot be changed anymore unless
  *       the Backup domain is reset, or unless a failure is detected on LSE (LSECSSD is
  *       set). The BDRST bit can be used to reset them.
  * @rmtoll BDCR         RTCSEL        LL_RCC_SetRTCClockSource
  * @param  Source This parameter can be one of the following values:
  *         @arg @ref LL_RCC_RTC_CLKSOURCE_NONE
stm32l4xx_ll_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 3697 : 
/**
  * @brief  Force the Backup domain reset
  * @rmtoll BDCR         BDRST         LL_RCC_ForceBackupDomainReset
  * @retval None
  */
__STATIC_INLINE void LL_RCC_ForceBackupDomainReset(void)
{
  SET_BIT(RCC->BDCR, RCC_BDCR_BDRST);
}
stm32l4xx_ll_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 3707 : 
/**
  * @brief  Release the Backup domain reset
  * @rmtoll BDCR         BDRST         LL_RCC_ReleaseBackupDomainReset
  * @retval None
  */
__STATIC_INLINE void LL_RCC_ReleaseBackupDomainReset(void)
{
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_BDRST);
}
stm32l4xx_ll_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 5604 : 
/**
  * @brief  Check if RCC flag FW reset is set or not.
  * @rmtoll CSR          FWRSTF        LL_RCC_IsActiveFlag_FWRST
  * @retval State of bit (1 or 0).
  */
stm32l4xx_ll_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 5614 : 
/**
  * @brief  Check if RCC flag Independent Watchdog reset is set or not.
  * @rmtoll CSR          IWDGRSTF      LL_RCC_IsActiveFlag_IWDGRST
  * @retval State of bit (1 or 0).
  */
stm32l4xx_ll_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 5624 : 
/**
  * @brief  Check if RCC flag Low Power reset is set or not.
  * @rmtoll CSR          LPWRRSTF      LL_RCC_IsActiveFlag_LPWRRST
  * @retval State of bit (1 or 0).
  */
stm32l4xx_ll_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 5644 : 
/**
  * @brief  Check if RCC flag Pin reset is set or not.
  * @rmtoll CSR          PINRSTF       LL_RCC_IsActiveFlag_PINRST
  * @retval State of bit (1 or 0).
  */
stm32l4xx_ll_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 5654 : 
/**
  * @brief  Check if RCC flag Software reset is set or not.
  * @rmtoll CSR          SFTRSTF       LL_RCC_IsActiveFlag_SFTRST
  * @retval State of bit (1 or 0).
  */
stm32l4xx_ll_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 5664 : 
/**
  * @brief  Check if RCC flag Window Watchdog reset is set or not.
  * @rmtoll CSR          WWDGRSTF      LL_RCC_IsActiveFlag_WWDGRST
  * @retval State of bit (1 or 0).
  */
stm32l4xx_ll_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 5674 : 
/**
  * @brief  Check if RCC flag BOR reset is set or not.
  * @rmtoll CSR          BORRSTF       LL_RCC_IsActiveFlag_BORRST
  * @retval State of bit (1 or 0).
  */
stm32l4xx_ll_rcc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 5684 : 
/**
  * @brief  Set RMVF bit to clear the reset flags.
  * @rmtoll CSR          RMVF          LL_RCC_ClearResetFlags
  * @retval None
  */
__STATIC_INLINE void LL_RCC_ClearResetFlags(void)
{
  SET_BIT(RCC->CSR, RCC_CSR_RMVF);
}
LL_RNG_DeInit in stm32l4xx_ll_rng.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Enable RNG reset state */
  LL_AHB2_GRP1_ForceReset(LL_AHB2_GRP1_PERIPH_RNG);

  /* Release RNG from reset state */
  LL_AHB2_GRP1_ReleaseReset(LL_AHB2_GRP1_PERIPH_RNG);

  return (SUCCESS);
}
stm32l4xx_ll_rtc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 129 : 
/**
  * @brief  De-Initializes the RTC registers to their default reset values.
  * @note   This function doesn't reset the RTC Clock source and RTC Backup Data
  *         registers.
  * @param  RTCx RTC Instance
  * @retval An ErrorStatus enumeration value:
LL_RTC_DeInit in stm32l4xx_ll_rtc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Reset TR, DR and CR registers */
    LL_RTC_WriteReg(RTCx, TR, 0x00000000U);

    LL_RTC_WriteReg(RTCx, WUTR, RTC_WUTR_WUT);
    LL_RTC_WriteReg(RTCx, DR, (RTC_DR_WDU_0 | RTC_DR_MU_0 | RTC_DR_DU_0));
    /* Reset All CR bits except CR[2:0] */
    LL_RTC_WriteReg(RTCx, CR, (LL_RTC_ReadReg(RTCx, CR) & RTC_CR_WUCKSEL));

    LL_RTC_WriteReg(RTCx, PRER, (RTC_PRER_PREDIV_A | RTC_SYNCH_PRESC_DEFAULT));
LL_RTC_DeInit in stm32l4xx_ll_rtc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
#else /* #if defined(STM32L412xx) || defined(STM32L422xx) */
    /* Reset ISR register and exit initialization mode */
    LL_RTC_WriteReg(RTCx, ISR,      0x00000000U);

    /* Reset Tamper and alternate functions configuration register */
    LL_RTC_WriteReg(RTCx, TAMPCR, 0x00000000U);

    /* Reset Option register */
    LL_RTC_WriteReg(RTCx, OR, 0x00000000U);
#endif /* #if defined(STM32L412xx) || defined(STM32L422xx) */

stm32l4xx_ll_rtc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 970 : 
  *         and prescaler register (RTC_PRER).
  *         Counters are stopped and start counting from the new value when INIT is reset.
  * @rmtoll RTC_ICSR          INIT          LL_RTC_EnableInitMode
  * @param  RTCx RTC Instance
  * @retval None
stm32l4xx_ll_rtc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1028 : 
  *         and prescaler register (RTC_PRER).
  *         Counters are stopped and start counting from the new value when INIT is reset.
  * @rmtoll ISR          INIT          LL_RTC_EnableInitMode
  * @param  RTCx RTC Instance
  * @retval None
stm32l4xx_ll_rtc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 2195 : 
  * @brief  Set Alarm A Mask the most-significant bits starting at this bit
  * @note This register can be written only when ALRAE is reset in RTC_CR register,
  *       or in initialization mode.
  * @rmtoll RTC_ALRMASSR     MASKSS        LL_RTC_ALMA_SetSubSecondMask
  * @param  RTCx RTC Instance
stm32l4xx_ll_rtc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 2561 : 
  * @brief  Set Alarm B Mask the most-significant bits starting at this bit
  * @note This register can be written only when ALRBE is reset in RTC_CR register,
  *       or in initialization mode.
  * @rmtoll RTC_ALRMBSSR     MASKSS        LL_RTC_ALMB_SetSubSecondMask
  * @param  RTCx RTC Instance
stm32l4xx_ll_rtc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 2666 : 
  * @note   Bit is write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
  * @note TSE must be reset when TSEDGE is changed to avoid unwanted TSF setting
  * @rmtoll RTC_CR           ITSEDGE        LL_RTC_TS_SetActiveEdge
  * @param  RTCx RTC Instance
  * @param  Edge This parameter can be one of the following values:
stm32l4xx_ll_sdmmc.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 1388 : 
  }
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
  {
    return SDMMC_ERROR_ERASE_RESET;
  }
  else if((response_r1 & SDMMC_OCR_AKE_SEQ_ERROR) == SDMMC_OCR_AKE_SEQ_ERROR)
  {
stm32l4xx_ll_sdmmc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 163 : 
#define SDMMC_ERROR_CARD_ECC_DISABLED        ((uint32_t)0x00200000U)   /*!< Command has been executed without using internal ECC          */
#define SDMMC_ERROR_ERASE_RESET              ((uint32_t)0x00400000U)   /*!< Erase sequence was cleared before executing because an out
                                                                            of erase sequence command was received                        */
#define SDMMC_ERROR_AKE_SEQ_ERR              ((uint32_t)0x00800000U)   /*!< Error in sequence of authentication                           */
#define SDMMC_ERROR_INVALID_VOLTRANGE        ((uint32_t)0x01000000U)   /*!< Error in case of invalid voltage range                        */
stm32l4xx_ll_sdmmc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 178 : 
  */
#define SDMMC_CMD_GO_IDLE_STATE                       ((uint8_t)0U)   /*!< Resets the SD memory card.                                                               */
#define SDMMC_CMD_SEND_OP_COND                        ((uint8_t)1U)   /*!< Sends host capacity support information and activates the card's initialization process. */
#define SDMMC_CMD_ALL_SEND_CID                        ((uint8_t)2U)   /*!< Asks any card connected to the host to send the CID numbers on the CMD line.             */
#define SDMMC_CMD_SET_REL_ADDR                        ((uint8_t)3U)   /*!< Asks the card to publish a new relative address (RCA).                                   */
stm32l4xx_ll_sdmmc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 227 : 
#define SDMMC_CMD_GO_IRQ_STATE                        ((uint8_t)40U)  /*!< SD card doesn't support it (Reserved).                                                   */
#define SDMMC_CMD_LOCK_UNLOCK                         ((uint8_t)42U)  /*!< Sets/resets the password or lock/unlock the card. The size of the data block is set by
                                                                           the SET_BLOCK_LEN command.                                                               */
#define SDMMC_CMD_APP_CMD                             ((uint8_t)55U)  /*!< Indicates to the card that the next command is an application specific command rather
                                                                           than a standard command.                                                                 */
stm32l4xx_ll_sdmmc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 287 : 
#define SDMMC_OCR_CARD_ECC_DISABLED        ((uint32_t)0x00004000U)
#define SDMMC_OCR_ERASE_RESET              ((uint32_t)0x00002000U)
#define SDMMC_OCR_AKE_SEQ_ERROR            ((uint32_t)0x00000008U)
#define SDMMC_OCR_ERRORBITS                ((uint32_t)0xFDFFE008U)

stm32l4xx_ll_sdmmc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 977 : 
  *            @arg SDMMC_FLAG_IDMABTC:    IDMA buffer transfer complete
  * @retval The new state of SDMMC_FLAG (SET or RESET).
  */
#define __SDMMC_GET_FLAG(__INSTANCE__, __FLAG__)  (((__INSTANCE__)->STA &(__FLAG__)) != 0U)

stm32l4xx_ll_sdmmc.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1046 : 
  *            @arg SDMMC_IT_IDMABTC:    IDMA buffer transfer complete interrupt
  * @retval The new state of SDMMC_IT (SET or RESET).
  */
#define __SDMMC_GET_IT(__INSTANCE__, __INTERRUPT__)  (((__INSTANCE__)->STA &(__INTERRUPT__)) == (__INTERRUPT__))

stm32l4xx_ll_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 126 : 
/**
  * @brief  De-initialize the SPI registers to their default reset values.
  * @param  SPIx SPI Instance
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: SPI registers are de-initialized
LL_SPI_DeInit in stm32l4xx_ll_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Force reset of SPI clock */
    LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_SPI1);

    /* Release reset of SPI clock */
    LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_SPI1);

    status = SUCCESS;
  }
LL_SPI_DeInit in stm32l4xx_ll_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Force reset of SPI clock */
    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_SPI2);

    /* Release reset of SPI clock */
    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_SPI2);

    status = SUCCESS;
  }
LL_SPI_DeInit in stm32l4xx_ll_spi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Force reset of SPI clock */
    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_SPI3);

    /* Release reset of SPI clock */
    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_SPI3);

    status = SUCCESS;
  }
stm32l4xx_ll_swpmi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 74 : 
/**
  * @brief  De-initialize the SWPMI peripheral registers to their default reset values.
  * @param  SWPMIx SWPMI Instance
  * @retval An ErrorStatus enumeration value
  *          - SUCCESS: SWPMI registers are de-initialized
LL_SWPMI_DeInit in stm32l4xx_ll_swpmi.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    LL_APB1_GRP2_ForceReset(LL_APB1_GRP2_PERIPH_SWPMI1);
    LL_APB1_GRP2_ReleaseReset(LL_APB1_GRP2_PERIPH_SWPMI1);
  }
  else
  {
stm32l4xx_ll_system.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 899 : 
  * @brief  Enable SRAM2 page write protection for Pages in range 0 to 31
  * @note Write protection is cleared only by a system reset
  * @rmtoll SYSCFG_SWPR  PxWP         LL_SYSCFG_EnableSRAM2PageWRP_0_31
  * @param  SRAM2WRP This parameter can be a combination of the following values:
  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE0
stm32l4xx_ll_system.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 948 : 
  * @brief  Enable SRAM2 page write protection for Pages in range 32 to 63
  * @note Write protection is cleared only by a system reset
  * @rmtoll SYSCFG_SWPR2 PxWP          LL_SYSCFG_EnableSRAM2PageWRP_32_63
  * @param  SRAM2WRP This parameter can be a combination of the following values:
  *         @arg @ref LL_SYSCFG_SRAM2WRP_PAGE32 (*)
stm32l4xx_ll_system.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1503 : 
/**
  * @brief  Enable Instruction cache reset
  * @note  bit can be written only when the instruction cache is disabled
  * @rmtoll FLASH_ACR    ICRST         LL_FLASH_EnableInstCacheReset
  * @retval None
  */
__STATIC_INLINE void LL_FLASH_EnableInstCacheReset(void)
{
  SET_BIT(FLASH->ACR, FLASH_ACR_ICRST);
}
stm32l4xx_ll_system.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1514 : 
/**
  * @brief  Disable Instruction cache reset
  * @rmtoll FLASH_ACR    ICRST         LL_FLASH_DisableInstCacheReset
  * @retval None
  */
__STATIC_INLINE void LL_FLASH_DisableInstCacheReset(void)
{
  CLEAR_BIT(FLASH->ACR, FLASH_ACR_ICRST);
}
stm32l4xx_ll_system.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1524 : 
/**
  * @brief  Enable Data cache reset
  * @note bit can be written only when the data cache is disabled
  * @rmtoll FLASH_ACR    DCRST         LL_FLASH_EnableDataCacheReset
  * @retval None
  */
__STATIC_INLINE void LL_FLASH_EnableDataCacheReset(void)
{
  SET_BIT(FLASH->ACR, FLASH_ACR_DCRST);
}
stm32l4xx_ll_system.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1535 : 
/**
  * @brief  Disable Data cache reset
  * @rmtoll FLASH_ACR    DCRST         LL_FLASH_DisableDataCacheReset
  * @retval None
  */
__STATIC_INLINE void LL_FLASH_DisableDataCacheReset(void)
{
  CLEAR_BIT(FLASH->ACR, FLASH_ACR_DCRST);
}
stm32l4xx_ll_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 210 : 
/**
  * @brief  Set TIMx registers to their reset values.
  * @param  TIMx Timer instance
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: TIMx registers are de-initialized
LL_TIM_DeInit in stm32l4xx_ll_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM1);
    LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM1);
  }
  else if (TIMx == TIM2)
  {
    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM2);
    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM2);
  }
#if defined(TIM3)
  else if (TIMx == TIM3)
  {
    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM3);
    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM3);
  }
#endif
#if defined(TIM4)
LL_TIM_DeInit in stm32l4xx_ll_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM4);
    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM4);
  }
#endif
#if defined(TIM5)
LL_TIM_DeInit in stm32l4xx_ll_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM5);
    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM5);
  }
#endif
  else if (TIMx == TIM6)
  {
    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM6);
    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM6);
  }
#if defined (TIM7)
  else if (TIMx == TIM7)
  {
    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM7);
    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM7);
  }
#endif
#if defined(TIM8)
LL_TIM_DeInit in stm32l4xx_ll_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM8);
    LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM8);
  }
#endif
  else if (TIMx == TIM15)
  {
    LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM15);
    LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM15);
  }
  else if (TIMx == TIM16)
  {
    LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM16);
    LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM16);
  }
#if defined(TIM17)
  else if (TIMx == TIM17)
  {
    LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM17);
    LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM17);
  }
#endif
  else
LL_TIM_ENCODER_Init in stm32l4xx_ll_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Disable the CC1 and CC2: Reset the CC1E and CC2E Bits */
  TIMx->CCER &= (uint32_t)~(TIM_CCER_CC1E | TIM_CCER_CC2E);

  /* Get the TIMx CCMR1 register value */
stm32l4xx_ll_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 587 : 
  *       to the TI1 input channel
  * @note TIMx slave mode controller is configured in reset mode.
          Selected internal trigger is TI1F_ED.
  * @note Channel 1 is configured as input, IC1 is mapped on TRC.
  * @note Captured value stored in TIMx_CCR1 correspond to the time elapsed
LL_TIM_HALLSENSOR_Init in stm32l4xx_ll_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Disable the CC1 and CC2: Reset the CC1E and CC2E Bits */
  TIMx->CCER &= (uint32_t)~(TIM_CCER_CC1E | TIM_CCER_CC2E);

  /* Get the TIMx CR2 register value */
LL_TIM_HALLSENSOR_Init in stm32l4xx_ll_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  tmpsmcr |= LL_TIM_TS_TI1F_ED;
  tmpsmcr |= LL_TIM_SLAVEMODE_RESET;

  /* Configure input channel 1 */
  tmpccmr1 &= (uint32_t)~(TIM_CCMR1_CC1S | TIM_CCMR1_IC1F  | TIM_CCMR1_IC1PSC);
OC1Config in stm32l4xx_ll_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Disable the Channel 1: Reset the CC1E Bit */
  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC1E);

  /* Get the TIMx CCER register value */
OC1Config in stm32l4xx_ll_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset Capture/Compare selection Bits */
  CLEAR_BIT(tmpccmr1, TIM_CCMR1_CC1S);

  /* Set the Output Compare Mode */
OC2Config in stm32l4xx_ll_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Disable the Channel 2: Reset the CC2E Bit */
  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC2E);

  /* Get the TIMx CCER register value */
OC2Config in stm32l4xx_ll_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset Capture/Compare selection Bits */
  CLEAR_BIT(tmpccmr1, TIM_CCMR1_CC2S);

  /* Select the Output Compare Mode */
OC3Config in stm32l4xx_ll_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Disable the Channel 3: Reset the CC3E Bit */
  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC3E);

  /* Get the TIMx CCER register value */
OC3Config in stm32l4xx_ll_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset Capture/Compare selection Bits */
  CLEAR_BIT(tmpccmr2, TIM_CCMR2_CC3S);

  /* Select the Output Compare Mode */
OC4Config in stm32l4xx_ll_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Disable the Channel 4: Reset the CC4E Bit */
  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC4E);

  /* Get the TIMx CCER register value */
OC4Config in stm32l4xx_ll_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Reset Capture/Compare selection Bits */
  CLEAR_BIT(tmpccmr2, TIM_CCMR2_CC4S);

  /* Select the Output Compare Mode */
OC5Config in stm32l4xx_ll_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Disable the Channel 5: Reset the CC5E Bit */
  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC5E);

  /* Get the TIMx CCER register value */
OC6Config in stm32l4xx_ll_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Disable the Channel 5: Reset the CC6E Bit */
  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC6E);

  /* Get the TIMx CCER register value */
IC1Config in stm32l4xx_ll_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC1E;

  /* Select the Input and set the filter and the prescaler value */
IC2Config in stm32l4xx_ll_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC2E;

  /* Select the Input and set the filter and the prescaler value */
IC3Config in stm32l4xx_ll_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC3E;

  /* Select the Input and set the filter and the prescaler value */
IC4Config in stm32l4xx_ll_tim.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC4E;

  /* Select the Input and set the filter and the prescaler value */
{anonLL_TIM_BDTR_InitTypeDef} in stm32l4xx_ll_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) : 

                                      @note The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register
                                            has been written, their content is frozen until the next reset.*/

  uint8_t DeadTime;              /*!< Specifies the delay time between the switching-off and the
                                      switching-on of the outputs.
stm32l4xx_ll_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 831 : 
  */
#define LL_TIM_TRGO_RESET                      0x00000000U                                     /*!< UG bit from the TIMx_EGR register is used as trigger output */
#define LL_TIM_TRGO_ENABLE                     TIM_CR2_MMS_0                                   /*!< Counter Enable signal (CNT_EN) is used as trigger output */
#define LL_TIM_TRGO_UPDATE                     TIM_CR2_MMS_1                                   /*!< Update event is used as trigger output */
#define LL_TIM_TRGO_CC1IF                      (TIM_CR2_MMS_1 | TIM_CR2_MMS_0)                 /*!< CC1 capture or a compare match is used as trigger output */
stm32l4xx_ll_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 846 : 
  */
#define LL_TIM_TRGO2_RESET                     0x00000000U                                                         /*!< UG bit from the TIMx_EGR register is used as trigger output 2 */
#define LL_TIM_TRGO2_ENABLE                    TIM_CR2_MMS2_0                                                      /*!< Counter Enable signal (CNT_EN) is used as trigger output 2 */
#define LL_TIM_TRGO2_UPDATE                    TIM_CR2_MMS2_1                                                      /*!< Update event is used as trigger output 2 */
#define LL_TIM_TRGO2_CC1F                      (TIM_CR2_MMS2_1 | TIM_CR2_MMS2_0)                                   /*!< CC1 capture or a compare match is used as trigger output 2 */
stm32l4xx_ll_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 870 : 
#define LL_TIM_SLAVEMODE_DISABLED              0x00000000U                         /*!< Slave mode disabled */
#define LL_TIM_SLAVEMODE_RESET                 TIM_SMCR_SMS_2                      /*!< Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter */
#define LL_TIM_SLAVEMODE_GATED                 (TIM_SMCR_SMS_2 | TIM_SMCR_SMS_0)   /*!< Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high */
#define LL_TIM_SLAVEMODE_TRIGGER               (TIM_SMCR_SMS_2 | TIM_SMCR_SMS_1)   /*!< Trigger Mode - The counter starts at a rising edge of the trigger TRGI */
#define LL_TIM_SLAVEMODE_COMBINED_RESETTRIGGER TIM_SMCR_SMS_3                      /*!< Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI)  reinitializes the counter, generates an update of the registers and starts the counter */
/**
  * @}
  */
LL_TIM_IsEnabledUpdateEvent in stm32l4xx_ll_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) : 
{
  return ((READ_BIT(TIMx->CR1, TIM_CR1_UDIS) == (uint32_t)RESET) ? 1UL : 0UL);
}

/**
stm32l4xx_ll_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 1568 : 
  * @note Switching from Center Aligned counter mode to Edge counter mode (or reverse)
  *       requires a timer reset to avoid unexpected direction
  *       due to DIR bit readonly in center aligned mode.
  * @rmtoll CR1          DIR           LL_TIM_SetCounterMode\n
  *         CR1          CMS           LL_TIM_SetCounterMode
stm32l4xx_ll_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 3221 : 
  * @param  TimerSynchronization This parameter can be one of the following values:
  *         @arg @ref LL_TIM_TRGO_RESET
  *         @arg @ref LL_TIM_TRGO_ENABLE
  *         @arg @ref LL_TIM_TRGO_UPDATE
  *         @arg @ref LL_TIM_TRGO_CC1IF
stm32l4xx_ll_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 3243 : 
  * @param  ADCSynchronization This parameter can be one of the following values:
  *         @arg @ref LL_TIM_TRGO2_RESET
  *         @arg @ref LL_TIM_TRGO2_ENABLE
  *         @arg @ref LL_TIM_TRGO2_UPDATE
  *         @arg @ref LL_TIM_TRGO2_CC1F
stm32l4xx_ll_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 3274 : 
  *         @arg @ref LL_TIM_SLAVEMODE_DISABLED
  *         @arg @ref LL_TIM_SLAVEMODE_RESET
  *         @arg @ref LL_TIM_SLAVEMODE_GATED
  *         @arg @ref LL_TIM_SLAVEMODE_TRIGGER
  *         @arg @ref LL_TIM_SLAVEMODE_COMBINED_RESETTRIGGER
  * @retval None
  */
__STATIC_INLINE void LL_TIM_SetSlaveMode(TIM_TypeDef *TIMx, uint32_t SlaveMode)
stm32l4xx_ll_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 3595 : 
  * @note The MOE bit in TIMx_BDTR register allows to enable /disable the outputs by
  *       software and is reset in case of break or break2 event
  * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
  *       a timer instance provides a break input.
  * @rmtoll BDTR         MOE           LL_TIM_EnableAllOutputs
stm32l4xx_ll_tim.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 3608 : 
/**
  * @brief  Disable the outputs (reset the MOE bit in TIMx_BDTR register).
  * @note The MOE bit in TIMx_BDTR register allows to enable /disable the outputs by
  *       software and is reset in case of break or break2 event.
  * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
  *       a timer instance provides a break input.
  * @rmtoll BDTR         MOE           LL_TIM_DisableAllOutputs
LL_USART_DeInit in stm32l4xx_ll_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Force reset of USART clock */
    LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_USART1);

    /* Release reset of USART clock */
    LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_USART1);
  }
  else if (USARTx == USART2)
  {
    /* Force reset of USART clock */
    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_USART2);

    /* Release reset of USART clock */
    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_USART2);
  }
#if defined(USART3)
  else if (USARTx == USART3)
  {
    /* Force reset of USART clock */
    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_USART3);

    /* Release reset of USART clock */
    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_USART3);
  }
#endif /* USART3 */
#if defined(UART4)
LL_USART_DeInit in stm32l4xx_ll_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Force reset of UART clock */
    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_UART4);

    /* Release reset of UART clock */
    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_UART4);
  }
#endif /* UART4 */
#if defined(UART5)
LL_USART_DeInit in stm32l4xx_ll_usart.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
  {
    /* Force reset of UART clock */
    LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_UART5);

    /* Release reset of UART clock */
    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_UART5);
  }
#endif /* UART5 */
  else
stm32l4xx_ll_usb.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 55 : 
#if defined (USB_OTG_FS)
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx);

/* Exported functions --------------------------------------------------------*/
/** @defgroup USB_LL_Exported_Functions USB Low Layer Exported Functions
USB_CoreInit in stm32l4xx_ll_usb.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
    }
    /* Reset after a PHY select  */
    ret = USB_CoreReset(USBx);
  }
  else /* FS interface (embedded Phy) */
  {
USB_CoreInit in stm32l4xx_ll_usb.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

    /* Reset after a PHY select and set Host mode */
    ret = USB_CoreReset(USBx);

    if (cfg.battery_charging_enable == 0U)
    {
stm32l4xx_ll_usb.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 1153 : 
/**
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t count = 0U;

USB_CoreReset in stm32l4xx_ll_usb.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

  /* Core Soft Reset */
  count = 0U;
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;

stm32l4xx_ll_usb.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) line 1283 : 
/**
* @brief  USB_OTG_ResetPort : Reset Host Port
  * @param  USBx  Selected device
  * @retval HAL status
  * @note (1)The application must wait at least 10 ms
  *   before clearing the reset bit.
  */
HAL_StatusTypeDef USB_ResetPort(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t USBx_BASE = (uint32_t)USBx;

USB_EnableGlobalInt in stm32l4xx_ll_usb.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
                   USB_CNTR_SOFM | USB_CNTR_ESOFM |
                   USB_CNTR_RESETM | USB_CNTR_L1REQM;

  /* Set interrupt mask */
  USBx->CNTR |= winterruptmask;
USB_DisableGlobalInt in stm32l4xx_ll_usb.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
                   USB_CNTR_SOFM | USB_CNTR_ESOFM |
                   USB_CNTR_RESETM | USB_CNTR_L1REQM;

  /* Clear interrupt mask */
  USBx->CNTR &= ~winterruptmask;
USB_ActivateEndpoint in stm32l4xx_ll_usb.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

      /* Reset value of the data toggle bits for the endpoint out */
      PCD_TX_DTOG(USBx, ep->num);

      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
USB_DeactivateEndpoint in stm32l4xx_ll_usb.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 

      /* Reset value of the data toggle bits for the endpoint out*/
      PCD_TX_DTOG(USBx, ep->num);

      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
USB_StopDevice in stm32l4xx_ll_usb.c (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Src) : 
{
  /* disable all interrupts and force USB reset */
  USBx->CNTR = USB_CNTR_FRES;

  /* clear interrupt status register */
stm32l4xx_ll_usb.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 574 : 
HAL_StatusTypeDef USB_InitFSLSPClkSel(USB_OTG_GlobalTypeDef *USBx, uint8_t freq);
HAL_StatusTypeDef USB_ResetPort(USB_OTG_GlobalTypeDef *USBx);
HAL_StatusTypeDef USB_DriveVbus(USB_OTG_GlobalTypeDef *USBx, uint8_t state);
uint32_t          USB_GetHostSpeed(USB_OTG_GlobalTypeDef *USBx);
uint32_t          USB_GetCurrentFrame(USB_OTG_GlobalTypeDef *USBx);
stm32l4xx_ll_wwdg.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 113 : 
/**
  * @brief  Enable Window Watchdog. The watchdog is always disabled after a reset.
  * @note   It is enabled by setting the WDGA bit in the WWDG_CR register,
  *         then it cannot be disabled again except by a reset.
  *         This bit is set by software and only cleared by hardware after a reset.
  *         When WDGA = 1, the watchdog can generate a reset.
  * @rmtoll CR           WDGA          LL_WWDG_Enable
  * @param  WWDGx WWDG Instance
  * @retval None
stm32l4xx_ll_wwdg.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 140 : 
  * @brief  Set the Watchdog counter value to provided value (7-bits T[6:0])
  * @note   When writing to the WWDG_CR register, always write 1 in the MSB b6 to avoid generating an immediate reset
  *         This counter is decremented every (4096 x 2expWDGTB) PCLK cycles
  *         A reset is produced when it rolls over from 0x40 to 0x3F (bit T6 becomes cleared)
  *         Setting the counter lower then 0x40 causes an immediate reset (if WWDG enabled)
  * @rmtoll CR           T             LL_WWDG_SetCounter
  * @param  WWDGx WWDG Instance
  * @param  Counter 0..0x7F (7 bit counter value)
stm32l4xx_ll_wwdg.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 204 : 
  *         is lower than the Watchdog window register value.
  *         Otherwise, a MCU reset is generated if the 7-bit Watchdog counter value
  *         (in the control register) is refreshed before the downcounter has reached
  *         the watchdog window register value.
  *         Physically is possible to set the Window lower then 0x40 but it is not recommended.
  *         To generate an immediate reset, it is possible to set the Counter lower than 0x40.
  * @rmtoll CFR          W             LL_WWDG_SetWindow
  * @param  WWDGx WWDG Instance
  * @param  Window 0x00..0x7F (7 bit Window value)
stm32l4xx_ll_wwdg.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc) line 272 : 
  * @note   When set, an interrupt occurs whenever the counter reaches value 0x40.
  *         This interrupt is only cleared by hardware after a reset
  * @rmtoll CFR          EWI           LL_WWDG_EnableIT_EWKUP
  * @param  WWDGx WWDG Instance
  * @retval None
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 441 : 
#define OB_SDADC12_VDD_MONITOR_SET    OB_SDACD_VDD_MONITOR_SET
#define OB_SDADC12_VDD_MONITOR_RESET  OB_SDACD_VDD_MONITOR_RESET
#define OB_RAM_PARITY_CHECK_SET       OB_SRAM_PARITY_SET
#define OB_RAM_PARITY_CHECK_RESET     OB_SRAM_PARITY_RESET
#define IS_OB_SDADC12_VDD_MONITOR     IS_OB_SDACD_VDD_MONITOR
#define OB_RDP_LEVEL0                 OB_RDP_LEVEL_0
#define OB_RDP_LEVEL1                 OB_RDP_LEVEL_1
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 475 : 
#define __HAL_RCC_JPEG_CLK_DISABLE              __HAL_RCC_JPGDECEN_CLK_DISABLE
#define __HAL_RCC_JPEG_FORCE_RESET              __HAL_RCC_JPGDECRST_FORCE_RESET
#define __HAL_RCC_JPEG_RELEASE_RESET            __HAL_RCC_JPGDECRST_RELEASE_RESET
#define __HAL_RCC_JPEG_CLK_SLEEP_ENABLE         __HAL_RCC_JPGDEC_CLK_SLEEP_ENABLE
#define __HAL_RCC_JPEG_CLK_SLEEP_DISABLE        __HAL_RCC_JPGDEC_CLK_SLEEP_DISABLE
#endif /* STM32H7 */
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 623 : 
#define HAL_HRTIM_ExternalEventCounterDisable   HAL_HRTIM_ExtEventCounterDisable
#define HAL_HRTIM_ExternalEventCounterReset     HAL_HRTIM_ExtEventCounterReset
#endif /* STM32G4 */
/**
  * @}
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 1866 : 

#define __HAL_I2C_RESET_CR2             I2C_RESET_CR2
#define __HAL_I2C_GENERATE_START        I2C_GENERATE_START
#if defined(STM32F1)
#define __HAL_I2C_FREQ_RANGE            I2C_FREQRANGE
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 2040 : 
#define __ADC_CLK_SLEEP_ENABLE     __HAL_RCC_ADC_CLK_SLEEP_ENABLE
#define __ADC_FORCE_RESET          __HAL_RCC_ADC_FORCE_RESET
#define __ADC_RELEASE_RESET        __HAL_RCC_ADC_RELEASE_RESET
#define __ADC1_CLK_DISABLE         __HAL_RCC_ADC1_CLK_DISABLE
#define __ADC1_CLK_ENABLE          __HAL_RCC_ADC1_CLK_ENABLE
#define __ADC1_FORCE_RESET         __HAL_RCC_ADC1_FORCE_RESET
#define __ADC1_RELEASE_RESET       __HAL_RCC_ADC1_RELEASE_RESET
#define __ADC1_CLK_SLEEP_ENABLE    __HAL_RCC_ADC1_CLK_SLEEP_ENABLE
#define __ADC1_CLK_SLEEP_DISABLE   __HAL_RCC_ADC1_CLK_SLEEP_DISABLE
#define __ADC2_CLK_DISABLE         __HAL_RCC_ADC2_CLK_DISABLE
#define __ADC2_CLK_ENABLE          __HAL_RCC_ADC2_CLK_ENABLE
#define __ADC2_FORCE_RESET __HAL_RCC_ADC2_FORCE_RESET
#define __ADC2_RELEASE_RESET __HAL_RCC_ADC2_RELEASE_RESET
#define __ADC3_CLK_DISABLE __HAL_RCC_ADC3_CLK_DISABLE
#define __ADC3_CLK_ENABLE __HAL_RCC_ADC3_CLK_ENABLE
#define __ADC3_FORCE_RESET __HAL_RCC_ADC3_FORCE_RESET
#define __ADC3_RELEASE_RESET __HAL_RCC_ADC3_RELEASE_RESET
#define __AES_CLK_DISABLE __HAL_RCC_AES_CLK_DISABLE
#define __AES_CLK_ENABLE __HAL_RCC_AES_CLK_ENABLE
#define __AES_CLK_SLEEP_DISABLE __HAL_RCC_AES_CLK_SLEEP_DISABLE
#define __AES_CLK_SLEEP_ENABLE __HAL_RCC_AES_CLK_SLEEP_ENABLE
#define __AES_FORCE_RESET __HAL_RCC_AES_FORCE_RESET
#define __AES_RELEASE_RESET __HAL_RCC_AES_RELEASE_RESET
#define __CRYP_CLK_SLEEP_ENABLE      __HAL_RCC_CRYP_CLK_SLEEP_ENABLE
#define __CRYP_CLK_SLEEP_DISABLE  __HAL_RCC_CRYP_CLK_SLEEP_DISABLE
#define __CRYP_CLK_ENABLE  __HAL_RCC_CRYP_CLK_ENABLE
#define __CRYP_CLK_DISABLE  __HAL_RCC_CRYP_CLK_DISABLE
#define __CRYP_FORCE_RESET       __HAL_RCC_CRYP_FORCE_RESET
#define __CRYP_RELEASE_RESET  __HAL_RCC_CRYP_RELEASE_RESET
#define __AFIO_CLK_DISABLE __HAL_RCC_AFIO_CLK_DISABLE
#define __AFIO_CLK_ENABLE __HAL_RCC_AFIO_CLK_ENABLE
#define __AFIO_FORCE_RESET __HAL_RCC_AFIO_FORCE_RESET
#define __AFIO_RELEASE_RESET __HAL_RCC_AFIO_RELEASE_RESET
#define __AHB_FORCE_RESET __HAL_RCC_AHB_FORCE_RESET
#define __AHB_RELEASE_RESET __HAL_RCC_AHB_RELEASE_RESET
#define __AHB1_FORCE_RESET __HAL_RCC_AHB1_FORCE_RESET
#define __AHB1_RELEASE_RESET __HAL_RCC_AHB1_RELEASE_RESET
#define __AHB2_FORCE_RESET __HAL_RCC_AHB2_FORCE_RESET
#define __AHB2_RELEASE_RESET __HAL_RCC_AHB2_RELEASE_RESET
#define __AHB3_FORCE_RESET __HAL_RCC_AHB3_FORCE_RESET
#define __AHB3_RELEASE_RESET __HAL_RCC_AHB3_RELEASE_RESET
#define __APB1_FORCE_RESET __HAL_RCC_APB1_FORCE_RESET
#define __APB1_RELEASE_RESET __HAL_RCC_APB1_RELEASE_RESET
#define __APB2_FORCE_RESET __HAL_RCC_APB2_FORCE_RESET
#define __APB2_RELEASE_RESET __HAL_RCC_APB2_RELEASE_RESET
#define __BKP_CLK_DISABLE __HAL_RCC_BKP_CLK_DISABLE
#define __BKP_CLK_ENABLE __HAL_RCC_BKP_CLK_ENABLE
#define __BKP_FORCE_RESET __HAL_RCC_BKP_FORCE_RESET
#define __BKP_RELEASE_RESET __HAL_RCC_BKP_RELEASE_RESET
#define __CAN1_CLK_DISABLE __HAL_RCC_CAN1_CLK_DISABLE
#define __CAN1_CLK_ENABLE __HAL_RCC_CAN1_CLK_ENABLE
#define __CAN1_CLK_SLEEP_DISABLE __HAL_RCC_CAN1_CLK_SLEEP_DISABLE
#define __CAN1_CLK_SLEEP_ENABLE __HAL_RCC_CAN1_CLK_SLEEP_ENABLE
#define __CAN1_FORCE_RESET __HAL_RCC_CAN1_FORCE_RESET
#define __CAN1_RELEASE_RESET __HAL_RCC_CAN1_RELEASE_RESET
#define __CAN_CLK_DISABLE         __HAL_RCC_CAN1_CLK_DISABLE
#define __CAN_CLK_ENABLE          __HAL_RCC_CAN1_CLK_ENABLE
#define __CAN_FORCE_RESET         __HAL_RCC_CAN1_FORCE_RESET
#define __CAN_RELEASE_RESET       __HAL_RCC_CAN1_RELEASE_RESET
#define __CAN2_CLK_DISABLE __HAL_RCC_CAN2_CLK_DISABLE
#define __CAN2_CLK_ENABLE __HAL_RCC_CAN2_CLK_ENABLE
#define __CAN2_FORCE_RESET __HAL_RCC_CAN2_FORCE_RESET
#define __CAN2_RELEASE_RESET __HAL_RCC_CAN2_RELEASE_RESET
#define __CEC_CLK_DISABLE __HAL_RCC_CEC_CLK_DISABLE
#define __CEC_CLK_ENABLE __HAL_RCC_CEC_CLK_ENABLE
#define __COMP_CLK_DISABLE        __HAL_RCC_COMP_CLK_DISABLE
#define __COMP_CLK_ENABLE         __HAL_RCC_COMP_CLK_ENABLE
#define __COMP_FORCE_RESET        __HAL_RCC_COMP_FORCE_RESET
#define __COMP_RELEASE_RESET      __HAL_RCC_COMP_RELEASE_RESET
#define __COMP_CLK_SLEEP_ENABLE   __HAL_RCC_COMP_CLK_SLEEP_ENABLE
#define __COMP_CLK_SLEEP_DISABLE  __HAL_RCC_COMP_CLK_SLEEP_DISABLE
#define __CEC_FORCE_RESET __HAL_RCC_CEC_FORCE_RESET
#define __CEC_RELEASE_RESET __HAL_RCC_CEC_RELEASE_RESET
#define __CRC_CLK_DISABLE __HAL_RCC_CRC_CLK_DISABLE
#define __CRC_CLK_ENABLE __HAL_RCC_CRC_CLK_ENABLE
#define __CRC_CLK_SLEEP_DISABLE __HAL_RCC_CRC_CLK_SLEEP_DISABLE
#define __CRC_CLK_SLEEP_ENABLE __HAL_RCC_CRC_CLK_SLEEP_ENABLE
#define __CRC_FORCE_RESET __HAL_RCC_CRC_FORCE_RESET
#define __CRC_RELEASE_RESET __HAL_RCC_CRC_RELEASE_RESET
#define __DAC_CLK_DISABLE __HAL_RCC_DAC_CLK_DISABLE
#define __DAC_CLK_ENABLE __HAL_RCC_DAC_CLK_ENABLE
#define __DAC_FORCE_RESET __HAL_RCC_DAC_FORCE_RESET
#define __DAC_RELEASE_RESET __HAL_RCC_DAC_RELEASE_RESET
#define __DAC1_CLK_DISABLE __HAL_RCC_DAC1_CLK_DISABLE
#define __DAC1_CLK_ENABLE __HAL_RCC_DAC1_CLK_ENABLE
#define __DAC1_CLK_SLEEP_DISABLE __HAL_RCC_DAC1_CLK_SLEEP_DISABLE
#define __DAC1_CLK_SLEEP_ENABLE __HAL_RCC_DAC1_CLK_SLEEP_ENABLE
#define __DAC1_FORCE_RESET __HAL_RCC_DAC1_FORCE_RESET
#define __DAC1_RELEASE_RESET __HAL_RCC_DAC1_RELEASE_RESET
#define __DBGMCU_CLK_ENABLE     __HAL_RCC_DBGMCU_CLK_ENABLE
#define __DBGMCU_CLK_DISABLE     __HAL_RCC_DBGMCU_CLK_DISABLE
#define __DBGMCU_FORCE_RESET    __HAL_RCC_DBGMCU_FORCE_RESET
#define __DBGMCU_RELEASE_RESET  __HAL_RCC_DBGMCU_RELEASE_RESET
#define __DFSDM_CLK_DISABLE __HAL_RCC_DFSDM_CLK_DISABLE
#define __DFSDM_CLK_ENABLE __HAL_RCC_DFSDM_CLK_ENABLE
#define __DFSDM_CLK_SLEEP_DISABLE __HAL_RCC_DFSDM_CLK_SLEEP_DISABLE
#define __DFSDM_CLK_SLEEP_ENABLE __HAL_RCC_DFSDM_CLK_SLEEP_ENABLE
#define __DFSDM_FORCE_RESET __HAL_RCC_DFSDM_FORCE_RESET
#define __DFSDM_RELEASE_RESET __HAL_RCC_DFSDM_RELEASE_RESET
#define __DMA1_CLK_DISABLE __HAL_RCC_DMA1_CLK_DISABLE
#define __DMA1_CLK_ENABLE __HAL_RCC_DMA1_CLK_ENABLE
#define __DMA1_CLK_SLEEP_DISABLE __HAL_RCC_DMA1_CLK_SLEEP_DISABLE
#define __DMA1_CLK_SLEEP_ENABLE __HAL_RCC_DMA1_CLK_SLEEP_ENABLE
#define __DMA1_FORCE_RESET __HAL_RCC_DMA1_FORCE_RESET
#define __DMA1_RELEASE_RESET __HAL_RCC_DMA1_RELEASE_RESET
#define __DMA2_CLK_DISABLE __HAL_RCC_DMA2_CLK_DISABLE
#define __DMA2_CLK_ENABLE __HAL_RCC_DMA2_CLK_ENABLE
#define __DMA2_CLK_SLEEP_DISABLE __HAL_RCC_DMA2_CLK_SLEEP_DISABLE
#define __DMA2_CLK_SLEEP_ENABLE __HAL_RCC_DMA2_CLK_SLEEP_ENABLE
#define __DMA2_FORCE_RESET __HAL_RCC_DMA2_FORCE_RESET
#define __DMA2_RELEASE_RESET __HAL_RCC_DMA2_RELEASE_RESET
#define __ETHMAC_CLK_DISABLE __HAL_RCC_ETHMAC_CLK_DISABLE
#define __ETHMAC_CLK_ENABLE __HAL_RCC_ETHMAC_CLK_ENABLE
#define __ETHMAC_FORCE_RESET __HAL_RCC_ETHMAC_FORCE_RESET
#define __ETHMAC_RELEASE_RESET __HAL_RCC_ETHMAC_RELEASE_RESET
#define __ETHMACRX_CLK_DISABLE __HAL_RCC_ETHMACRX_CLK_DISABLE
#define __ETHMACRX_CLK_ENABLE __HAL_RCC_ETHMACRX_CLK_ENABLE
#define __ETHMACTX_CLK_DISABLE __HAL_RCC_ETHMACTX_CLK_DISABLE
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 2164 : 
#define __FLASH_CLK_SLEEP_ENABLE __HAL_RCC_FLASH_CLK_SLEEP_ENABLE
#define __FLASH_FORCE_RESET __HAL_RCC_FLASH_FORCE_RESET
#define __FLASH_RELEASE_RESET __HAL_RCC_FLASH_RELEASE_RESET
#define __FLITF_CLK_DISABLE       __HAL_RCC_FLITF_CLK_DISABLE
#define __FLITF_CLK_ENABLE        __HAL_RCC_FLITF_CLK_ENABLE
#define __FLITF_FORCE_RESET       __HAL_RCC_FLITF_FORCE_RESET
#define __FLITF_RELEASE_RESET     __HAL_RCC_FLITF_RELEASE_RESET
#define __FLITF_CLK_SLEEP_ENABLE  __HAL_RCC_FLITF_CLK_SLEEP_ENABLE
#define __FLITF_CLK_SLEEP_DISABLE __HAL_RCC_FLITF_CLK_SLEEP_DISABLE
#define __FMC_CLK_DISABLE __HAL_RCC_FMC_CLK_DISABLE
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 2176 : 
#define __FMC_CLK_SLEEP_ENABLE __HAL_RCC_FMC_CLK_SLEEP_ENABLE
#define __FMC_FORCE_RESET __HAL_RCC_FMC_FORCE_RESET
#define __FMC_RELEASE_RESET __HAL_RCC_FMC_RELEASE_RESET
#define __FSMC_CLK_DISABLE __HAL_RCC_FSMC_CLK_DISABLE
#define __FSMC_CLK_ENABLE __HAL_RCC_FSMC_CLK_ENABLE
#define __GPIOA_CLK_DISABLE __HAL_RCC_GPIOA_CLK_DISABLE
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 2184 : 
#define __GPIOA_CLK_SLEEP_ENABLE __HAL_RCC_GPIOA_CLK_SLEEP_ENABLE
#define __GPIOA_FORCE_RESET __HAL_RCC_GPIOA_FORCE_RESET
#define __GPIOA_RELEASE_RESET __HAL_RCC_GPIOA_RELEASE_RESET
#define __GPIOB_CLK_DISABLE __HAL_RCC_GPIOB_CLK_DISABLE
#define __GPIOB_CLK_ENABLE __HAL_RCC_GPIOB_CLK_ENABLE
#define __GPIOB_CLK_SLEEP_DISABLE __HAL_RCC_GPIOB_CLK_SLEEP_DISABLE
#define __GPIOB_CLK_SLEEP_ENABLE __HAL_RCC_GPIOB_CLK_SLEEP_ENABLE
#define __GPIOB_FORCE_RESET __HAL_RCC_GPIOB_FORCE_RESET
#define __GPIOB_RELEASE_RESET __HAL_RCC_GPIOB_RELEASE_RESET
#define __GPIOC_CLK_DISABLE __HAL_RCC_GPIOC_CLK_DISABLE
#define __GPIOC_CLK_ENABLE __HAL_RCC_GPIOC_CLK_ENABLE
#define __GPIOC_CLK_SLEEP_DISABLE __HAL_RCC_GPIOC_CLK_SLEEP_DISABLE
#define __GPIOC_CLK_SLEEP_ENABLE __HAL_RCC_GPIOC_CLK_SLEEP_ENABLE
#define __GPIOC_FORCE_RESET __HAL_RCC_GPIOC_FORCE_RESET
#define __GPIOC_RELEASE_RESET __HAL_RCC_GPIOC_RELEASE_RESET
#define __GPIOD_CLK_DISABLE __HAL_RCC_GPIOD_CLK_DISABLE
#define __GPIOD_CLK_ENABLE __HAL_RCC_GPIOD_CLK_ENABLE
#define __GPIOD_CLK_SLEEP_DISABLE __HAL_RCC_GPIOD_CLK_SLEEP_DISABLE
#define __GPIOD_CLK_SLEEP_ENABLE __HAL_RCC_GPIOD_CLK_SLEEP_ENABLE
#define __GPIOD_FORCE_RESET __HAL_RCC_GPIOD_FORCE_RESET
#define __GPIOD_RELEASE_RESET __HAL_RCC_GPIOD_RELEASE_RESET
#define __GPIOE_CLK_DISABLE __HAL_RCC_GPIOE_CLK_DISABLE
#define __GPIOE_CLK_ENABLE __HAL_RCC_GPIOE_CLK_ENABLE
#define __GPIOE_CLK_SLEEP_DISABLE __HAL_RCC_GPIOE_CLK_SLEEP_DISABLE
#define __GPIOE_CLK_SLEEP_ENABLE __HAL_RCC_GPIOE_CLK_SLEEP_ENABLE
#define __GPIOE_FORCE_RESET __HAL_RCC_GPIOE_FORCE_RESET
#define __GPIOE_RELEASE_RESET __HAL_RCC_GPIOE_RELEASE_RESET
#define __GPIOF_CLK_DISABLE __HAL_RCC_GPIOF_CLK_DISABLE
#define __GPIOF_CLK_ENABLE __HAL_RCC_GPIOF_CLK_ENABLE
#define __GPIOF_CLK_SLEEP_DISABLE __HAL_RCC_GPIOF_CLK_SLEEP_DISABLE
#define __GPIOF_CLK_SLEEP_ENABLE __HAL_RCC_GPIOF_CLK_SLEEP_ENABLE
#define __GPIOF_FORCE_RESET __HAL_RCC_GPIOF_FORCE_RESET
#define __GPIOF_RELEASE_RESET __HAL_RCC_GPIOF_RELEASE_RESET
#define __GPIOG_CLK_DISABLE __HAL_RCC_GPIOG_CLK_DISABLE
#define __GPIOG_CLK_ENABLE __HAL_RCC_GPIOG_CLK_ENABLE
#define __GPIOG_CLK_SLEEP_DISABLE __HAL_RCC_GPIOG_CLK_SLEEP_DISABLE
#define __GPIOG_CLK_SLEEP_ENABLE __HAL_RCC_GPIOG_CLK_SLEEP_ENABLE
#define __GPIOG_FORCE_RESET __HAL_RCC_GPIOG_FORCE_RESET
#define __GPIOG_RELEASE_RESET __HAL_RCC_GPIOG_RELEASE_RESET
#define __GPIOH_CLK_DISABLE __HAL_RCC_GPIOH_CLK_DISABLE
#define __GPIOH_CLK_ENABLE __HAL_RCC_GPIOH_CLK_ENABLE
#define __GPIOH_CLK_SLEEP_DISABLE __HAL_RCC_GPIOH_CLK_SLEEP_DISABLE
#define __GPIOH_CLK_SLEEP_ENABLE __HAL_RCC_GPIOH_CLK_SLEEP_ENABLE
#define __GPIOH_FORCE_RESET __HAL_RCC_GPIOH_FORCE_RESET
#define __GPIOH_RELEASE_RESET __HAL_RCC_GPIOH_RELEASE_RESET
#define __I2C1_CLK_DISABLE __HAL_RCC_I2C1_CLK_DISABLE
#define __I2C1_CLK_ENABLE __HAL_RCC_I2C1_CLK_ENABLE
#define __I2C1_CLK_SLEEP_DISABLE __HAL_RCC_I2C1_CLK_SLEEP_DISABLE
#define __I2C1_CLK_SLEEP_ENABLE __HAL_RCC_I2C1_CLK_SLEEP_ENABLE
#define __I2C1_FORCE_RESET __HAL_RCC_I2C1_FORCE_RESET
#define __I2C1_RELEASE_RESET __HAL_RCC_I2C1_RELEASE_RESET
#define __I2C2_CLK_DISABLE __HAL_RCC_I2C2_CLK_DISABLE
#define __I2C2_CLK_ENABLE __HAL_RCC_I2C2_CLK_ENABLE
#define __I2C2_CLK_SLEEP_DISABLE __HAL_RCC_I2C2_CLK_SLEEP_DISABLE
#define __I2C2_CLK_SLEEP_ENABLE __HAL_RCC_I2C2_CLK_SLEEP_ENABLE
#define __I2C2_FORCE_RESET __HAL_RCC_I2C2_FORCE_RESET
#define __I2C2_RELEASE_RESET __HAL_RCC_I2C2_RELEASE_RESET
#define __I2C3_CLK_DISABLE __HAL_RCC_I2C3_CLK_DISABLE
#define __I2C3_CLK_ENABLE __HAL_RCC_I2C3_CLK_ENABLE
#define __I2C3_CLK_SLEEP_DISABLE __HAL_RCC_I2C3_CLK_SLEEP_DISABLE
#define __I2C3_CLK_SLEEP_ENABLE __HAL_RCC_I2C3_CLK_SLEEP_ENABLE
#define __I2C3_FORCE_RESET __HAL_RCC_I2C3_FORCE_RESET
#define __I2C3_RELEASE_RESET __HAL_RCC_I2C3_RELEASE_RESET
#define __LCD_CLK_DISABLE __HAL_RCC_LCD_CLK_DISABLE
#define __LCD_CLK_ENABLE __HAL_RCC_LCD_CLK_ENABLE
#define __LCD_CLK_SLEEP_DISABLE __HAL_RCC_LCD_CLK_SLEEP_DISABLE
#define __LCD_CLK_SLEEP_ENABLE __HAL_RCC_LCD_CLK_SLEEP_ENABLE
#define __LCD_FORCE_RESET __HAL_RCC_LCD_FORCE_RESET
#define __LCD_RELEASE_RESET __HAL_RCC_LCD_RELEASE_RESET
#define __LPTIM1_CLK_DISABLE __HAL_RCC_LPTIM1_CLK_DISABLE
#define __LPTIM1_CLK_ENABLE __HAL_RCC_LPTIM1_CLK_ENABLE
#define __LPTIM1_CLK_SLEEP_DISABLE __HAL_RCC_LPTIM1_CLK_SLEEP_DISABLE
#define __LPTIM1_CLK_SLEEP_ENABLE __HAL_RCC_LPTIM1_CLK_SLEEP_ENABLE
#define __LPTIM1_FORCE_RESET __HAL_RCC_LPTIM1_FORCE_RESET
#define __LPTIM1_RELEASE_RESET __HAL_RCC_LPTIM1_RELEASE_RESET
#define __LPTIM2_CLK_DISABLE __HAL_RCC_LPTIM2_CLK_DISABLE
#define __LPTIM2_CLK_ENABLE __HAL_RCC_LPTIM2_CLK_ENABLE
#define __LPTIM2_CLK_SLEEP_DISABLE __HAL_RCC_LPTIM2_CLK_SLEEP_DISABLE
#define __LPTIM2_CLK_SLEEP_ENABLE __HAL_RCC_LPTIM2_CLK_SLEEP_ENABLE
#define __LPTIM2_FORCE_RESET __HAL_RCC_LPTIM2_FORCE_RESET
#define __LPTIM2_RELEASE_RESET __HAL_RCC_LPTIM2_RELEASE_RESET
#define __LPUART1_CLK_DISABLE __HAL_RCC_LPUART1_CLK_DISABLE
#define __LPUART1_CLK_ENABLE __HAL_RCC_LPUART1_CLK_ENABLE
#define __LPUART1_CLK_SLEEP_DISABLE __HAL_RCC_LPUART1_CLK_SLEEP_DISABLE
#define __LPUART1_CLK_SLEEP_ENABLE __HAL_RCC_LPUART1_CLK_SLEEP_ENABLE
#define __LPUART1_FORCE_RESET __HAL_RCC_LPUART1_FORCE_RESET
#define __LPUART1_RELEASE_RESET __HAL_RCC_LPUART1_RELEASE_RESET
#define __OPAMP_CLK_DISABLE __HAL_RCC_OPAMP_CLK_DISABLE
#define __OPAMP_CLK_ENABLE __HAL_RCC_OPAMP_CLK_ENABLE
#define __OPAMP_CLK_SLEEP_DISABLE __HAL_RCC_OPAMP_CLK_SLEEP_DISABLE
#define __OPAMP_CLK_SLEEP_ENABLE __HAL_RCC_OPAMP_CLK_SLEEP_ENABLE
#define __OPAMP_FORCE_RESET __HAL_RCC_OPAMP_FORCE_RESET
#define __OPAMP_RELEASE_RESET __HAL_RCC_OPAMP_RELEASE_RESET
#define __OTGFS_CLK_DISABLE __HAL_RCC_OTGFS_CLK_DISABLE
#define __OTGFS_CLK_ENABLE __HAL_RCC_OTGFS_CLK_ENABLE
#define __OTGFS_CLK_SLEEP_DISABLE __HAL_RCC_OTGFS_CLK_SLEEP_DISABLE
#define __OTGFS_CLK_SLEEP_ENABLE __HAL_RCC_OTGFS_CLK_SLEEP_ENABLE
#define __OTGFS_FORCE_RESET __HAL_RCC_OTGFS_FORCE_RESET
#define __OTGFS_RELEASE_RESET __HAL_RCC_OTGFS_RELEASE_RESET
#define __PWR_CLK_DISABLE __HAL_RCC_PWR_CLK_DISABLE
#define __PWR_CLK_ENABLE __HAL_RCC_PWR_CLK_ENABLE
#define __PWR_CLK_SLEEP_DISABLE __HAL_RCC_PWR_CLK_SLEEP_DISABLE
#define __PWR_CLK_SLEEP_ENABLE __HAL_RCC_PWR_CLK_SLEEP_ENABLE
#define __PWR_FORCE_RESET __HAL_RCC_PWR_FORCE_RESET
#define __PWR_RELEASE_RESET __HAL_RCC_PWR_RELEASE_RESET
#define __QSPI_CLK_DISABLE __HAL_RCC_QSPI_CLK_DISABLE
#define __QSPI_CLK_ENABLE __HAL_RCC_QSPI_CLK_ENABLE
#define __QSPI_CLK_SLEEP_DISABLE __HAL_RCC_QSPI_CLK_SLEEP_DISABLE
#define __QSPI_CLK_SLEEP_ENABLE __HAL_RCC_QSPI_CLK_SLEEP_ENABLE
#define __QSPI_FORCE_RESET __HAL_RCC_QSPI_FORCE_RESET
#define __QSPI_RELEASE_RESET __HAL_RCC_QSPI_RELEASE_RESET

#if defined(STM32WB)
#define __HAL_RCC_QSPI_CLK_DISABLE            __HAL_RCC_QUADSPI_CLK_DISABLE
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 2300 : 
#define __HAL_RCC_QSPI_CLK_SLEEP_ENABLE       __HAL_RCC_QUADSPI_CLK_SLEEP_ENABLE
#define __HAL_RCC_QSPI_FORCE_RESET            __HAL_RCC_QUADSPI_FORCE_RESET
#define __HAL_RCC_QSPI_RELEASE_RESET          __HAL_RCC_QUADSPI_RELEASE_RESET
#define __HAL_RCC_QSPI_IS_CLK_ENABLED         __HAL_RCC_QUADSPI_IS_CLK_ENABLED
#define __HAL_RCC_QSPI_IS_CLK_DISABLED        __HAL_RCC_QUADSPI_IS_CLK_DISABLED
#define __HAL_RCC_QSPI_IS_CLK_SLEEP_ENABLED   __HAL_RCC_QUADSPI_IS_CLK_SLEEP_ENABLED
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 2313 : 
#define __RNG_CLK_SLEEP_ENABLE __HAL_RCC_RNG_CLK_SLEEP_ENABLE
#define __RNG_FORCE_RESET __HAL_RCC_RNG_FORCE_RESET
#define __RNG_RELEASE_RESET __HAL_RCC_RNG_RELEASE_RESET
#define __SAI1_CLK_DISABLE __HAL_RCC_SAI1_CLK_DISABLE
#define __SAI1_CLK_ENABLE __HAL_RCC_SAI1_CLK_ENABLE
#define __SAI1_CLK_SLEEP_DISABLE __HAL_RCC_SAI1_CLK_SLEEP_DISABLE
#define __SAI1_CLK_SLEEP_ENABLE __HAL_RCC_SAI1_CLK_SLEEP_ENABLE
#define __SAI1_FORCE_RESET __HAL_RCC_SAI1_FORCE_RESET
#define __SAI1_RELEASE_RESET __HAL_RCC_SAI1_RELEASE_RESET
#define __SAI2_CLK_DISABLE __HAL_RCC_SAI2_CLK_DISABLE
#define __SAI2_CLK_ENABLE __HAL_RCC_SAI2_CLK_ENABLE
#define __SAI2_CLK_SLEEP_DISABLE __HAL_RCC_SAI2_CLK_SLEEP_DISABLE
#define __SAI2_CLK_SLEEP_ENABLE __HAL_RCC_SAI2_CLK_SLEEP_ENABLE
#define __SAI2_FORCE_RESET __HAL_RCC_SAI2_FORCE_RESET
#define __SAI2_RELEASE_RESET __HAL_RCC_SAI2_RELEASE_RESET
#define __SDIO_CLK_DISABLE __HAL_RCC_SDIO_CLK_DISABLE
#define __SDIO_CLK_ENABLE __HAL_RCC_SDIO_CLK_ENABLE
#define __SDMMC_CLK_DISABLE __HAL_RCC_SDMMC_CLK_DISABLE
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 2333 : 
#define __SDMMC_CLK_SLEEP_ENABLE __HAL_RCC_SDMMC_CLK_SLEEP_ENABLE
#define __SDMMC_FORCE_RESET __HAL_RCC_SDMMC_FORCE_RESET
#define __SDMMC_RELEASE_RESET __HAL_RCC_SDMMC_RELEASE_RESET
#define __SPI1_CLK_DISABLE __HAL_RCC_SPI1_CLK_DISABLE
#define __SPI1_CLK_ENABLE __HAL_RCC_SPI1_CLK_ENABLE
#define __SPI1_CLK_SLEEP_DISABLE __HAL_RCC_SPI1_CLK_SLEEP_DISABLE
#define __SPI1_CLK_SLEEP_ENABLE __HAL_RCC_SPI1_CLK_SLEEP_ENABLE
#define __SPI1_FORCE_RESET __HAL_RCC_SPI1_FORCE_RESET
#define __SPI1_RELEASE_RESET __HAL_RCC_SPI1_RELEASE_RESET
#define __SPI2_CLK_DISABLE __HAL_RCC_SPI2_CLK_DISABLE
#define __SPI2_CLK_ENABLE __HAL_RCC_SPI2_CLK_ENABLE
#define __SPI2_CLK_SLEEP_DISABLE __HAL_RCC_SPI2_CLK_SLEEP_DISABLE
#define __SPI2_CLK_SLEEP_ENABLE __HAL_RCC_SPI2_CLK_SLEEP_ENABLE
#define __SPI2_FORCE_RESET __HAL_RCC_SPI2_FORCE_RESET
#define __SPI2_RELEASE_RESET __HAL_RCC_SPI2_RELEASE_RESET
#define __SPI3_CLK_DISABLE __HAL_RCC_SPI3_CLK_DISABLE
#define __SPI3_CLK_ENABLE __HAL_RCC_SPI3_CLK_ENABLE
#define __SPI3_CLK_SLEEP_DISABLE __HAL_RCC_SPI3_CLK_SLEEP_DISABLE
#define __SPI3_CLK_SLEEP_ENABLE __HAL_RCC_SPI3_CLK_SLEEP_ENABLE
#define __SPI3_FORCE_RESET __HAL_RCC_SPI3_FORCE_RESET
#define __SPI3_RELEASE_RESET __HAL_RCC_SPI3_RELEASE_RESET
#define __SRAM_CLK_DISABLE __HAL_RCC_SRAM_CLK_DISABLE
#define __SRAM_CLK_ENABLE __HAL_RCC_SRAM_CLK_ENABLE
#define __SRAM1_CLK_SLEEP_DISABLE __HAL_RCC_SRAM1_CLK_SLEEP_DISABLE
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 2363 : 
#define __SWPMI1_CLK_SLEEP_ENABLE __HAL_RCC_SWPMI1_CLK_SLEEP_ENABLE
#define __SWPMI1_FORCE_RESET __HAL_RCC_SWPMI1_FORCE_RESET
#define __SWPMI1_RELEASE_RESET __HAL_RCC_SWPMI1_RELEASE_RESET
#define __SYSCFG_CLK_DISABLE __HAL_RCC_SYSCFG_CLK_DISABLE
#define __SYSCFG_CLK_ENABLE __HAL_RCC_SYSCFG_CLK_ENABLE
#define __SYSCFG_CLK_SLEEP_DISABLE __HAL_RCC_SYSCFG_CLK_SLEEP_DISABLE
#define __SYSCFG_CLK_SLEEP_ENABLE __HAL_RCC_SYSCFG_CLK_SLEEP_ENABLE
#define __SYSCFG_FORCE_RESET __HAL_RCC_SYSCFG_FORCE_RESET
#define __SYSCFG_RELEASE_RESET __HAL_RCC_SYSCFG_RELEASE_RESET
#define __TIM1_CLK_DISABLE __HAL_RCC_TIM1_CLK_DISABLE
#define __TIM1_CLK_ENABLE __HAL_RCC_TIM1_CLK_ENABLE
#define __TIM1_CLK_SLEEP_DISABLE __HAL_RCC_TIM1_CLK_SLEEP_DISABLE
#define __TIM1_CLK_SLEEP_ENABLE __HAL_RCC_TIM1_CLK_SLEEP_ENABLE
#define __TIM1_FORCE_RESET __HAL_RCC_TIM1_FORCE_RESET
#define __TIM1_RELEASE_RESET __HAL_RCC_TIM1_RELEASE_RESET
#define __TIM10_CLK_DISABLE __HAL_RCC_TIM10_CLK_DISABLE
#define __TIM10_CLK_ENABLE __HAL_RCC_TIM10_CLK_ENABLE
#define __TIM10_FORCE_RESET __HAL_RCC_TIM10_FORCE_RESET
#define __TIM10_RELEASE_RESET __HAL_RCC_TIM10_RELEASE_RESET
#define __TIM11_CLK_DISABLE __HAL_RCC_TIM11_CLK_DISABLE
#define __TIM11_CLK_ENABLE __HAL_RCC_TIM11_CLK_ENABLE
#define __TIM11_FORCE_RESET __HAL_RCC_TIM11_FORCE_RESET
#define __TIM11_RELEASE_RESET __HAL_RCC_TIM11_RELEASE_RESET
#define __TIM12_CLK_DISABLE __HAL_RCC_TIM12_CLK_DISABLE
#define __TIM12_CLK_ENABLE __HAL_RCC_TIM12_CLK_ENABLE
#define __TIM12_FORCE_RESET __HAL_RCC_TIM12_FORCE_RESET
#define __TIM12_RELEASE_RESET __HAL_RCC_TIM12_RELEASE_RESET
#define __TIM13_CLK_DISABLE __HAL_RCC_TIM13_CLK_DISABLE
#define __TIM13_CLK_ENABLE __HAL_RCC_TIM13_CLK_ENABLE
#define __TIM13_FORCE_RESET __HAL_RCC_TIM13_FORCE_RESET
#define __TIM13_RELEASE_RESET __HAL_RCC_TIM13_RELEASE_RESET
#define __TIM14_CLK_DISABLE __HAL_RCC_TIM14_CLK_DISABLE
#define __TIM14_CLK_ENABLE __HAL_RCC_TIM14_CLK_ENABLE
#define __TIM14_FORCE_RESET __HAL_RCC_TIM14_FORCE_RESET
#define __TIM14_RELEASE_RESET __HAL_RCC_TIM14_RELEASE_RESET
#define __TIM15_CLK_DISABLE __HAL_RCC_TIM15_CLK_DISABLE
#define __TIM15_CLK_ENABLE __HAL_RCC_TIM15_CLK_ENABLE
#define __TIM15_CLK_SLEEP_DISABLE __HAL_RCC_TIM15_CLK_SLEEP_DISABLE
#define __TIM15_CLK_SLEEP_ENABLE __HAL_RCC_TIM15_CLK_SLEEP_ENABLE
#define __TIM15_FORCE_RESET __HAL_RCC_TIM15_FORCE_RESET
#define __TIM15_RELEASE_RESET __HAL_RCC_TIM15_RELEASE_RESET
#define __TIM16_CLK_DISABLE __HAL_RCC_TIM16_CLK_DISABLE
#define __TIM16_CLK_ENABLE __HAL_RCC_TIM16_CLK_ENABLE
#define __TIM16_CLK_SLEEP_DISABLE __HAL_RCC_TIM16_CLK_SLEEP_DISABLE
#define __TIM16_CLK_SLEEP_ENABLE __HAL_RCC_TIM16_CLK_SLEEP_ENABLE
#define __TIM16_FORCE_RESET __HAL_RCC_TIM16_FORCE_RESET
#define __TIM16_RELEASE_RESET __HAL_RCC_TIM16_RELEASE_RESET
#define __TIM17_CLK_DISABLE __HAL_RCC_TIM17_CLK_DISABLE
#define __TIM17_CLK_ENABLE __HAL_RCC_TIM17_CLK_ENABLE
#define __TIM17_CLK_SLEEP_DISABLE __HAL_RCC_TIM17_CLK_SLEEP_DISABLE
#define __TIM17_CLK_SLEEP_ENABLE __HAL_RCC_TIM17_CLK_SLEEP_ENABLE
#define __TIM17_FORCE_RESET __HAL_RCC_TIM17_FORCE_RESET
#define __TIM17_RELEASE_RESET __HAL_RCC_TIM17_RELEASE_RESET
#define __TIM2_CLK_DISABLE __HAL_RCC_TIM2_CLK_DISABLE
#define __TIM2_CLK_ENABLE __HAL_RCC_TIM2_CLK_ENABLE
#define __TIM2_CLK_SLEEP_DISABLE __HAL_RCC_TIM2_CLK_SLEEP_DISABLE
#define __TIM2_CLK_SLEEP_ENABLE __HAL_RCC_TIM2_CLK_SLEEP_ENABLE
#define __TIM2_FORCE_RESET __HAL_RCC_TIM2_FORCE_RESET
#define __TIM2_RELEASE_RESET __HAL_RCC_TIM2_RELEASE_RESET
#define __TIM3_CLK_DISABLE __HAL_RCC_TIM3_CLK_DISABLE
#define __TIM3_CLK_ENABLE __HAL_RCC_TIM3_CLK_ENABLE
#define __TIM3_CLK_SLEEP_DISABLE __HAL_RCC_TIM3_CLK_SLEEP_DISABLE
#define __TIM3_CLK_SLEEP_ENABLE __HAL_RCC_TIM3_CLK_SLEEP_ENABLE
#define __TIM3_FORCE_RESET __HAL_RCC_TIM3_FORCE_RESET
#define __TIM3_RELEASE_RESET __HAL_RCC_TIM3_RELEASE_RESET
#define __TIM4_CLK_DISABLE __HAL_RCC_TIM4_CLK_DISABLE
#define __TIM4_CLK_ENABLE __HAL_RCC_TIM4_CLK_ENABLE
#define __TIM4_CLK_SLEEP_DISABLE __HAL_RCC_TIM4_CLK_SLEEP_DISABLE
#define __TIM4_CLK_SLEEP_ENABLE __HAL_RCC_TIM4_CLK_SLEEP_ENABLE
#define __TIM4_FORCE_RESET __HAL_RCC_TIM4_FORCE_RESET
#define __TIM4_RELEASE_RESET __HAL_RCC_TIM4_RELEASE_RESET
#define __TIM5_CLK_DISABLE __HAL_RCC_TIM5_CLK_DISABLE
#define __TIM5_CLK_ENABLE __HAL_RCC_TIM5_CLK_ENABLE
#define __TIM5_CLK_SLEEP_DISABLE __HAL_RCC_TIM5_CLK_SLEEP_DISABLE
#define __TIM5_CLK_SLEEP_ENABLE __HAL_RCC_TIM5_CLK_SLEEP_ENABLE
#define __TIM5_FORCE_RESET __HAL_RCC_TIM5_FORCE_RESET
#define __TIM5_RELEASE_RESET __HAL_RCC_TIM5_RELEASE_RESET
#define __TIM6_CLK_DISABLE __HAL_RCC_TIM6_CLK_DISABLE
#define __TIM6_CLK_ENABLE __HAL_RCC_TIM6_CLK_ENABLE
#define __TIM6_CLK_SLEEP_DISABLE __HAL_RCC_TIM6_CLK_SLEEP_DISABLE
#define __TIM6_CLK_SLEEP_ENABLE __HAL_RCC_TIM6_CLK_SLEEP_ENABLE
#define __TIM6_FORCE_RESET __HAL_RCC_TIM6_FORCE_RESET
#define __TIM6_RELEASE_RESET __HAL_RCC_TIM6_RELEASE_RESET
#define __TIM7_CLK_DISABLE __HAL_RCC_TIM7_CLK_DISABLE
#define __TIM7_CLK_ENABLE __HAL_RCC_TIM7_CLK_ENABLE
#define __TIM7_CLK_SLEEP_DISABLE __HAL_RCC_TIM7_CLK_SLEEP_DISABLE
#define __TIM7_CLK_SLEEP_ENABLE __HAL_RCC_TIM7_CLK_SLEEP_ENABLE
#define __TIM7_FORCE_RESET __HAL_RCC_TIM7_FORCE_RESET
#define __TIM7_RELEASE_RESET __HAL_RCC_TIM7_RELEASE_RESET
#define __TIM8_CLK_DISABLE __HAL_RCC_TIM8_CLK_DISABLE
#define __TIM8_CLK_ENABLE __HAL_RCC_TIM8_CLK_ENABLE
#define __TIM8_CLK_SLEEP_DISABLE __HAL_RCC_TIM8_CLK_SLEEP_DISABLE
#define __TIM8_CLK_SLEEP_ENABLE __HAL_RCC_TIM8_CLK_SLEEP_ENABLE
#define __TIM8_FORCE_RESET __HAL_RCC_TIM8_FORCE_RESET
#define __TIM8_RELEASE_RESET __HAL_RCC_TIM8_RELEASE_RESET
#define __TIM9_CLK_DISABLE __HAL_RCC_TIM9_CLK_DISABLE
#define __TIM9_CLK_ENABLE __HAL_RCC_TIM9_CLK_ENABLE
#define __TIM9_FORCE_RESET __HAL_RCC_TIM9_FORCE_RESET
#define __TIM9_RELEASE_RESET __HAL_RCC_TIM9_RELEASE_RESET
#define __TSC_CLK_DISABLE __HAL_RCC_TSC_CLK_DISABLE
#define __TSC_CLK_ENABLE __HAL_RCC_TSC_CLK_ENABLE
#define __TSC_CLK_SLEEP_DISABLE __HAL_RCC_TSC_CLK_SLEEP_DISABLE
#define __TSC_CLK_SLEEP_ENABLE __HAL_RCC_TSC_CLK_SLEEP_ENABLE
#define __TSC_FORCE_RESET __HAL_RCC_TSC_FORCE_RESET
#define __TSC_RELEASE_RESET __HAL_RCC_TSC_RELEASE_RESET
#define __UART4_CLK_DISABLE __HAL_RCC_UART4_CLK_DISABLE
#define __UART4_CLK_ENABLE __HAL_RCC_UART4_CLK_ENABLE
#define __UART4_CLK_SLEEP_DISABLE __HAL_RCC_UART4_CLK_SLEEP_DISABLE
#define __UART4_CLK_SLEEP_ENABLE __HAL_RCC_UART4_CLK_SLEEP_ENABLE
#define __UART4_FORCE_RESET __HAL_RCC_UART4_FORCE_RESET
#define __UART4_RELEASE_RESET __HAL_RCC_UART4_RELEASE_RESET
#define __UART5_CLK_DISABLE __HAL_RCC_UART5_CLK_DISABLE
#define __UART5_CLK_ENABLE __HAL_RCC_UART5_CLK_ENABLE
#define __UART5_CLK_SLEEP_DISABLE __HAL_RCC_UART5_CLK_SLEEP_DISABLE
#define __UART5_CLK_SLEEP_ENABLE __HAL_RCC_UART5_CLK_SLEEP_ENABLE
#define __UART5_FORCE_RESET __HAL_RCC_UART5_FORCE_RESET
#define __UART5_RELEASE_RESET __HAL_RCC_UART5_RELEASE_RESET
#define __USART1_CLK_DISABLE __HAL_RCC_USART1_CLK_DISABLE
#define __USART1_CLK_ENABLE __HAL_RCC_USART1_CLK_ENABLE
#define __USART1_CLK_SLEEP_DISABLE __HAL_RCC_USART1_CLK_SLEEP_DISABLE
#define __USART1_CLK_SLEEP_ENABLE __HAL_RCC_USART1_CLK_SLEEP_ENABLE
#define __USART1_FORCE_RESET __HAL_RCC_USART1_FORCE_RESET
#define __USART1_RELEASE_RESET __HAL_RCC_USART1_RELEASE_RESET
#define __USART2_CLK_DISABLE __HAL_RCC_USART2_CLK_DISABLE
#define __USART2_CLK_ENABLE __HAL_RCC_USART2_CLK_ENABLE
#define __USART2_CLK_SLEEP_DISABLE __HAL_RCC_USART2_CLK_SLEEP_DISABLE
#define __USART2_CLK_SLEEP_ENABLE __HAL_RCC_USART2_CLK_SLEEP_ENABLE
#define __USART2_FORCE_RESET __HAL_RCC_USART2_FORCE_RESET
#define __USART2_RELEASE_RESET __HAL_RCC_USART2_RELEASE_RESET
#define __USART3_CLK_DISABLE __HAL_RCC_USART3_CLK_DISABLE
#define __USART3_CLK_ENABLE __HAL_RCC_USART3_CLK_ENABLE
#define __USART3_CLK_SLEEP_DISABLE __HAL_RCC_USART3_CLK_SLEEP_DISABLE
#define __USART3_CLK_SLEEP_ENABLE __HAL_RCC_USART3_CLK_SLEEP_ENABLE
#define __USART3_FORCE_RESET __HAL_RCC_USART3_FORCE_RESET
#define __USART3_RELEASE_RESET __HAL_RCC_USART3_RELEASE_RESET
#define __USART4_CLK_DISABLE        __HAL_RCC_UART4_CLK_DISABLE
#define __USART4_CLK_ENABLE         __HAL_RCC_UART4_CLK_ENABLE
#define __USART4_CLK_SLEEP_ENABLE   __HAL_RCC_UART4_CLK_SLEEP_ENABLE
#define __USART4_CLK_SLEEP_DISABLE  __HAL_RCC_UART4_CLK_SLEEP_DISABLE
#define __USART4_FORCE_RESET        __HAL_RCC_UART4_FORCE_RESET
#define __USART4_RELEASE_RESET      __HAL_RCC_UART4_RELEASE_RESET
#define __USART5_CLK_DISABLE        __HAL_RCC_UART5_CLK_DISABLE
#define __USART5_CLK_ENABLE         __HAL_RCC_UART5_CLK_ENABLE
#define __USART5_CLK_SLEEP_ENABLE   __HAL_RCC_UART5_CLK_SLEEP_ENABLE
#define __USART5_CLK_SLEEP_DISABLE  __HAL_RCC_UART5_CLK_SLEEP_DISABLE
#define __USART5_FORCE_RESET        __HAL_RCC_UART5_FORCE_RESET
#define __USART5_RELEASE_RESET      __HAL_RCC_UART5_RELEASE_RESET
#define __USART7_CLK_DISABLE        __HAL_RCC_UART7_CLK_DISABLE
#define __USART7_CLK_ENABLE         __HAL_RCC_UART7_CLK_ENABLE
#define __USART7_FORCE_RESET        __HAL_RCC_UART7_FORCE_RESET
#define __USART7_RELEASE_RESET      __HAL_RCC_UART7_RELEASE_RESET
#define __USART8_CLK_DISABLE        __HAL_RCC_UART8_CLK_DISABLE
#define __USART8_CLK_ENABLE         __HAL_RCC_UART8_CLK_ENABLE
#define __USART8_FORCE_RESET        __HAL_RCC_UART8_FORCE_RESET
#define __USART8_RELEASE_RESET      __HAL_RCC_UART8_RELEASE_RESET
#define __USB_CLK_DISABLE         __HAL_RCC_USB_CLK_DISABLE
#define __USB_CLK_ENABLE          __HAL_RCC_USB_CLK_ENABLE
#define __USB_FORCE_RESET         __HAL_RCC_USB_FORCE_RESET
#define __USB_CLK_SLEEP_ENABLE    __HAL_RCC_USB_CLK_SLEEP_ENABLE
#define __USB_CLK_SLEEP_DISABLE   __HAL_RCC_USB_CLK_SLEEP_DISABLE
#define __USB_OTG_FS_CLK_DISABLE __HAL_RCC_USB_OTG_FS_CLK_DISABLE
#define __USB_OTG_FS_CLK_ENABLE __HAL_RCC_USB_OTG_FS_CLK_ENABLE
#define __USB_RELEASE_RESET __HAL_RCC_USB_RELEASE_RESET

#if defined(STM32H7)
#define __HAL_RCC_WWDG_CLK_DISABLE   __HAL_RCC_WWDG1_CLK_DISABLE
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 2532 : 

#define __HAL_RCC_WWDG_FORCE_RESET    ((void)0U)  /* Not available on the STM32H7*/
#define __HAL_RCC_WWDG_RELEASE_RESET ((void)0U) /* Not available on the STM32H7*/


#define  __HAL_RCC_WWDG_IS_CLK_ENABLED    __HAL_RCC_WWDG1_IS_CLK_ENABLED
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 2544 : 
#define __WWDG_CLK_SLEEP_ENABLE __HAL_RCC_WWDG_CLK_SLEEP_ENABLE
#define __WWDG_FORCE_RESET __HAL_RCC_WWDG_FORCE_RESET
#define __WWDG_RELEASE_RESET __HAL_RCC_WWDG_RELEASE_RESET

#define __TIM21_CLK_ENABLE   __HAL_RCC_TIM21_CLK_ENABLE
#define __TIM21_CLK_DISABLE   __HAL_RCC_TIM21_CLK_DISABLE
#define __TIM21_FORCE_RESET   __HAL_RCC_TIM21_FORCE_RESET
#define __TIM21_RELEASE_RESET  __HAL_RCC_TIM21_RELEASE_RESET
#define __TIM21_CLK_SLEEP_ENABLE   __HAL_RCC_TIM21_CLK_SLEEP_ENABLE
#define __TIM21_CLK_SLEEP_DISABLE   __HAL_RCC_TIM21_CLK_SLEEP_DISABLE
#define __TIM22_CLK_ENABLE   __HAL_RCC_TIM22_CLK_ENABLE
#define __TIM22_CLK_DISABLE   __HAL_RCC_TIM22_CLK_DISABLE
#define __TIM22_FORCE_RESET   __HAL_RCC_TIM22_FORCE_RESET
#define __TIM22_RELEASE_RESET  __HAL_RCC_TIM22_RELEASE_RESET
#define __TIM22_CLK_SLEEP_ENABLE   __HAL_RCC_TIM22_CLK_SLEEP_ENABLE
#define __TIM22_CLK_SLEEP_DISABLE   __HAL_RCC_TIM22_CLK_SLEEP_DISABLE
#define __CRS_CLK_DISABLE __HAL_RCC_CRS_CLK_DISABLE
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 2563 : 
#define __CRS_CLK_SLEEP_ENABLE __HAL_RCC_CRS_CLK_SLEEP_ENABLE
#define __CRS_FORCE_RESET __HAL_RCC_CRS_FORCE_RESET
#define __CRS_RELEASE_RESET __HAL_RCC_CRS_RELEASE_RESET
#define __RCC_BACKUPRESET_FORCE __HAL_RCC_BACKUPRESET_FORCE
#define __RCC_BACKUPRESET_RELEASE __HAL_RCC_BACKUPRESET_RELEASE

#define __USB_OTG_FS_FORCE_RESET  __HAL_RCC_USB_OTG_FS_FORCE_RESET
#define __USB_OTG_FS_RELEASE_RESET  __HAL_RCC_USB_OTG_FS_RELEASE_RESET
#define __USB_OTG_FS_CLK_SLEEP_ENABLE  __HAL_RCC_USB_OTG_FS_CLK_SLEEP_ENABLE
#define __USB_OTG_FS_CLK_SLEEP_DISABLE  __HAL_RCC_USB_OTG_FS_CLK_SLEEP_DISABLE
#define __USB_OTG_HS_CLK_DISABLE  __HAL_RCC_USB_OTG_HS_CLK_DISABLE
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 2587 : 
#define __HASH_CLK_ENABLE          __HAL_RCC_HASH_CLK_ENABLE
#define __HASH_FORCE_RESET          __HAL_RCC_HASH_FORCE_RESET
#define __HASH_RELEASE_RESET          __HAL_RCC_HASH_RELEASE_RESET
#define __HASH_CLK_SLEEP_ENABLE          __HAL_RCC_HASH_CLK_SLEEP_ENABLE
#define __HASH_CLK_SLEEP_DISABLE  __HAL_RCC_HASH_CLK_SLEEP_DISABLE
#define __HASH_CLK_DISABLE            __HAL_RCC_HASH_CLK_DISABLE
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 2594 : 
#define __SPI5_CLK_DISABLE              __HAL_RCC_SPI5_CLK_DISABLE
#define __SPI5_FORCE_RESET          __HAL_RCC_SPI5_FORCE_RESET
#define __SPI5_RELEASE_RESET          __HAL_RCC_SPI5_RELEASE_RESET
#define __SPI5_CLK_SLEEP_ENABLE          __HAL_RCC_SPI5_CLK_SLEEP_ENABLE
#define __SPI5_CLK_SLEEP_DISABLE  __HAL_RCC_SPI5_CLK_SLEEP_DISABLE
#define __SPI6_CLK_ENABLE          __HAL_RCC_SPI6_CLK_ENABLE
#define __SPI6_CLK_DISABLE          __HAL_RCC_SPI6_CLK_DISABLE
#define __SPI6_FORCE_RESET          __HAL_RCC_SPI6_FORCE_RESET
#define __SPI6_RELEASE_RESET         __HAL_RCC_SPI6_RELEASE_RESET
#define __SPI6_CLK_SLEEP_ENABLE          __HAL_RCC_SPI6_CLK_SLEEP_ENABLE
#define __SPI6_CLK_SLEEP_DISABLE  __HAL_RCC_SPI6_CLK_SLEEP_DISABLE
#define __LTDC_CLK_ENABLE          __HAL_RCC_LTDC_CLK_ENABLE
#define __LTDC_CLK_DISABLE          __HAL_RCC_LTDC_CLK_DISABLE
#define __LTDC_FORCE_RESET          __HAL_RCC_LTDC_FORCE_RESET
#define __LTDC_RELEASE_RESET          __HAL_RCC_LTDC_RELEASE_RESET
#define __LTDC_CLK_SLEEP_ENABLE          __HAL_RCC_LTDC_CLK_SLEEP_ENABLE
#define __ETHMAC_CLK_SLEEP_ENABLE  __HAL_RCC_ETHMAC_CLK_SLEEP_ENABLE
#define __ETHMAC_CLK_SLEEP_DISABLE  __HAL_RCC_ETHMAC_CLK_SLEEP_DISABLE
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 2629 : 
#define __USART6_CLK_DISABLE          __HAL_RCC_USART6_CLK_DISABLE
#define __USART6_FORCE_RESET        __HAL_RCC_USART6_FORCE_RESET
#define __USART6_RELEASE_RESET        __HAL_RCC_USART6_RELEASE_RESET
#define __USART6_CLK_SLEEP_ENABLE  __HAL_RCC_USART6_CLK_SLEEP_ENABLE
#define __USART6_CLK_SLEEP_DISABLE  __HAL_RCC_USART6_CLK_SLEEP_DISABLE
#define __SPI4_CLK_ENABLE          __HAL_RCC_SPI4_CLK_ENABLE
#define __SPI4_CLK_DISABLE          __HAL_RCC_SPI4_CLK_DISABLE
#define __SPI4_FORCE_RESET          __HAL_RCC_SPI4_FORCE_RESET
#define __SPI4_RELEASE_RESET        __HAL_RCC_SPI4_RELEASE_RESET
#define __SPI4_CLK_SLEEP_ENABLE   __HAL_RCC_SPI4_CLK_SLEEP_ENABLE
#define __SPI4_CLK_SLEEP_DISABLE  __HAL_RCC_SPI4_CLK_SLEEP_DISABLE
#define __GPIOI_CLK_ENABLE          __HAL_RCC_GPIOI_CLK_ENABLE
#define __GPIOI_CLK_DISABLE          __HAL_RCC_GPIOI_CLK_DISABLE
#define __GPIOI_FORCE_RESET          __HAL_RCC_GPIOI_FORCE_RESET
#define __GPIOI_RELEASE_RESET          __HAL_RCC_GPIOI_RELEASE_RESET
#define __GPIOI_CLK_SLEEP_ENABLE  __HAL_RCC_GPIOI_CLK_SLEEP_ENABLE
#define __GPIOI_CLK_SLEEP_DISABLE  __HAL_RCC_GPIOI_CLK_SLEEP_DISABLE
#define __GPIOJ_CLK_ENABLE          __HAL_RCC_GPIOJ_CLK_ENABLE
#define __GPIOJ_CLK_DISABLE          __HAL_RCC_GPIOJ_CLK_DISABLE
#define __GPIOJ_FORCE_RESET         __HAL_RCC_GPIOJ_FORCE_RESET
#define __GPIOJ_RELEASE_RESET          __HAL_RCC_GPIOJ_RELEASE_RESET
#define __GPIOJ_CLK_SLEEP_ENABLE  __HAL_RCC_GPIOJ_CLK_SLEEP_ENABLE
#define __GPIOJ_CLK_SLEEP_DISABLE  __HAL_RCC_GPIOJ_CLK_SLEEP_DISABLE
#define __GPIOK_CLK_ENABLE          __HAL_RCC_GPIOK_CLK_ENABLE
#define __GPIOK_CLK_DISABLE          __HAL_RCC_GPIOK_CLK_DISABLE
#define __GPIOK_RELEASE_RESET          __HAL_RCC_GPIOK_RELEASE_RESET
#define __GPIOK_CLK_SLEEP_ENABLE  __HAL_RCC_GPIOK_CLK_SLEEP_ENABLE
#define __GPIOK_CLK_SLEEP_DISABLE  __HAL_RCC_GPIOK_CLK_SLEEP_DISABLE
#define __ETH_CLK_ENABLE          __HAL_RCC_ETH_CLK_ENABLE
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 2660 : 
#define __DCMI_CLK_DISABLE          __HAL_RCC_DCMI_CLK_DISABLE
#define __DCMI_FORCE_RESET          __HAL_RCC_DCMI_FORCE_RESET
#define __DCMI_RELEASE_RESET          __HAL_RCC_DCMI_RELEASE_RESET
#define __DCMI_CLK_SLEEP_ENABLE   __HAL_RCC_DCMI_CLK_SLEEP_ENABLE
#define __DCMI_CLK_SLEEP_DISABLE  __HAL_RCC_DCMI_CLK_SLEEP_DISABLE
#define __UART7_CLK_ENABLE          __HAL_RCC_UART7_CLK_ENABLE
#define __UART7_CLK_DISABLE          __HAL_RCC_UART7_CLK_DISABLE
#define __UART7_RELEASE_RESET       __HAL_RCC_UART7_RELEASE_RESET
#define __UART7_FORCE_RESET       __HAL_RCC_UART7_FORCE_RESET
#define __UART7_CLK_SLEEP_ENABLE  __HAL_RCC_UART7_CLK_SLEEP_ENABLE
#define __UART7_CLK_SLEEP_DISABLE  __HAL_RCC_UART7_CLK_SLEEP_DISABLE
#define __UART8_CLK_ENABLE          __HAL_RCC_UART8_CLK_ENABLE
#define __UART8_CLK_DISABLE          __HAL_RCC_UART8_CLK_DISABLE
#define __UART8_FORCE_RESET          __HAL_RCC_UART8_FORCE_RESET
#define __UART8_RELEASE_RESET          __HAL_RCC_UART8_RELEASE_RESET
#define __UART8_CLK_SLEEP_ENABLE  __HAL_RCC_UART8_CLK_SLEEP_ENABLE
#define __UART8_CLK_SLEEP_DISABLE  __HAL_RCC_UART8_CLK_SLEEP_DISABLE
#define __OTGHS_CLK_SLEEP_ENABLE  __HAL_RCC_USB_OTG_HS_CLK_SLEEP_ENABLE
#define __OTGHS_CLK_SLEEP_DISABLE  __HAL_RCC_USB_OTG_HS_CLK_SLEEP_DISABLE
#define __OTGHS_FORCE_RESET          __HAL_RCC_USB_OTG_HS_FORCE_RESET
#define __OTGHS_RELEASE_RESET          __HAL_RCC_USB_OTG_HS_RELEASE_RESET
#define __OTGHSULPI_CLK_SLEEP_ENABLE  __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_ENABLE
#define __OTGHSULPI_CLK_SLEEP_DISABLE  __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_DISABLE
#define __HAL_RCC_OTGHS_CLK_SLEEP_ENABLE  __HAL_RCC_USB_OTG_HS_CLK_SLEEP_ENABLE
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 2686 : 
#define __HAL_RCC_OTGHS_IS_CLK_SLEEP_DISABLED __HAL_RCC_USB_OTG_HS_IS_CLK_SLEEP_DISABLED
#define __HAL_RCC_OTGHS_FORCE_RESET          __HAL_RCC_USB_OTG_HS_FORCE_RESET
#define __HAL_RCC_OTGHS_RELEASE_RESET          __HAL_RCC_USB_OTG_HS_RELEASE_RESET
#define __HAL_RCC_OTGHSULPI_CLK_SLEEP_ENABLE      __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_ENABLE
#define __HAL_RCC_OTGHSULPI_CLK_SLEEP_DISABLE     __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_DISABLE
#define __HAL_RCC_OTGHSULPI_IS_CLK_SLEEP_ENABLED  __HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_SLEEP_ENABLED
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 2701 : 
#define __ADC3_CLK_SLEEP_DISABLE       __HAL_RCC_ADC3_CLK_SLEEP_DISABLE
#define __FSMC_FORCE_RESET             __HAL_RCC_FSMC_FORCE_RESET
#define __FSMC_RELEASE_RESET           __HAL_RCC_FSMC_RELEASE_RESET
#define __FSMC_CLK_SLEEP_ENABLE        __HAL_RCC_FSMC_CLK_SLEEP_ENABLE
#define __FSMC_CLK_SLEEP_DISABLE       __HAL_RCC_FSMC_CLK_SLEEP_DISABLE
#define __SDIO_FORCE_RESET             __HAL_RCC_SDIO_FORCE_RESET
#define __SDIO_RELEASE_RESET           __HAL_RCC_SDIO_RELEASE_RESET
#define __SDIO_CLK_SLEEP_DISABLE       __HAL_RCC_SDIO_CLK_SLEEP_DISABLE
#define __SDIO_CLK_SLEEP_ENABLE        __HAL_RCC_SDIO_CLK_SLEEP_ENABLE
#define __DMA2D_CLK_ENABLE             __HAL_RCC_DMA2D_CLK_ENABLE
#define __DMA2D_CLK_DISABLE            __HAL_RCC_DMA2D_CLK_DISABLE
#define __DMA2D_FORCE_RESET            __HAL_RCC_DMA2D_FORCE_RESET
#define __DMA2D_RELEASE_RESET          __HAL_RCC_DMA2D_RELEASE_RESET
#define __DMA2D_CLK_SLEEP_ENABLE       __HAL_RCC_DMA2D_CLK_SLEEP_ENABLE
#define __DMA2D_CLK_SLEEP_DISABLE      __HAL_RCC_DMA2D_CLK_SLEEP_DISABLE

/* alias define maintained for legacy */
#define __HAL_RCC_OTGFS_FORCE_RESET    __HAL_RCC_USB_OTG_FS_FORCE_RESET
#define __HAL_RCC_OTGFS_RELEASE_RESET  __HAL_RCC_USB_OTG_FS_RELEASE_RESET

#define __ADC12_CLK_ENABLE          __HAL_RCC_ADC12_CLK_ENABLE
#define __ADC12_CLK_DISABLE         __HAL_RCC_ADC12_CLK_DISABLE
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 2741 : 

#define __ADC12_FORCE_RESET         __HAL_RCC_ADC12_FORCE_RESET
#define __ADC12_RELEASE_RESET       __HAL_RCC_ADC12_RELEASE_RESET
#define __ADC34_FORCE_RESET         __HAL_RCC_ADC34_FORCE_RESET
#define __ADC34_RELEASE_RESET       __HAL_RCC_ADC34_RELEASE_RESET
#define __DAC2_FORCE_RESET          __HAL_RCC_DAC2_FORCE_RESET
#define __DAC2_RELEASE_RESET        __HAL_RCC_DAC2_RELEASE_RESET
#define __TIM18_FORCE_RESET         __HAL_RCC_TIM18_FORCE_RESET
#define __TIM18_RELEASE_RESET       __HAL_RCC_TIM18_RELEASE_RESET
#define __TIM19_FORCE_RESET         __HAL_RCC_TIM19_FORCE_RESET
#define __TIM19_RELEASE_RESET       __HAL_RCC_TIM19_RELEASE_RESET
#define __TIM20_FORCE_RESET         __HAL_RCC_TIM20_FORCE_RESET
#define __TIM20_RELEASE_RESET       __HAL_RCC_TIM20_RELEASE_RESET
#define __HRTIM1_FORCE_RESET        __HAL_RCC_HRTIM1_FORCE_RESET
#define __HRTIM1_RELEASE_RESET      __HAL_RCC_HRTIM1_RELEASE_RESET
#define __SDADC1_FORCE_RESET        __HAL_RCC_SDADC1_FORCE_RESET
#define __SDADC2_FORCE_RESET        __HAL_RCC_SDADC2_FORCE_RESET
#define __SDADC3_FORCE_RESET        __HAL_RCC_SDADC3_FORCE_RESET
#define __SDADC1_RELEASE_RESET      __HAL_RCC_SDADC1_RELEASE_RESET
#define __SDADC2_RELEASE_RESET      __HAL_RCC_SDADC2_RELEASE_RESET
#define __SDADC3_RELEASE_RESET      __HAL_RCC_SDADC3_RELEASE_RESET

#define __ADC1_IS_CLK_ENABLED       __HAL_RCC_ADC1_IS_CLK_ENABLED
#define __ADC1_IS_CLK_DISABLED      __HAL_RCC_ADC1_IS_CLK_DISABLED
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 2884 : 
#define __HAL_RCC_CRYP_CLK_SLEEP_ENABLE    __HAL_RCC_AES_CLK_SLEEP_ENABLE
#define __HAL_RCC_CRYP_FORCE_RESET         __HAL_RCC_AES_FORCE_RESET
#define __HAL_RCC_CRYP_RELEASE_RESET       __HAL_RCC_AES_RELEASE_RESET
#endif /* STM32L1 */

#if defined(STM32F4)
#define __HAL_RCC_SDMMC1_FORCE_RESET       __HAL_RCC_SDIO_FORCE_RESET
#define __HAL_RCC_SDMMC1_RELEASE_RESET     __HAL_RCC_SDIO_RELEASE_RESET
#define __HAL_RCC_SDMMC1_CLK_SLEEP_ENABLE  __HAL_RCC_SDIO_CLK_SLEEP_ENABLE
#define __HAL_RCC_SDMMC1_CLK_SLEEP_DISABLE __HAL_RCC_SDIO_CLK_SLEEP_DISABLE
#define __HAL_RCC_SDMMC1_CLK_ENABLE        __HAL_RCC_SDIO_CLK_ENABLE
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 2906 : 
#if defined(STM32F7) || defined(STM32L4)
#define __HAL_RCC_SDIO_FORCE_RESET         __HAL_RCC_SDMMC1_FORCE_RESET
#define __HAL_RCC_SDIO_RELEASE_RESET       __HAL_RCC_SDMMC1_RELEASE_RESET
#define __HAL_RCC_SDIO_CLK_SLEEP_ENABLE    __HAL_RCC_SDMMC1_CLK_SLEEP_ENABLE
#define __HAL_RCC_SDIO_CLK_SLEEP_DISABLE   __HAL_RCC_SDMMC1_CLK_SLEEP_DISABLE
#define __HAL_RCC_SDIO_CLK_ENABLE          __HAL_RCC_SDMMC1_CLK_ENABLE
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 2930 : 
#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_DISABLE()        __HAL_RCC_USB1_OTG_HS_ULPI_CLK_DISABLE()
#define __HAL_RCC_USB_OTG_HS_FORCE_RESET()             __HAL_RCC_USB1_OTG_HS_FORCE_RESET()
#define __HAL_RCC_USB_OTG_HS_RELEASE_RESET()           __HAL_RCC_USB1_OTG_HS_RELEASE_RESET()
#define __HAL_RCC_USB_OTG_HS_CLK_SLEEP_ENABLE()        __HAL_RCC_USB1_OTG_HS_CLK_SLEEP_ENABLE()
#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_ENABLE()   __HAL_RCC_USB1_OTG_HS_ULPI_CLK_SLEEP_ENABLE()
#define __HAL_RCC_USB_OTG_HS_CLK_SLEEP_DISABLE()       __HAL_RCC_USB1_OTG_HS_CLK_SLEEP_DISABLE()
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 2941 : 
#define __HAL_RCC_USB_OTG_FS_ULPI_CLK_DISABLE()       __HAL_RCC_USB2_OTG_FS_ULPI_CLK_DISABLE()
#define __HAL_RCC_USB_OTG_FS_FORCE_RESET()            __HAL_RCC_USB2_OTG_FS_FORCE_RESET()
#define __HAL_RCC_USB_OTG_FS_RELEASE_RESET()          __HAL_RCC_USB2_OTG_FS_RELEASE_RESET()
#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_ENABLE()       __HAL_RCC_USB2_OTG_FS_CLK_SLEEP_ENABLE()
#define __HAL_RCC_USB_OTG_FS_ULPI_CLK_SLEEP_ENABLE()  __HAL_RCC_USB2_OTG_FS_ULPI_CLK_SLEEP_ENABLE()
#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_DISABLE()      __HAL_RCC_USB2_OTG_FS_CLK_SLEEP_DISABLE()
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 3091 : 
#define __HAL_RCC_DFSDM_IS_CLK_DISABLED        __HAL_RCC_DFSDM1_IS_CLK_DISABLED
#define __HAL_RCC_DFSDM_FORCE_RESET            __HAL_RCC_DFSDM1_FORCE_RESET
#define __HAL_RCC_DFSDM_RELEASE_RESET          __HAL_RCC_DFSDM1_RELEASE_RESET
#define __HAL_RCC_DFSDM_CLK_SLEEP_ENABLE       __HAL_RCC_DFSDM1_CLK_SLEEP_ENABLE
#define __HAL_RCC_DFSDM_CLK_SLEEP_DISABLE      __HAL_RCC_DFSDM1_CLK_SLEEP_DISABLE
#define __HAL_RCC_DFSDM_IS_CLK_SLEEP_ENABLED   __HAL_RCC_DFSDM1_IS_CLK_SLEEP_ENABLED
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 3293 : 
  */
#define __HAL_SMBUS_RESET_CR1           SMBUS_RESET_CR1
#define __HAL_SMBUS_RESET_CR2           SMBUS_RESET_CR2
#define __HAL_SMBUS_GENERATE_START      SMBUS_GENERATE_START
#define __HAL_SMBUS_GET_ADDR_MATCH      SMBUS_GET_ADDR_MATCH
#define __HAL_SMBUS_GET_DIR             SMBUS_GET_DIR
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 3311 : 
#define __HAL_SPI_1LINE_RX              SPI_1LINE_RX
#define __HAL_SPI_RESET_CRC             SPI_RESET_CRC

/**
  * @}
stm32_hal_legacy.h (F:\projects\git\Hardware\magnetic\code\node\Drivers\STM32L4xx_HAL_Driver\Inc\Legacy) line 3406 : 
#define __HAL_TIM_SetICPrescalerValue   TIM_SET_ICPRESCALERVALUE
#define __HAL_TIM_ResetICPrescalerValue TIM_RESET_ICPRESCALERVALUE

#define TIM_GET_ITSTATUS                __HAL_TIM_GET_IT_SOURCE
#define TIM_GET_CLEAR_IT                __HAL_TIM_CLEAR_IT
system_stm32l4xx.c (F:\projects\git\Hardware\magnetic\code\node\Src) line 8 : 
  *   user application:
  *      - SystemInit(): This function is called at startup just after reset and
  *                      before branch to main program. This call is made inside
  *                      the "startup_stm32l4xx.s" file.
  *
system_stm32l4xx.c (F:\projects\git\Hardware\magnetic\code\node\Src) line 20 : 
  *
  *   After each device reset the MSI (4 MHz) is used as system clock source.
  *   Then SystemInit() function is called, in "startup_stm32l4xx.s" file, to
  *   configure the system clock before to branch to main program.
  *
SystemInit in system_stm32l4xx.c (F:\projects\git\Hardware\magnetic\code\node\Src) : 

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000U;

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  RCC->CR &= 0xEAF6FFFFU;

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00001000U;

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;

  /* Disable all interrupts */
SystemCoreClockUpdate in system_stm32l4xx.c (F:\projects\git\Hardware\magnetic\code\node\Src) : 
  /* Get MSI Range frequency--------------------------------------------------*/
  if((RCC->CR & RCC_CR_MSIRGSEL) == RESET)
  { /* MSISRANGE from RCC_CSR applies */
    msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8U;
  }
---- Reset Search Errors Encountered (1) ----
The following 1 files could not be processed:
F:\projects\git\Hardware\magnetic\code\node\MDK-ARM\JLinkLog.txt : File could not be opened.
