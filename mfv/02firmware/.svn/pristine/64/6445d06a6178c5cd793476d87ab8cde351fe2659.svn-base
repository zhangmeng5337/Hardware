/*
* This source file is part of the EtherCAT Slave Stack Code licensed by Beckhoff Automation GmbH & Co KG, 33415 Verl, Germany.
* The corresponding license agreement applies. This hint shall not be removed.
*/

/**
\addtogroup ETG5003_2020_MFC ETG5003_2020_MFC
@{
*/

/**
\file ETG5003_2020_MFC.c
\brief Implementation

\version 1.0.0.11
*/

#ifdef ECAT
/*-----------------------------------------------------------------------------------------
------
------    Includes
------
-----------------------------------------------------------------------------------------*/
#include "main.h"
#include "ecat_def.h"

#include "coeappl.h"
#include "applInterface.h"
#include "bootmode.h"

#include "nvmem.h"
#include "libUnits.h"
#include "digitalIO.h"

#include "adc.h"
#include "cdg.h"
#include "config.h"
#include "verifier.h"
#include "calibration.h"
#include "gas.h"
#include "flash.h"
#include "relay_driver.h"

#define _ETG5003_2020__MFC_ 1
#include "ETG5003_2020_MFC.h"
#undef _ETG5003_2020__MFC_
/*--------------------------------------------------------------------------------------
------
------    local types and defines
------
--------------------------------------------------------------------------------------*/
#define    MAX_FILE_NAME_SIZE    16

/** \brief  MAX_FILE_SIZE: Maximum file size */
#define MAX_FILE_SIZE                             0x180
/*-----------------------------------------------------------------------------------------
------
------    local variables and constants
------
-----------------------------------------------------------------------------------------*/
extern UINT64 u64Timestamp;
UINT16           ulMacId = 0;
UINT32           nFileWriteOffset;
CHAR             aFileName[MAX_FILE_NAME_SIZE];
UINT16 MBXMEM     aFileData[(MAX_FILE_SIZE >> 1)];


UINT32 u32FileSize;
UINT16 MBXMEM sii[128];

ECAT_VAR_STRUCT   ecat_Var;
UINT8  spType;

extern unsigned char SerialNumber0xF9F0[10];
extern UINT32 UpTime0xF9F6;
extern UINT32 TotalUpTime0xF9F7;

extern UINT32 u32Devicetype;
extern CHAR acDevicename[];
extern TOBJ1018 sIdentity;
extern TOBJECT    OBJMEM ApplicationObjDic[];
extern TOBJ1A00 InputMapping00x1A00;
extern OBJCONST UCHAR OBJMEM aName0x7003PC[];
extern OBJCONST UCHAR OBJMEM aName0x7007PC[];
extern unsigned char ExceptionStatus0xF380;

/*-----------------------------------------------------------------------------------------
------
------    application specific functions
------
-----------------------------------------------------------------------------------------*/
void disable_userobj(UINT16 Index)
{
    UINT16 obj = 0;
    while (ApplicationObjDic[obj].Index != 0xFFFF)
    {
        if (ApplicationObjDic[obj].Index == Index)
        {
            ApplicationObjDic[obj].Index = 0;
            return;
        }
        obj++;
    }
}

void ecat_userobj_init(UINT8 init_type)
{


    memset(acDevicename, 0, 4);
    memcpy(acDevicename, &nvmem.app.manufacturing.partnumber, 3);
    sIdentity.u32Productcode = nvmem.app.manufacturing.usProductCode;
    sIdentity.u32VendorID = nvmem.app.manufacturing.usVendorId;

    memcpy(SerialNumber0xF9F0, nvmem.app.manufacturing.deviceserialnumber, 12);

    switch (init_type)
    {
        case 1:
        default:
            ecat_Var.flowunits = DATAUNIT_SCCM;
            ecat_Var.pressureunits = DATAUNIT_TORR;
            ecat_Var.temperatureunits = DATAUNIT_CELSIUS;
            SensorFlowFloating0x8000.FlowDataUnit                                 =
                APPL_ConvertToEtherCATUnits(ecat_Var.flowunits, EcToNativeFlowUnits);
            SensorPressureFloating0x8001.PressureDataUnit                     =
                APPL_ConvertToEtherCATUnits(ecat_Var.pressureunits, EcToNativePresUnits);
            ecat_Var.status = 0x0000;
            break;
    }
}


/*-----------------------------------------------------------------------------------------
------
------    generic functions
------
-----------------------------------------------------------------------------------------*/
UINT16 ESC_EEPROM_Manager(void)
{
//  uint32_t fl_storage_addr = FLASH_STORAGE_BLOCK;
//  UINT32 wordaddress = 0;
//  volatile uint32_t *app_check_blk = APP_CHECK_BLOCK;
//  uint32_t app_chsum_info_block[3];
//
//  memcpy(app_chsum_info_block, app_check_blk, sizeof(app_chsum_info_block));
//  // check for new SII downloaded pattern from application
//  if ((app_chsum_info_block[2] & 0xFF000000) == 0x5a000000) {
//      if (ESC_EepromAccess(0,128,sii,ESC_RD) == ALSTATUSCODE_NOERROR) {
//          if (ESC_EepromAccess(wordaddress, 2048, (UINT16 *)(fl_storage_addr+app_chsum_info_block[1]), ESC_WR) == ALSTATUSCODE_NOERROR) {
//              app_chsum_info_block[2] &= ~0xFF000000; // clear pattern
//              memory_erase(APP_CHECK_BLOCK,12);
//              memory_write_word(APP_CHECK_BLOCK,app_chsum_info_block,12);
//              // TODO: Do we need to reset if we are not writing config area
//              //reset_device = 1;
//          }
//      }
//  }
}

/////////////////////////////////////////////////////////////////////////////////////////
/**
 \brief    The function is called when a read request from the master is issued

*////////////////////////////////////////////////////////////////////////////////////////
UINT16 FoE_Read(UINT16 MBXMEM *pName, UINT16 nameSize, UINT32 password,
                UINT16 maxBlockSize, UINT16 *pData)
{
    UINT16 i = 0;
    UINT16 sizeError = 0;

    CHAR aReadFileName[MAX_FILE_NAME_SIZE];


    if ((nameSize + 1) > MAX_FILE_NAME_SIZE)
    {

        return ECAT_FOE_ERRCODE_DISKFULL;
    }

    /*Read requested file name to endianess conversion if required*/
    MBXSTRCPY(aReadFileName, pName, nameSize);
    aReadFileName[nameSize] = '\0';

    if (u32FileSize == 0)
    {
        /* No file stored*/
        return ECAT_FOE_ERRCODE_NOTFOUND;
    }

    /* for test only the written file name can be read */
    for (i = 0; i < nameSize; i++)
    {
        if (aReadFileName[i] != aFileName[i])
        {
            /* file name not found */
            return ECAT_FOE_ERRCODE_NOTFOUND;
        }
    }

    sizeError = maxBlockSize;

    if (u32FileSize < sizeError)
    {
        sizeError = (UINT16)u32FileSize;
    }

    /*copy the first foe data block*/
    MEMCPY(pData, aFileData, sizeError);

    return sizeError;
}

/////////////////////////////////////////////////////////////////////////////////////////
/**
 \brief    The function is called when a block of data is requested for read

*////////////////////////////////////////////////////////////////////////////////////////
UINT16 FoE_ReadData(UINT32 offset, UINT16 maxBlockSize, UINT16 *pData)
{
    UINT16 sizeError = 0;

    if (u32FileSize < offset)
    {
        return 0;
    }

    /*get file length to send*/
    sizeError = (UINT16)(u32FileSize - offset);


    if (sizeError > maxBlockSize)
    {
        /*transmit max block size if the file data to be send is greater than the max data block*/
        sizeError = maxBlockSize;
    }

    /*copy the foe data block 2 .. n*/
    MEMCPY(pData, &(((UINT8 *)aFileData)[offset]), sizeError);

    return sizeError;
}

/////////////////////////////////////////////////////////////////////////////////////////
/**
 \brief    The function is called when a block of data is sent via FoE by the master

*////////////////////////////////////////////////////////////////////////////////////////
UINT16 FoE_WriteData(UINT16 MBXMEM *pData, UINT16 Size, BOOL bDataFollowing)
{
    if (bBootMode)
    {
        return BL_Data(pData, Size);
    }
    else if ((nFileWriteOffset + Size) > MAX_FILE_SIZE)
    {
        return ECAT_FOE_ERRCODE_DISKFULL;
    }

    if (Size)
    {
        MBXMEMCPY(&aFileData[(nFileWriteOffset >> 1)], pData, Size);

    }

    if (bDataFollowing)
    {
        /* FoE-Data services will follow */
        nFileWriteOffset += Size;

    }
    else
    {
        /* last part of the file is written */
        u32FileSize = nFileWriteOffset + Size;
        nFileWriteOffset = 0;
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////
/**
 \brief    The function is called when a write request is issued by the master

*////////////////////////////////////////////////////////////////////////////////////////
UINT16 FoE_Write(UINT16 MBXMEM *pName, UINT16 nameSize, UINT32 password)
{
    if (nameSize < MAX_FILE_NAME_SIZE)
    {
        /* for test every file name can be written */
        MBXSTRCPY(aFileName, pName, nameSize);
        MBXSTRCPY(aFileName + nameSize, "\0", 1); //string termination

        // TODO: If file system is implemented, this is the downloaded image filename
        // TODO: Filename or Password can be initially checked here before download is started

        nFileWriteOffset = 0;
        u32FileSize = 0;
        return 0;
    }
    else
    {
        return ECAT_FOE_ERRCODE_DISKFULL;
    }

}

/////////////////////////////////////////////////////////////////////////////////////////
/**
 \brief    The function is called when an error state was acknowledged by the master

*////////////////////////////////////////////////////////////////////////////////////////

void    APPL_AckErrorInd(UINT16 stateTrans)
{

}

/////////////////////////////////////////////////////////////////////////////////////////
/**
 \return    AL Status Code (see ecatslv.h ALSTATUSCODE_....)

 \brief    The function is called in the state transition from INIT to PREOP when
             all general settings were checked to start the mailbox handler. This function
             informs the application about the state transition, the application can refuse
             the state transition when returning an AL Status error code.
            The return code NOERROR_INWORK can be used, if the application cannot confirm
            the state transition immediately, in that case this function will be called cyclically
            until a value unequal NOERROR_INWORK is returned

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StartMailboxHandler(void)
{
    return ALSTATUSCODE_NOERROR;
}

/////////////////////////////////////////////////////////////////////////////////////////
/**
 \return     0, NOERROR_INWORK

 \brief    The function is called in the state transition from PREEOP to INIT
             to stop the mailbox handler. This functions informs the application
             about the state transition, the application cannot refuse
             the state transition.

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StopMailboxHandler(void)
{
    return ALSTATUSCODE_NOERROR;
}

/////////////////////////////////////////////////////////////////////////////////////////
/**
 \param    pIntMask    pointer to the AL Event Mask which will be written to the AL event Mask
                        register (0x204) when this function is succeeded. The event mask can be adapted
                        in this function
 \return    AL Status Code (see ecatslv.h ALSTATUSCODE_....)

 \brief    The function is called in the state transition from PREOP to SAFEOP when
           all general settings were checked to start the input handler. This function
           informs the application about the state transition, the application can refuse
           the state transition when returning an AL Status error code.
           The return code NOERROR_INWORK can be used, if the application cannot confirm
           the state transition immediately, in that case the application need to be complete
           the transition by calling ECAT_StateChange.
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StartInputHandler(UINT16 *pIntMask)
{
    return ALSTATUSCODE_NOERROR;
}

/////////////////////////////////////////////////////////////////////////////////////////
/**
 \return     0, NOERROR_INWORK

 \brief    The function is called in the state transition from SAFEOP to PREEOP
             to stop the input handler. This functions informs the application
             about the state transition, the application cannot refuse
             the state transition.

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StopInputHandler(void)
{
    return ALSTATUSCODE_NOERROR;
}

/////////////////////////////////////////////////////////////////////////////////////////
/**
 \return    AL Status Code (see ecatslv.h ALSTATUSCODE_....)

 \brief    The function is called in the state transition from SAFEOP to OP when
             all general settings were checked to start the output handler. This function
             informs the application about the state transition, the application can refuse
             the state transition when returning an AL Status error code.
           The return code NOERROR_INWORK can be used, if the application cannot confirm
           the state transition immediately, in that case the application need to be complete
           the transition by calling ECAT_StateChange.
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StartOutputHandler(void)
{
    return ALSTATUSCODE_NOERROR;
}

/////////////////////////////////////////////////////////////////////////////////////////
/**
 \return     0, NOERROR_INWORK

 \brief    The function is called in the state transition from OP to SAFEOP
             to stop the output handler. This functions informs the application
             about the state transition, the application cannot refuse
             the state transition.

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StopOutputHandler(void)
{

    return ALSTATUSCODE_NOERROR;
}

/////////////////////////////////////////////////////////////////////////////////////////
/**
\return     0(ALSTATUSCODE_NOERROR), NOERROR_INWORK
\param      pInputSize  pointer to save the input process data length
\param      pOutputSize  pointer to save the output process data length

\brief    This function calculates the process data sizes from the actual SM-PDO-Assign
            and PDO mapping
*////////////////////////////////////////////////////////////////////////////////////////
UINT16 APPL_GenerateMapping(UINT16 *pInputSize, UINT16 *pOutputSize)
{
    UINT16 result = ALSTATUSCODE_NOERROR;
    UINT16 InputSize = 0;
    UINT16 OutputSize = 0;

#if COE_SUPPORTED
    UINT16 PDOAssignEntryCnt = 0;
    OBJCONST TOBJECT OBJMEM *pPDO = NULL;
    UINT16 PDOSubindex0 = 0;
    UINT32 *pPDOEntry = NULL;
    UINT16 PDOEntryCnt = 0;

    /*Scan object 0x1C12 RXPDO assign*/
    for (PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sRxPDOassign.u16SubIndex0;
            PDOAssignEntryCnt++)
    {
        pPDO = OBJ_GetObjectHandle(sRxPDOassign.aEntries[PDOAssignEntryCnt]);
        if (pPDO != NULL)
        {
            PDOSubindex0 = *((UINT16 *)pPDO->pVarPtr);
            for (PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
            {
                pPDOEntry = (UINT32 *)((UINT16 *)pPDO->pVarPtr + (OBJ_GetEntryOffset((
                                           PDOEntryCnt + 1), pPDO) >> 3) / 2); //goto PDO entry
                // we increment the expected output size depending on the mapped Entry
                OutputSize += (UINT16)((*pPDOEntry) & 0xFF);
            }
        }
        else
        {
            /*assigned PDO was not found in object dictionary. return invalid mapping*/
            OutputSize = 0;
            result = ALSTATUSCODE_INVALIDOUTPUTMAPPING;
            break;
        }
    }

    OutputSize = (OutputSize + 7) >> 3;

    if (result == 0)
    {
        /*Scan Object 0x1C13 TXPDO assign*/
        for (PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sTxPDOassign.u16SubIndex0;
                PDOAssignEntryCnt++)
        {
            pPDO = OBJ_GetObjectHandle(sTxPDOassign.aEntries[PDOAssignEntryCnt]);
            if (pPDO != NULL)
            {
                PDOSubindex0 = *((UINT16 *)pPDO->pVarPtr);
                for (PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
                {
                    pPDOEntry = (UINT32 *)((UINT16 *)pPDO->pVarPtr + (OBJ_GetEntryOffset((
                                               PDOEntryCnt + 1), pPDO) >> 3) / 2); //goto PDO entry
                    // we increment the expected output size depending on the mapped Entry
                    InputSize += (UINT16)((*pPDOEntry) & 0xFF);
                }
            }
            else
            {
                /*assigned PDO was not found in object dictionary. return invalid mapping*/
                InputSize = 0;
                result = ALSTATUSCODE_INVALIDINPUTMAPPING;
                break;
            }
        }
    }
    InputSize = (InputSize + 7) >> 3;

#else
#if _WIN32
#pragma message ("Warning: Define 'InputSize' and 'OutputSize'.")
#else
#warning "Define 'InputSize' and 'OutputSize'."
#endif
#endif

    *pInputSize = InputSize;
    *pOutputSize = OutputSize;
    return result;
}

/************************************************************************/
/*                                                                      */
/************************************************************************/
UINT8 getBits(UINT32 *pISIEntry, UINT16 Index, UINT16 Subindex, UINT16 size)
{
    UINT8 bit = 0;
    UINT16 data = (UINT16) * pISIEntry;
    UINT16 mask = 0;

    switch (Index)
    {
        case 0x600F:    // ETG.2020 application specific for retrieving bits
            for (int i = 0; i < size; i++)
            {
                mask <<= 1;
                mask |= 1;
            }
            bit = (data >> (Subindex - 1)) & mask;
            break;
    }

    return bit;
}

/************************************************************************/
/*                                                                      */
/************************************************************************/
void putBits(UINT8 *pData_lcl, UINT32 *pISIEntry, UINT16 Index, UINT16 Subindex,
             UINT8 u8ctr, UINT16 size)
{
    UINT16 mask = 0;
    //UINT16 data = 0;
    UINT8 bit = 0;

    switch (Index)
    {
        case 0x700F:    // ETG.2020 application specific for retrieving bits
            for (int i = 0; i < size; i++)
            {
                mask <<= 1;
                mask |= 1;
            }
            bit = (*pData_lcl >> u8ctr) & mask;
            *pISIEntry &= ~(mask << (Subindex - 1));
            *pISIEntry |= (bit << (Subindex - 1));
            break;
    }
}

/////////////////////////////////////////////////////////////////////////////////////////
/**
\param      pData  pointer to input process data

\brief      This function will copies the inputs from the local memory to the ESC memory
            to the hardware
*////////////////////////////////////////////////////////////////////////////////////////
void APPL_InputMapping(UINT16 *pData)
{
#if _WIN32
#pragma message ("Warning: Implement input (Slave -> Master) mapping")
#else
    OBJCONST TOBJECT OBJMEM *pPDO = NULL;
    UINT8 *pData_lcl = (UINT8 *)(pData);
    UINT32 *pPDOEntry = NULL;
    UINT32 *pISIEntry = NULL;
    UINT16 InputSize = 0;
    UINT16 Subindex = 0;
    UINT16 Index = 0;
    UINT8 fill_in_progress = 0;
    UINT8 u8fill = 0;
    UINT8 u8ctr = 0;

    /*Scan Object 0x1C13 TXPDO assign*/
    for (UINT16 PDOAssignEntryCnt = 0;
            PDOAssignEntryCnt < sTxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
    {
        // Get the PDO object (default, flexible)
        pPDO = OBJ_GetObjectHandle(sTxPDOassign.aEntries[PDOAssignEntryCnt]);
        if (pPDO != NULL)
        {
            // Look at how many indices do we need to pack per PDO assignment
            UINT16 PDOSubindex0 = *((UINT16 *)pPDO->pVarPtr);
            for (UINT16 PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
            {
                // Get the PDO entry and parse the Index, Subindex and bit size
                pPDOEntry = (UINT32 *)((UINT16 *)pPDO->pVarPtr + (OBJ_GetEntryOffset((
                                           PDOEntryCnt + 1), pPDO) >> 3) / 2);
                Index = (UINT16)(((*pPDOEntry) >> 16) & 0xFFFF);
                Subindex = (UINT16)(((*pPDOEntry) >> 8) & 0xFF);
                InputSize = (UINT16)((*pPDOEntry) & 0xFF);

                // Retrieve the object based on the object Index
                OBJCONST TOBJECT OBJMEM *pISI = OBJ_GetObjectHandle(Index);
                // Retrieve the data based on the subindex of the object
//                pISIEntry = (UINT32 *)((UINT16 *)pISI->pVarPtr + (OBJ_GetEntryOffset((Subindex),
//                                       pISI) >> 3) / 2);
                UINT16 entry_offset = OBJ_GetEntryOffset((Subindex), pISI) >> 3;
                pISIEntry = (UINT32 *)((UINT16 *)pISI->pVarPtr + entry_offset / 2);
                binary data;
                if (entry_offset % 2)
                {
                    data._uint32 = *pISIEntry >> 8;
                }
                else
                {
                    data._uint32 = *pISIEntry;
                }

                if (InputSize >= 0x08)
                {
                    if (fill_in_progress == 1)
                    {
                        // pack the data based on the size
                        memcpy(pData_lcl, &u8fill, 1);
                        pData_lcl += 1;
                        u8fill = 0;
                        fill_in_progress = 0;
                    }
                    // pack the data based on the size
                    memcpy(pData_lcl, &data._uint32, InputSize / 8);
                    pData_lcl += InputSize / 8;

                }
                else
                {
                    u8fill |= (getBits((unsigned long *)&data._uint32, Index, Subindex,
                                       InputSize) << u8ctr);
                    u8ctr += InputSize;
                    fill_in_progress = 1;
                    // check if the last fill exceeds byte boundary. If so, transfer to data buffer. Left over bits are also handled here by subtracting 8 from the fill counter
                    if (u8ctr >= 8)
                    {
                        // pack the data based on the size
                        memcpy(pData_lcl, &u8fill, 1);
                        pData_lcl += 1;
                        u8ctr -= 8;
                        u8fill = 0;
                        fill_in_progress = 0;
                    }
                }
            }
        }
        else
        {
            /*assigned PDO was not found in object dictionary. return invalid mapping*/
        }
    }

#endif
}

/////////////////////////////////////////////////////////////////////////////////////////
/**
\param      pData  pointer to output process data

\brief    This function will copies the outputs from the ESC memory to the local memory
            to the hardware
*////////////////////////////////////////////////////////////////////////////////////////
void APPL_OutputMapping(UINT16 *pData)
{
#if _WIN32
#pragma message ("Warning: Implement output (Master -> Slave) mapping")
#else
    OBJCONST TOBJECT OBJMEM *pPDO = NULL;
    UINT8 *pData_lcl = (UINT8 *)(pData);
    UINT32 *pPDOEntry = NULL;
    UINT32 *pISIEntry = NULL;
    UINT16 InputSize = 0;
    UINT16 Subindex = 0;
    UINT16 Index = 0;
    UINT8 u8fill = 0;
    UINT8 u8ctr = 0;
    UINT8 spTypeSet = FALSE;

    spType = ECAT_REAL_TYPE;  // assume default fixed PDO type of REAL
    /*Scan object 0x1C12 RXPDO assign*/
    for (UINT16 PDOAssignEntryCnt = 0;
            PDOAssignEntryCnt < sRxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
    {
        // Get the PDO object (default, flexible)
        pPDO = OBJ_GetObjectHandle(sRxPDOassign.aEntries[PDOAssignEntryCnt]);
        if (pPDO != NULL)
        {
            // Look at how many indices do we need to pack per PDO assignment
            UINT16 PDOSubindex0 = *((UINT16 *)pPDO->pVarPtr);
            for (UINT16 PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
            {
                // Get the PDO entry and parse the Index, Subindex and bit size
                pPDOEntry = (UINT32 *)((UINT16 *)pPDO->pVarPtr + (OBJ_GetEntryOffset((
                                           PDOEntryCnt + 1), pPDO) >> 3) / 2);
                Index = (UINT16)(((*pPDOEntry) >> 16) & 0xFFFF);
                Subindex = (UINT16)(((*pPDOEntry) >> 8) & 0xFF);
                InputSize = (UINT16)((*pPDOEntry) & 0xFF);

                // Retrieve the object based on the object Index
                OBJCONST TOBJECT OBJMEM *pISI = OBJ_GetObjectHandle(Index);
                // Retrieve the data based on the subindex of the object then absorb the data based on the
                pISIEntry = (UINT32 *)((UINT16 *)pISI->pVarPtr + (OBJ_GetEntryOffset((Subindex),
                                       pISI) >> 3) / 2);

                if (InputSize >= 0x08)      // process 8 bit aligned data
                {
                    memcpy(pISIEntry, pData_lcl, InputSize >> 3);
                    pData_lcl += (InputSize >> 3);
                }
                else        // process <8 bits data set here
                {

                    putBits(pData_lcl, pISIEntry, Index, Subindex, u8ctr, InputSize);
                    u8ctr += InputSize;
                    if (u8ctr >= 8)
                    {
                        pData_lcl += 1;
                        u8ctr = 0;
                    }
                }

                if (!spTypeSet)
                {
                    // run check here if we are using REAL or INT for setpoint.
                    switch (pISI->Index)
                    {
                        case 0x7007:
                            // use INT setpoint
                            spType = ECAT_INT_TYPE;
                            spTypeSet = TRUE;
                            break;
                        case 0x7003:
                            // use REAL setpoint
                            spType = ECAT_REAL_TYPE;
                            spTypeSet = TRUE;
                            break;
                    }
                }
            }
        }
        else
        {
            /*assigned PDO was not found in object dictionary. return invalid mapping*/
        }
    }

#endif
}

/////////////////////////////////////////////////////////////////////////////////////////
/**
\brief    This function will called from the synchronization ISR
            or from the mainloop if no synchronization is supported
*////////////////////////////////////////////////////////////////////////////////////////
void APPL_Application(void)
{
#if _WIN32
#pragma message ("Warning: Implement the slave application")
#else

    UpdateAliasRegister(); // update station alias register per switch

    // Map EtherCAT to application
    SensorFlowFloating0x6000.FlowReadingREAL                    =
        get_calib()->F; //ConvertUnits( UnitsConvFlow, meter.flowSCCM, DATAUNIT_SCCM, ecat_Var.flowunits );
    SensorPressureFloating0x6001.PressureReadingREAL            =
        get_cdg_status()->pressure_filter_torr; //ConvertUnits( UnitsConvPressure, meter.fkpsia, DATAUNIT_PSIA, ecat_Var.pressureunits );
    SensorTemperatureFloating0x6002.TemperatureReadingREAL      =
        get_temperature()->average_P1_T; //ConvertUnits( UnitsConvTemperature, meter.tmkelvins, DATAUNIT_KELVIN, ecat_Var.temperatureunits );


    FlowVerifier0x8007.ServiceTimeConstant                      =
        get_verifier()->purge_time;
    FlowVerifier0x8007.PurgeCycles                              =
        get_verifier()->purge_cycle;
    FlowVerifier0x8007.Upstream2ValvePosition                   =
        (get_calib()->valve & 0x01) ? 1 : 0;
    FlowVerifier0x8007.UpstreamValvePosition                    =
        (get_calib()->valve & 0x02) ? 1 : 0;
    FlowVerifier0x8007.DownstreamValvePosition                  =
        (get_calib()->valve & 0x04) ? 1 : 0;

    Status0x600F.ServiceInProgress
        = (get_verifier()->state > NORMAL_OPERATION)
          && (get_verifier()->state < PH_SCTRL)  ? true : false;


    DeviceVolume0x9002.Volume = get_calib()->v1 +
                                get_calib()->v2;  // estimated totale device volume



    //FlowVerifyRequest0xFB10.Status = Status0x600F.ServiceInProgress?
    //   (get_calib()->fault==0?(get_calib()->progress+100):2):0;


    ManifoldPurge0xFB11.Status = get_verifier()->purge_status == 0 ?
                                 0 : ((get_verifier()->state == PURGE_START
                                       || get_verifier()->state == PURGE_STOP)
                                      ? (get_calib()->progress + 100) : 255);


    DeviceLeakCheck0xFB12.Status = (get_verifier()->state >= DEV_LEAK_START
                                    && get_verifier()->state <= DEV_LEAK_END) ?
                                   (get_calib()->fault == 0 ? (get_calib()->progress + 100) : 2) : 0;

    SystemLeakCheck0xFB13.Status = (get_verifier()->state >= SYS_LEAK_START
                                    && get_verifier()->state <= SYS_LEAK_END) ?
                                   (get_calib()->fault == 0 ? (get_calib()->progress + 100) : 2) : 0;
    FlowVerifier0x8007.DeviceLeakRate = get_calib()->device_leak_rate;
    FlowVerifier0x8007.SystemLeakRate = get_calib()->sys_leak_rate;

    // Update your zero service status and response here
//    ZeroAdjustForPressureSensor0xFB16.Status = 1;

    // Check if we are recieving input from Master
    if (bEcatInputUpdateRunning)
    {

    }

    //Status0x700F.OutputCycleCounter;  // only if DC is supported
#ifdef ECAT_ERROR_WARNING_ENABLED
    ActiveDeviceWarningDetails0xF381.aEntries[0] = awe.device.warning &
            DeviceWarningMask0xF3A1.aEntries[0];
    if (ActiveDeviceWarningDetails0xF381.aEntries[0] != 0)
    {
        ExceptionStatus0xF380 |= 0x01;
    }
    else
    {
        ExceptionStatus0xF380 &= ~0x01;
    }
    ActiveDeviceErrorDetails0xF383.aEntries[0] = awe.device.error &
            DeviceErrorMask0xF3A3.aEntries[0];
    if (ActiveDeviceErrorDetails0xF383.aEntries[0] != 0)
    {
        ExceptionStatus0xF380 |= 0x04;
    }
    else
    {
        ExceptionStatus0xF380 &= ~0x04;
    }
    //LatchedExceptionStatus0xF390;
    LatchedDeviceWarningDetails0xF391.aEntries[0] |=
        ActiveDeviceWarningDetails0xF381.aEntries[0];
    LatchedDeviceErrorDetails0xF393.aEntries[0] |=
        ActiveDeviceErrorDetails0xF383.aEntries[0];
    //DeviceWarningMask0xF3A1.aEntries[0];
    //DeviceErrorMask0xF3A3.aEntries[0];
#endif
    LatchedTimestamp0xF6F0.aEntries[0] += 2000;
//  UpTime0xF9F6 = meter.timedouble;
//  TotalUpTime0xF9F7 = rtb.totaltime;

    // Services:
    //  SetTemperatureSensor0xFB12  // we do not have this
    //  CardinalPointCalibration0xFB13


#endif
}

#if EXPLICIT_DEVICE_ID
/////////////////////////////////////////////////////////////////////////////////////////
/**
 \return    The Explicit Device ID of the EtherCAT slave

 \brief     Calculate the Explicit Device ID
*////////////////////////////////////////////////////////////////////////////////////////
UINT16 APPL_GetDeviceID()
{
#if _WIN32
#pragma message ("Warning: Implement explicit Device ID latching")
#else
    // return macid
    return ulMacId;
#endif
    /* Explicit Device 5 is expected by Explicit Device ID conformance tests*/
    // should not get here!!!
    return 0x5;
}
#endif

/**
\param     index                    index of the requested object.
\param     subindex                subindex of the requested object.
\param    dataSize                received data size of the SDO Download
\param    pData                    Pointer to the buffer where the written data can be copied from
\param    bCompleteAccess    Indicates if a complete write of all subindices of the
object shall be done or not

\return    result of the write operation (0 (success) or an abort code (ABORTIDX_.... defined in
sdosrv.h))

\brief    This function writes the object 0x8007
*/
UINT8 Write0x8007(UINT16 index, UINT8 subindex, UINT32 dataSize,
                  UINT16 MBXMEM  *pData, UINT8 bCompleteAccess)
{
    UINT8 instance = 0;
    uint8_t tmp_i = 0;

    if (index != 0x8007)
    {
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
    }

    if (bCompleteAccess)
    {
        // cannot do complete access with writes to FB10 as parts of it are RO
        return ABORTIDX_UNSUPPORTED_ACCESS;
    }

    if (subindex > 12)
    {
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
    }

    if (dataSize > 4)
    {
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
    }

    switch (subindex)
    {
        case 1:
            MEMCPY(&FlowVerifier0x8007.SafeState, pData, dataSize);
            break;
        case 2:
            MEMCPY(&FlowVerifier0x8007.HighPressureServiceConstant, pData, dataSize);
            get_calib()->high_press = FlowVerifier0x8007.HighPressureServiceConstant;

            break;
        case 3:
            MEMCPY(&FlowVerifier0x8007.ServiceTimeConstant, pData, dataSize);
            get_verifier()->purge_time = FlowVerifier0x8007.ServiceTimeConstant;
            get_nozzle()->state = get_nozzle()->state | 0x8000;
            flash_proc(WRITE, NOZZLE_SET);
            flash_proc(WRITE, PERROR_SET);
            get_nozzle()->state = 0;
            break;
        case 4:
            MEMCPY(&FlowVerifier0x8007.LowPressureLimit, pData, dataSize);
            break;
        case 5:
            MEMCPY(&FlowVerifier0x8007.PurgeCycles, pData, dataSize);
            get_verifier()->purge_cycle = FlowVerifier0x8007.PurgeCycles;
		    get_verifier()->purge_cycle_count=get_verifier()->purge_cycle;
            get_nozzle()->state = get_nozzle()->state | 0x8000;
            flash_proc(WRITE, NOZZLE_SET);
            flash_proc(WRITE, PERROR_SET);
            get_nozzle()->state = 0;

            break;
        case 6:
            //MEMCPY(&FlowVerifier0x8007.UpstreamValvePosition, pData, dataSize);
            //uint8_t tmp_i = FlowVerifier0x8007.UpstreamValvePosition == 0 ? 1 : 0;
            MEMCPY(&tmp_i, pData, dataSize);
            if (tmp_i == 0)
                tmp_i = 1;
            else
                tmp_i = 0;
            relay_ctrl(LOW_FLOW_UP_SRELAY, tmp_i);
            if (tmp_i == 1)//close
                get_calib()->valve = get_calib()->valve & 0xfffd;
            else
                get_calib()->valve = get_calib()->valve | 0x0002;
            get_verifier()->state = VAVLE_SCTRL;
            break;
        case 7:
            //MEMCPY(&FlowVerifier0x8007.DownstreamValvePosition, pData, dataSize);
            //tmp_i = FlowVerifier0x8007.DownstreamValvePosition; // == 0 ? 1 : 0;
            MEMCPY(&tmp_i, pData, dataSize);

            if (tmp_i == 0)
                tmp_i = 1;
            else
                tmp_i = 0;
            relay_ctrl(DOWN_RELAY, tmp_i);
            if (tmp_i == 1)
                get_calib()->valve = get_calib()->valve & 0xfffb;
            else
                get_calib()->valve = get_calib()->valve | 0x0004;
            get_verifier()->state = VAVLE_SCTRL;
            break;
        case 8:
            //MEMCPY(&FlowVerifier0x8007.Upstream2ValvePosition, pData, dataSize);
            //tmp_i = FlowVerifier0x8007.Upstream2ValvePosition; // == 0 ? 1 : 0;
            MEMCPY(&tmp_i, pData, dataSize);
            if (tmp_i == 0)
                tmp_i = 1;
            else
                tmp_i = 0;
            relay_ctrl(HIGHT_FLOW_UP_SRELAY, tmp_i);
            if (tmp_i == 1)//close
                get_calib()->valve = get_calib()->valve & 0xfffe;
            else
                get_calib()->valve = get_calib()->valve | 0x0001;
            get_verifier()->state = VAVLE_SCTRL;
            break;
        case 9:
            MEMCPY(&FlowVerifier0x8007.PressureFaultLimit, pData, dataSize);
            break;
        case 10:
            MEMCPY(&FlowVerifier0x8007.StabilizationTime, pData, dataSize);
            break;
        default:
            return ABORTIDX_UNSUPPORTED_ACCESS;
            break;
    };
    return 0;
}

/**
\param     index                    index of the requested object.
\param     subindex                subindex of the requested object.
\param    dataSize                received data size of the SDO Download
\param    pData                    Pointer to the buffer where the written data can be copied from
\param    bCompleteAccess    Indicates if a complete write of all subindices of the
object shall be done or not

\return    result of the write operation (0 (success) or an abort code (ABORTIDX_.... defined in
sdosrv.h))

\brief    This function writes the object 0x800A
*/
UINT8 Write0x800u(UINT16 index, UINT8 subindex, UINT32 dataSize,
                  UINT16 MBXMEM  *pData, UINT8 bCompleteAccess)
{
    UINT32 units = 0;
    if ((index != 0x8000) && (index != 0x8001) && (index != 0x8002))
    {
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
    }

    if (bCompleteAccess)
    {
        // cannot do complete access with writes
        return ABORTIDX_UNSUPPORTED_ACCESS;
    }

    if (subindex > 1)
    {
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
    }

    if (dataSize > 4)
    {
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
    }

    switch (subindex)
    {
        case 1:
            switch (index)
            {
                case 0x8000:
                    MEMCPY(&SensorFlowFloating0x8000.FlowDataUnit, pData, dataSize);
                    APPL_ConvertFromEtherCATUnits(SensorFlowFloating0x8000.FlowDataUnit,
                                                  &ecat_Var.flowunits, EcToNativeFlowUnits);
                    break;
                case 0x8001:
                    MEMCPY(&SensorPressureFloating0x8001.PressureDataUnit, pData, dataSize);
                    APPL_ConvertFromEtherCATUnits(SensorPressureFloating0x8001.PressureDataUnit,
                                                  &ecat_Var.pressureunits, EcToNativePresUnits);
                    break;
            }
            break;
        default:
            return ABORTIDX_UNSUPPORTED_ACCESS;
            break;
    };
    return 0;
}

/**
\param     index                    index of the requested object.
\param     subindex                subindex of the requested object.
\param    dataSize                received data size of the SDO Download
\param    pData                    Pointer to the buffer where the written data can be copied from
\param    bCompleteAccess    Indicates if a complete write of all subindices of the
object shall be done or not

\return    result of the write operation (0 (success) or an abort code (ABORTIDX_.... defined in
sdosrv.h))

\brief    This function reads the object 0x10F8
*/
UINT8 Read0xFB10(UINT16 index, UINT8 subindex, UINT32 dataSize,
                 UINT16 MBXMEM *pData, UINT8 bCompleteAccess)
{

    if (index != 0xFB10)
    {
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
    }

    if (bCompleteAccess)
    {
        UINT8 *pData_lcl = (UINT8 *)pData;
        MEMCPY(pData_lcl, &FlowVerifyRequest0xFB10.u16SubIndex0,
               sizeof(FlowVerifyRequest0xFB10.u16SubIndex0));
        pData_lcl += sizeof(FlowVerifyRequest0xFB10.u16SubIndex0);
        MEMCPY(pData_lcl, &FlowVerifyRequest0xFB10.Command,
               sizeof(FlowVerifyRequest0xFB10.Command));
        pData_lcl += sizeof(FlowVerifyRequest0xFB10.Command);
        MEMCPY(pData_lcl, &FlowVerifyRequest0xFB10.MFCPosition,
               sizeof(FlowVerifyRequest0xFB10.MFCPosition));
        pData_lcl += sizeof(FlowVerifyRequest0xFB10.MFCPosition);
        MEMCPY(pData_lcl, &FlowVerifyRequest0xFB10.GSN,
               sizeof(FlowVerifyRequest0xFB10.GSN));
        pData_lcl += sizeof(FlowVerifyRequest0xFB10.GSN);
        MEMCPY(pData_lcl, &FlowVerifyRequest0xFB10.Flow,
               sizeof(FlowVerifyRequest0xFB10.Flow));
        pData_lcl += sizeof(FlowVerifyRequest0xFB10.Flow);
        MEMCPY(pData_lcl, &FlowVerifyRequest0xFB10.Status,
               sizeof(FlowVerifyRequest0xFB10.Status));
        pData_lcl += sizeof(FlowVerifyRequest0xFB10.Status);
        return 0;
    }

    if (subindex > 5)
    {
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
    }

    if (dataSize > 9)
    {
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
    }

    switch (subindex)
    {
        case 0:
            MEMCPY(pData, &FlowVerifyRequest0xFB10.u16SubIndex0, dataSize);
            break;
        case 1:
            MEMCPY(pData, &FlowVerifyRequest0xFB10.Command, dataSize);
            break;
        case 2:
            MEMCPY(pData, &FlowVerifyRequest0xFB10.MFCPosition, dataSize);
            break;
        case 3:
            MEMCPY(pData, &FlowVerifyRequest0xFB10.GSN, dataSize);
            break;
        case 4:
            MEMCPY(pData, &FlowVerifyRequest0xFB10.Flow, dataSize);
            break;
        case 5:
            if (get_calib()->update == 0)//
            {
                if ((get_verifier()->state > NORMAL_OPERATION)
                        && (get_verifier()->state < PH_SCTRL) && (get_calib()->update == 0))
                {
                    if (get_calib()->fault == 0)
                    {
                        if (get_flash_status() == NOPARAMS)
                            FlowVerifyRequest0xFB10.Status = 100+2;//gas invalid add by zm
                        else
                        {
                            //FlowVerifyRequest0xFB10.Status = 255;
                            FlowVerifyRequest0xFB10.Status = get_verifier()->state;//for debug
                        }
                    }
                    else
                    {
                        if (get_calib()->fault == 2)
                            FlowVerifyRequest0xFB10.Status = 100+4;//high pressure add by zm
                        else 
                            FlowVerifyRequest0xFB10.Status = get_calib()->fault+100;//time out add by zm


                    }

                }
				else
					 FlowVerifyRequest0xFB10.Status = 0;

            }

            else
            {
                FlowVerifyRequest0xFB10.Status = get_calib()->update ;
            }
            MEMCPY(pData, &FlowVerifyRequest0xFB10.Status, dataSize);
            break;
        default:
            return ABORTIDX_UNSUPPORTED_ACCESS;
            break;
    };
    return 0;
}

/**
\param     index                    index of the requested object.
\param     subindex                subindex of the requested object.
\param    dataSize                received data size of the SDO Download
\param    pData                    Pointer to the buffer where the written data can be copied from
\param    bCompleteAccess    Indicates if a complete write of all subindices of the
object shall be done or not

\return    result of the write operation (0 (success) or an abort code (ABORTIDX_.... defined in
sdosrv.h))

\brief    This function writes the object 0xFB10
*/
UINT8 Write0xFB10(UINT16 index, UINT8 subindex, UINT32 dataSize,
                  UINT16 MBXMEM  *pData, UINT8 bCompleteAccess)
{

    if (index != 0xFB10)
    {
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
    }

    if (bCompleteAccess)
    {
        // cannot do complete access with writes to FB10 as parts of it are RO
        return ABORTIDX_UNSUPPORTED_ACCESS;
    }

    if (subindex > 5)
    {
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
    }

    if (dataSize > 9)
    {
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
    }

    switch (subindex)
    {
        case 1:
            MEMCPY(&FlowVerifyRequest0xFB10.Command, pData, dataSize);
            if (FlowVerifyRequest0xFB10.Command == 1)   // start verification
            {
                get_calib()->gas_type = FlowVerifyRequest0xFB10.GSN;
                get_gas()->id = FlowVerifyRequest0xFB10.GSN;
                if (get_calib()->state == 1)
                    get_calib()->state = 3; //
                else
                    get_calib()->state = 2;
                get_config()->update = 1;
                flash_proc(READ, GAS_SET);
                get_test()->gas_type = FlowVerifyRequest0xFB10.GSN;

                get_calib()->cali_flow = FlowVerifyRequest0xFB10.Flow;
				get_calib()->state = 3;
//                if (get_calib()->state == 2)
//                    get_calib()->state = 3;
//                else
//                    get_calib()->state = 1;
                get_config()->update = 1;
                get_test()->cali_flow = FlowVerifyRequest0xFB10.Flow;
                get_calib()->progress = 0;
                

            }
            FlowVerifyRequest0xFB10.Command = 0;
            break;
        case 2:
            MEMCPY(&FlowVerifyRequest0xFB10.MFCPosition, pData, dataSize);
            break;
        case 3:
            MEMCPY(&FlowVerifyRequest0xFB10.GSN, pData, dataSize);
            break;
        case 4:
            MEMCPY(&FlowVerifyRequest0xFB10.Flow, pData, dataSize);
            break;
        default:
            return ABORTIDX_UNSUPPORTED_ACCESS;
            break;
    };
    return 0;
}

/**
\param     index                    index of the requested object.
\param     subindex                subindex of the requested object.
\param    dataSize                received data size of the SDO Download
\param    pData                    Pointer to the buffer where the written data can be copied from
\param    bCompleteAccess    Indicates if a complete write of all subindices of the
object shall be done or not

\return    result of the write operation (0 (success) or an abort code (ABORTIDX_.... defined in
sdosrv.h))

\brief    This function reads the object 0x10F8
*/
UINT8 Read0xFB11(UINT16 index, UINT8 subindex, UINT32 dataSize,
                 UINT16 MBXMEM *pData, UINT8 bCompleteAccess)
{

    if (index != 0xFB11)
    {
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
    }

    if (bCompleteAccess)
    {
        UINT8 *pData_lcl = (UINT8 *)pData;
        MEMCPY(pData_lcl, &ManifoldPurge0xFB11.u16SubIndex0,
               sizeof(ManifoldPurge0xFB11.u16SubIndex0));
        pData_lcl += sizeof(ManifoldPurge0xFB11.u16SubIndex0);
        MEMCPY(pData_lcl, &ManifoldPurge0xFB11.Command,
               sizeof(ManifoldPurge0xFB11.Command));
        pData_lcl += sizeof(ManifoldPurge0xFB11.Command);
        MEMCPY(pData_lcl, &ManifoldPurge0xFB11.Status,
               sizeof(ManifoldPurge0xFB11.Status));
        return 0;
    }

    if (subindex > 3)
    {
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
    }

    if (dataSize > 9)
    {
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
    }

    switch (subindex)
    {
        case 0:
            MEMCPY(pData, &ManifoldPurge0xFB11.u16SubIndex0, dataSize);
            break;
        case 1:
            MEMCPY(pData, &ManifoldPurge0xFB11.Command, dataSize);
            break;
        case 2:
            MEMCPY(pData, &ManifoldPurge0xFB11.Status, dataSize);
            break;
        default:
            return ABORTIDX_UNSUPPORTED_ACCESS;
            break;
    };
    return 0;
}

/**
\param     index                    index of the requested object.
\param     subindex                subindex of the requested object.
\param    dataSize                received data size of the SDO Download
\param    pData                    Pointer to the buffer where the written data can be copied from
\param    bCompleteAccess    Indicates if a complete write of all subindices of the
object shall be done or not

\return    result of the write operation (0 (success) or an abort code (ABORTIDX_.... defined in
sdosrv.h))

\brief    This function writes the object 0xFB11
*/
UINT8 Write0xFB11(UINT16 index, UINT8 subindex, UINT32 dataSize,
                  UINT16 MBXMEM  *pData, UINT8 bCompleteAccess)
{

    if (index != 0xFB11)
    {
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
    }

    if (bCompleteAccess)
    {
        // cannot do complete access with writes to FB11 as parts of it are RO
        return ABORTIDX_UNSUPPORTED_ACCESS;
    }

    if (subindex > 3)
    {
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
    }

    if (dataSize > 9)
    {
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
    }

    switch (subindex)
    {
        case 1:
            MEMCPY(&ManifoldPurge0xFB11.Command, pData, dataSize);
            if (ManifoldPurge0xFB11.Command == 0)
            {
                // stop purge cycle
                get_verifier()->state = PURGE_STOP;
                get_verifier()->purge_status = 0;
                get_calib()->state = 0;
            }
            else
            {
                // run purge cycle
                get_verifier()->state = PURGE_START;
				get_verifier()->timer_tick = 0;
                get_verifier()->purge_tick = get_verifier()->timer_tick;
                get_verifier()->purge_status = 1;
                get_calib()->state = 0;
                get_calib()->progress = 0;
                get_calib()->pro_total_time = get_verifier()->purge_cycle *
                                              get_verifier()->purge_time;
                get_calib()->pro_total_time = get_calib()->pro_total_time * 1000;

            }
            break;
        default:
            return ABORTIDX_UNSUPPORTED_ACCESS;
            break;
    };
    return 0;
}

/**
\param     index                    index of the requested object.
\param     subindex                subindex of the requested object.
\param    dataSize                received data size of the SDO Download
\param    pData                    Pointer to the buffer where the written data can be copied from
\param    bCompleteAccess    Indicates if a complete write of all subindices of the
object shall be done or not

\return    result of the write operation (0 (success) or an abort code (ABORTIDX_.... defined in
sdosrv.h))

\brief    This function reads the object 0x10F8
*/
UINT8 Read0xFB12(UINT16 index, UINT8 subindex, UINT32 dataSize,
                 UINT16 MBXMEM *pData, UINT8 bCompleteAccess)
{

    if (index != 0xFB12)
    {
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
    }

    if (bCompleteAccess)
    {
        UINT8 *pData_lcl = (UINT8 *)pData;
        MEMCPY(pData_lcl, &DeviceLeakCheck0xFB12.u16SubIndex0,
               sizeof(DeviceLeakCheck0xFB12.u16SubIndex0));
        pData_lcl += sizeof(DeviceLeakCheck0xFB12.u16SubIndex0);
        MEMCPY(pData_lcl, &DeviceLeakCheck0xFB12.Command,
               sizeof(DeviceLeakCheck0xFB12.Command));
        pData_lcl += sizeof(DeviceLeakCheck0xFB12.Command);
        MEMCPY(pData_lcl, &DeviceLeakCheck0xFB12.Status,
               sizeof(DeviceLeakCheck0xFB12.Status));
        return 0;
    }

    if (subindex > 3)
    {
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
    }

    if (dataSize > 9)
    {
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
    }

    switch (subindex)
    {
        case 0:
            MEMCPY(pData, &DeviceLeakCheck0xFB12.u16SubIndex0, dataSize);
            break;
        case 1:
            MEMCPY(pData, &DeviceLeakCheck0xFB12.Command, dataSize);
            break;
        case 2:
            MEMCPY(pData, &DeviceLeakCheck0xFB12.Status, dataSize);
            break;
        default:
            return ABORTIDX_UNSUPPORTED_ACCESS;
            break;
    };
    return 0;
}

/**
\param     index                    index of the requested object.
\param     subindex                subindex of the requested object.
\param    dataSize                received data size of the SDO Download
\param    pData                    Pointer to the buffer where the written data can be copied from
\param    bCompleteAccess    Indicates if a complete write of all subindices of the
object shall be done or not

\return    result of the write operation (0 (success) or an abort code (ABORTIDX_.... defined in
sdosrv.h))

\brief    This function writes the object 0xFB11
*/
UINT8 Write0xFB12(UINT16 index, UINT8 subindex, UINT32 dataSize,
                  UINT16 MBXMEM  *pData, UINT8 bCompleteAccess)
{

    if (index != 0xFB12)
    {
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
    }

    if (bCompleteAccess)
    {
        // cannot do complete access with writes to FB11 as parts of it are RO
        return ABORTIDX_UNSUPPORTED_ACCESS;
    }

    if (subindex > 2)
    {
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
    }

    if (dataSize > 2)
    {
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
    }

    switch (subindex)
    {
        case 1:
            MEMCPY(&DeviceLeakCheck0xFB12.Command, pData, dataSize);
            if (DeviceLeakCheck0xFB12.Command == 0)
            {
                get_verifier()->state = DEV_LEAK_END;
                get_verifier()->purge_tick = get_verifier()->timer_tick;
                //get_verifier()->purge_status = 1;
                get_calib()->state = 0;
            }
            else
            {
                get_verifier()->state = DEV_LEAK_START;
				get_verifier()->timer_tick = 0;
                get_verifier()->purge_tick = get_verifier()->timer_tick;
                //get_verifier()->purge_status = 1;
                get_calib()->state = 0;
                get_calib()->progress = 0;
                get_calib()->pro_total_time = get_verifier()->purge_cycle *
                                              get_verifier()->purge_time;
                get_calib()->pro_total_time = get_calib()->pro_total_time * 1000;
            }
            break;
        default:
            return ABORTIDX_UNSUPPORTED_ACCESS;
            break;
    };
    return 0;
}

/**
\param     index                    index of the requested object.
\param     subindex                subindex of the requested object.
\param    dataSize                received data size of the SDO Download
\param    pData                    Pointer to the buffer where the written data can be copied from
\param    bCompleteAccess    Indicates if a complete write of all subindices of the
object shall be done or not

\return    result of the write operation (0 (success) or an abort code (ABORTIDX_.... defined in
sdosrv.h))

\brief    This function reads the object 0x10F8
*/
UINT8 Read0xFB13(UINT16 index, UINT8 subindex, UINT32 dataSize,
                 UINT16 MBXMEM *pData, UINT8 bCompleteAccess)
{

    if (index != 0xFB13)
    {
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
    }

    if (bCompleteAccess)
    {
        UINT8 *pData_lcl = (UINT8 *)pData;
        MEMCPY(pData_lcl, &SystemLeakCheck0xFB13.u16SubIndex0,
               sizeof(SystemLeakCheck0xFB13.u16SubIndex0));
        pData_lcl += sizeof(SystemLeakCheck0xFB13.u16SubIndex0);
        MEMCPY(pData_lcl, &SystemLeakCheck0xFB13.Command,
               sizeof(SystemLeakCheck0xFB13.Command));
        pData_lcl += sizeof(SystemLeakCheck0xFB13.Command);
        MEMCPY(pData_lcl, &SystemLeakCheck0xFB13.Status,
               sizeof(SystemLeakCheck0xFB13.Status));
        pData_lcl += sizeof(SystemLeakCheck0xFB13.Status);
        return 0;
    }

    if (subindex > 3)
    {
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
    }

    if (dataSize > 170)
    {
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
    }

    switch (subindex)
    {
        case 0:
            MEMCPY(pData, &SystemLeakCheck0xFB13.u16SubIndex0, dataSize);
            break;
        case 1:
            MEMCPY(pData, &SystemLeakCheck0xFB13.Command, dataSize);
            break;
        case 2:
            MEMCPY(pData, &SystemLeakCheck0xFB13.Status, dataSize);
            break;
        default:
            return ABORTIDX_UNSUPPORTED_ACCESS;
            break;
    };
    return 0;
}

/**
\param     index                    index of the requested object.
\param     subindex                subindex of the requested object.
\param    dataSize                received data size of the SDO Download
\param    pData                    Pointer to the buffer where the written data can be copied from
\param    bCompleteAccess    Indicates if a complete write of all subindices of the
object shall be done or not

\return    result of the write operation (0 (success) or an abort code (ABORTIDX_.... defined in
sdosrv.h))

\brief    This function reads the object 0x10F8
*/
UINT8 Write0xFB13(UINT16 index, UINT8 subindex, UINT32 dataSize,
                  UINT16 MBXMEM  *pData, UINT8 bCompleteAccess)
{

    if (index != 0xFB13)
    {
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
    }

    if (bCompleteAccess)
    {
        // cannot do complete access with writes to FB13 as parts of it are RO
        return ABORTIDX_UNSUPPORTED_ACCESS;
    }

    if (subindex > 3)
    {
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
    }

    if (dataSize > 2)
    {
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
    }

    switch (subindex)
    {
        case 1:
            MEMCPY(&SystemLeakCheck0xFB13.Command, pData, dataSize);
            if (SystemLeakCheck0xFB13.Command == 0)
            {
                get_verifier()->state = SYS_LEAK_END;
                get_verifier()->purge_tick = get_verifier()->timer_tick;
                //get_verifier()->purge_status = 1;
                get_calib()->state = 0;
            }
            else
            {
                get_verifier()->state = SYS_LEAK_START;
				get_verifier()->timer_tick = 0;
                get_verifier()->purge_tick = get_verifier()->timer_tick;
                //get_verifier()->purge_status = 1;
                get_calib()->state = 0;
                get_calib()->progress = 0;
                get_calib()->pro_total_time = get_verifier()->purge_cycle *
                                              get_verifier()->purge_time;
                get_calib()->pro_total_time = get_calib()->pro_total_time * 1000;
            }
            break;
        default:
            return ABORTIDX_UNSUPPORTED_ACCESS;
            break;
    };
    return 0;
}
/**
\param     index                    index of the requested object.
\param     subindex                subindex of the requested object.
\param    dataSize                received data size of the SDO Download
\param    pData                    Pointer to the buffer where the written data can be copied from
\param    bCompleteAccess    Indicates if a complete write of all subindices of the
object shall be done or not

\return    result of the write operation (0 (success) or an abort code (ABORTIDX_.... defined in
sdosrv.h))

\brief    This function reads the object 0x10F8
*/
UINT8 Read0xFB14(UINT16 index, UINT8 subindex, UINT32 dataSize,
                 UINT16 MBXMEM *pData, UINT8 bCompleteAccess)
{

    if (index != 0xFB14)
    {
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
    }

    if (bCompleteAccess)
    {
        UINT8 *pData_lcl = (UINT8 *)pData;
        MEMCPY(pData_lcl, &FlowVerifyResetService0xFB14.u16SubIndex0,
               sizeof(FlowVerifyResetService0xFB14.u16SubIndex0));
        pData_lcl += sizeof(FlowVerifyResetService0xFB14.u16SubIndex0);
        MEMCPY(pData_lcl, &FlowVerifyResetService0xFB14.Command,
               sizeof(FlowVerifyResetService0xFB14.Command));
        pData_lcl += sizeof(FlowVerifyResetService0xFB14.Command);
        MEMCPY(pData_lcl, &FlowVerifyResetService0xFB14.Status,
               sizeof(FlowVerifyResetService0xFB14.Status));
        pData_lcl += sizeof(FlowVerifyResetService0xFB14.Status);
        return 0;
    }

    if (subindex > 3)
    {
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
    }

    if (dataSize > 170)
    {
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
    }

    switch (subindex)
    {
        case 0:
            MEMCPY(pData, &FlowVerifyResetService0xFB14.u16SubIndex0, dataSize);
            break;
        case 1:
            MEMCPY(pData, &FlowVerifyResetService0xFB14.Command, dataSize);
            break;
        case 2:
			if(get_verifier()->state == NORMAL_OPERATION)
				FlowVerifyResetService0xFB14.Status = 0;
			else
				FlowVerifyResetService0xFB14.Status = 1;	
          //  MEMCPY(pData, &FlowVerifyResetService0xFB14.Status, dataSize);
            break;
        default:
            return ABORTIDX_UNSUPPORTED_ACCESS;
            break;
    };
    return 0;
}

/**
\param     index                    index of the requested object.
\param     subindex                subindex of the requested object.
\param    dataSize                received data size of the SDO Download
\param    pData                    Pointer to the buffer where the written data can be copied from
\param    bCompleteAccess    Indicates if a complete write of all subindices of the
object shall be done or not

\return    result of the write operation (0 (success) or an abort code (ABORTIDX_.... defined in
sdosrv.h))

\brief    This function reads the object 0x10F8
*/
UINT8 Write0xFB14(UINT16 index, UINT8 subindex, UINT32 dataSize,
                  UINT16 MBXMEM  *pData, UINT8 bCompleteAccess)
{
    UINT16 gasid;
    UINT8 instance;
    float fsrange;
    if (index != 0xFB14)
    {
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
    }

    if (bCompleteAccess)
    {
        // cannot do complete access with writes to FB13 as parts of it are RO
        return ABORTIDX_UNSUPPORTED_ACCESS;
    }

    if (subindex > 3)
    {
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
    }

    if (dataSize > 1)
    {
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
    }

    switch (subindex)
    {
    case 1:
                MEMCPY(&FlowVerifyResetService0xFB14.Command, pData, dataSize);
            if (FlowVerifyResetService0xFB14.Command == 1)   // start verification
            {
                get_config()->update = 0;
               get_verifier()->state = NORMAL_OPERATION;
			   get_calib()->fault = 0;
			   get_calib()->update = 0;
			   get_verifier()->timer_tick = 0;
            }
            FlowVerifyResetService0xFB14.Command = 0;
            break;
        default:
            return ABORTIDX_UNSUPPORTED_ACCESS;
            break;
    };
    return 0;
}
/**
\param     index                    index of the requested object.
\param     subindex                subindex of the requested object.
\param    dataSize                received data size of the SDO Download
\param    pData                    Pointer to the buffer where the written data can be copied from
\param    bCompleteAccess    Indicates if a complete write of all subindices of the
object shall be done or not

\return    result of the write operation (0 (success) or an abort code (ABORTIDX_.... defined in
sdosrv.h))

\brief    This function reads the object 0xfb16
*/
UINT8 Read0xFB16(UINT16 index, UINT8 subindex, UINT32 dataSize,
                 UINT16 MBXMEM *pData, UINT8 bCompleteAccess)
{

    if (index != 0xFB16)
    {
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
    }

    if (bCompleteAccess)
    {
        UINT8 *pData_lcl = (UINT8 *)pData;
        MEMCPY(pData_lcl, &ZeroAdjustForPressureSensor0xFB16.u16SubIndex0,
               sizeof(ZeroAdjustForPressureSensor0xFB16.u16SubIndex0));
        pData_lcl += sizeof(ZeroAdjustForPressureSensor0xFB16.u16SubIndex0);
        MEMCPY(pData_lcl, &ZeroAdjustForPressureSensor0xFB16.TargetZero,
               sizeof(ZeroAdjustForPressureSensor0xFB16.TargetZero));
        pData_lcl += sizeof(ZeroAdjustForPressureSensor0xFB16.TargetZero);
        MEMCPY(pData_lcl, &ZeroAdjustForPressureSensor0xFB16.Status,
               sizeof(ZeroAdjustForPressureSensor0xFB16.Status));
        return 0;
    }

    if (subindex > 2)
    {
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
    }

    if (dataSize > 4)
    {
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
    }

    switch (subindex)
    {
        case 0:
            MEMCPY(pData, &ZeroAdjustForPressureSensor0xFB16.u16SubIndex0, dataSize);
            break;
        case 1:
            MEMCPY(pData, &ZeroAdjustForPressureSensor0xFB16.TargetZero, dataSize);
            break;
        case 2:
            if (get_zero_status() & 0x06)
                ZeroAdjustForPressureSensor0xFB16.Status = 1;
            else
                ZeroAdjustForPressureSensor0xFB16.Status = 0;
            MEMCPY(pData, &ZeroAdjustForPressureSensor0xFB16.Status, dataSize);
            break;
        default:
            return ABORTIDX_UNSUPPORTED_ACCESS;
            break;
    };
    return 0;
}

/**
\param     index                    index of the requested object.
\param     subindex                subindex of the requested object.
\param    dataSize                received data size of the SDO Download
\param    pData                    Pointer to the buffer where the written data can be copied from
\param    bCompleteAccess    Indicates if a complete write of all subindices of the
object shall be done or not

\return    result of the write operation (0 (success) or an abort code (ABORTIDX_.... defined in
sdosrv.h))

\brief    This function reads the object 0x10F8
*/
UINT8 Write0xFB16(UINT16 index, UINT8 subindex, UINT32 dataSize,
                  UINT16 MBXMEM  *pData, UINT8 bCompleteAccess)
{
    if (index != 0xFB16)
    {
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
    }

    if (bCompleteAccess)
    {
        // cannot do complete access with writes to FB16 as parts of it are RO
        return ABORTIDX_UNSUPPORTED_ACCESS;
    }

    if (subindex > 2)
    {
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
    }

    if (dataSize > 4)
    {
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
    }

    switch (subindex)
    {
        case 1:
            MEMCPY(&ZeroAdjustForPressureSensor0xFB16.TargetZero, pData, dataSize);
            zero_adjust(ZeroAdjustForPressureSensor0xFB16.TargetZero, 0x21, 0x22);
            //get_cdg_status()->zero_flag = 1;  // zero the CDG
            break;
        default:
            return ABORTIDX_UNSUPPORTED_ACCESS;
            break;
    };
    return 0;
}

/**
\param     index                    index of the requested object.
\param     subindex                subindex of the requested object.
\param    dataSize                received data size of the SDO Download
\param    pData                    Pointer to the buffer where the written data can be copied from
\param    bCompleteAccess    Indicates if a complete write of all subindices of the
object shall be done or not

\return    result of the write operation (0 (success) or an abort code (ABORTIDX_.... defined in
sdosrv.h))

\brief    This function reads the object 0x10F8
*/
UINT8 Read0xFBF0(UINT16 index, UINT8 subindex, UINT32 dataSize,
                 UINT16 MBXMEM *pData, UINT8 bCompleteAccess)
{

    if (index != 0xFBF0)
    {
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
    }

    if (bCompleteAccess)
    {
        UINT8 *pData_lcl = (UINT8 *)pData;
        MEMCPY(pData_lcl, &DeviceReset0xFBF0.u16SubIndex0,
               sizeof(DeviceReset0xFBF0.u16SubIndex0));
        pData_lcl += sizeof(DeviceReset0xFBF0.u16SubIndex0);
        MEMCPY(pData_lcl, &DeviceReset0xFBF0.Command,
               sizeof(DeviceReset0xFBF0.Command));
        pData_lcl += sizeof(DeviceReset0xFBF0.Command);
        MEMCPY(pData_lcl, &DeviceReset0xFBF0.Status, sizeof(DeviceReset0xFBF0.Status));
        pData_lcl += sizeof(DeviceReset0xFBF0.Status);
        MEMCPY(pData_lcl, &DeviceReset0xFBF0.Response,
               sizeof(DeviceReset0xFBF0.Response));
        return 0;
    }

    if (subindex > 3)
    {
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
    }

    if (dataSize > 9)
    {
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
    }

    switch (subindex)
    {
        case 0:
            MEMCPY(pData, &DeviceReset0xFBF0.u16SubIndex0, dataSize);
            break;
        case 1:
            MEMCPY(pData, &DeviceReset0xFBF0.Command, dataSize);
            break;
        case 2:
            MEMCPY(pData, &DeviceReset0xFBF0.Status, dataSize);
            break;
        case 3:
            MEMCPY(pData, &DeviceReset0xFBF0.Response, dataSize);
            break;
        default:
            return ABORTIDX_UNSUPPORTED_ACCESS;
            break;
    };
    return 0;
}

/**
\param     index                    index of the requested object.
\param     subindex                subindex of the requested object.
\param    dataSize                received data size of the SDO Download
\param    pData                    Pointer to the buffer where the written data can be copied from
\param    bCompleteAccess    Indicates if a complete write of all subindices of the
object shall be done or not

\return    result of the write operation (0 (success) or an abort code (ABORTIDX_.... defined in
sdosrv.h))

\brief    This function reads the object 0x10F8
*/
UINT8 Write0xFBF0(UINT16 index, UINT8 subindex, UINT32 dataSize,
                  UINT16 MBXMEM  *pData, UINT8 bCompleteAccess)
{

    if (index != 0xFBF0)
    {
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
    }

    if (bCompleteAccess)
    {
        // cannot do complete access with writes to FBF0 as parts of it are RO
        return ABORTIDX_UNSUPPORTED_ACCESS;
    }

    if (subindex > 3)
    {
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
    }

    if (dataSize > 9)
    {
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
    }

    switch (subindex)
    {
        case 1:
            MEMCPY(DeviceReset0xFBF0.Command, pData, dataSize);
            if (strncmp(DeviceReset0xFBF0.Command, "teser", 5) == 0)
            {
                if (DeviceReset0xFBF0.Command[5] == 0x00)
                {
                    // normal device reset
                    reset_device = 1;
                }
                else if (DeviceReset0xFBF0.Command[5] == 0x66)
                {
                    // factory reset
                }
            }
            break;
        default:
            return ABORTIDX_UNSUPPORTED_ACCESS;
            break;
    };
    return 0;
}

/**
\param     index                    index of the requested object.
\param     subindex                subindex of the requested object.
\param    dataSize                received data size of the SDO Download
\param    pData                    Pointer to the buffer where the written data can be copied from
\param    bCompleteAccess    Indicates if a complete write of all subindices of the
object shall be done or not

\return    result of the write operation (0 (success) or an abort code (ABORTIDX_.... defined in
sdosrv.h))

\brief    This function reads the object 0x10F8
*/
UINT8 Read0xFBF1(UINT16 index, UINT8 subindex, UINT32 dataSize,
                 UINT16 MBXMEM *pData, UINT8 bCompleteAccess)
{

    if (index != 0xFBF1)
    {
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
    }

    if (bCompleteAccess)
    {
        UINT8 *pData_lcl = (UINT8 *)pData;
        MEMCPY(pData_lcl, &ExceptionReset0xFBF1.u16SubIndex0,
               sizeof(ExceptionReset0xFBF1.u16SubIndex0));
        pData_lcl += sizeof(ExceptionReset0xFBF1.u16SubIndex0);
        MEMCPY(pData_lcl, &ExceptionReset0xFBF1.Command,
               sizeof(ExceptionReset0xFBF1.Command));
        pData_lcl += sizeof(ExceptionReset0xFBF1.Command);
        MEMCPY(pData_lcl, &ExceptionReset0xFBF1.Status,
               sizeof(ExceptionReset0xFBF1.Status));
        pData_lcl += sizeof(ExceptionReset0xFBF1.Status);
        MEMCPY(pData_lcl, &ExceptionReset0xFBF1.Response,
               sizeof(ExceptionReset0xFBF1.Response));
        return 0;
    }

    if (subindex > 3)
    {
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
    }

    if (dataSize > 9)
    {
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
    }

    switch (subindex)
    {
        case 0:
            MEMCPY(pData, &ExceptionReset0xFBF1.u16SubIndex0, dataSize);
            break;
        case 1:
            MEMCPY(pData, &ExceptionReset0xFBF1.Command, dataSize);
            break;
        case 2:
            MEMCPY(pData, &ExceptionReset0xFBF1.Status, dataSize);
            break;
        case 3:
            MEMCPY(pData, &ExceptionReset0xFBF1.Response, dataSize);
            break;
        default:
            return ABORTIDX_UNSUPPORTED_ACCESS;
            break;
    };
    return 0;
}

/**
\param     index                    index of the requested object.
\param     subindex                subindex of the requested object.
\param    dataSize                received data size of the SDO Download
\param    pData                    Pointer to the buffer where the written data can be copied from
\param    bCompleteAccess    Indicates if a complete write of all subindices of the
object shall be done or not

\return    result of the write operation (0 (success) or an abort code (ABORTIDX_.... defined in
sdosrv.h))

\brief    This function reads the object 0x10F8
*/
UINT8 Write0xFBF1(UINT16 index, UINT8 subindex, UINT32 dataSize,
                  UINT16 MBXMEM  *pData, UINT8 bCompleteAccess)
{

    if (index != 0xFBF1)
    {
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
    }

    if (bCompleteAccess)
    {
        // cannot do complete access with writes to FBF1 as parts of it are RO
        return ABORTIDX_UNSUPPORTED_ACCESS;
    }

    if (subindex > 3)
    {
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
    }

    if (dataSize > 9)
    {
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
    }

    switch (subindex)
    {
        case 1:
            MEMCPY(ExceptionReset0xFBF1.Command, pData, dataSize);
            if (strncmp(ExceptionReset0xFBF1.Command, "teser", 5) == 0)
            {
                // reset exception bits here
            }
            break;
        default:
            return ABORTIDX_UNSUPPORTED_ACCESS;
            break;
    };
    return 0;
}

/**
\param     index                    index of the requested object.
\param     subindex                subindex of the requested object.
\param    dataSize                received data size of the SDO Download
\param    pData                    Pointer to the buffer where the written data can be copied from
\param    bCompleteAccess    Indicates if a complete write of all subindices of the
object shall be done or not

\return    result of the write operation (0 (success) or an abort code (ABORTIDX_.... defined in
sdosrv.h))

\brief    This function reads the object 0x10F8
*/
UINT8 Read0xFBF2(UINT16 index, UINT8 subindex, UINT32 dataSize,
                 UINT16 MBXMEM *pData, UINT8 bCompleteAccess)
{

    if (index != 0xFBF2)
    {
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
    }

    if (bCompleteAccess)
    {
        UINT8 *pData_lcl = (UINT8 *)pData;
        MEMCPY(pData_lcl, &StoreParam0xFBF2.u16SubIndex0,
               sizeof(StoreParam0xFBF2.u16SubIndex0));
        pData_lcl += sizeof(StoreParam0xFBF2.u16SubIndex0);
        MEMCPY(pData_lcl, &StoreParam0xFBF2.Command, sizeof(StoreParam0xFBF2.Command));
        pData_lcl += sizeof(StoreParam0xFBF2.Command);
        MEMCPY(pData_lcl, &StoreParam0xFBF2.Status, sizeof(StoreParam0xFBF2.Status));
        pData_lcl += sizeof(StoreParam0xFBF2.Status);
        MEMCPY(pData_lcl, &StoreParam0xFBF2.Response,
               sizeof(StoreParam0xFBF2.Response));
        return 0;
    }

    if (subindex > 3)
    {
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
    }

    if (dataSize > 9)
    {
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
    }

    switch (subindex)
    {
        case 0:
            MEMCPY(pData, &StoreParam0xFBF2.u16SubIndex0, dataSize);
            break;
        case 1:
            MEMCPY(pData, &StoreParam0xFBF2.Command, dataSize);
            break;
        case 2:
            MEMCPY(pData, &StoreParam0xFBF2.Status, dataSize);
            break;
        case 3:
            MEMCPY(pData, &StoreParam0xFBF2.Response, dataSize);
            break;
        default:
            return ABORTIDX_UNSUPPORTED_ACCESS;
            break;
    };
    return 0;
}

/**
\param     index                    index of the requested object.
\param     subindex                subindex of the requested object.
\param    dataSize                received data size of the SDO Download
\param    pData                    Pointer to the buffer where the written data can be copied from
\param    bCompleteAccess    Indicates if a complete write of all subindices of the
object shall be done or not

\return    result of the write operation (0 (success) or an abort code (ABORTIDX_.... defined in
sdosrv.h))

\brief    This function reads the object 0x10F8
*/
UINT8 Write0xFBF2(UINT16 index, UINT8 subindex, UINT32 dataSize,
                  UINT16 MBXMEM  *pData, UINT8 bCompleteAccess)
{

    if (index != 0xFBF2)
    {
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
    }

    if (bCompleteAccess)
    {
        // cannot do complete access with writes to FBF2 as parts of it are RO
        return ABORTIDX_UNSUPPORTED_ACCESS;
    }

    if (subindex > 3)
    {
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
    }

    if (dataSize > 9)
    {
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
    }

    switch (subindex)
    {
        case 1:
            MEMCPY(StoreParam0xFBF2.Command, pData, dataSize);
            if (strncmp(StoreParam0xFBF2.Command, "evas", 4) == 0)
            {
                // initiate NV save in here
            }
            break;
        default:
            return ABORTIDX_UNSUPPORTED_ACCESS;
            break;
    };
    return 0;
}

/**
\param     index                    index of the requested object.
\param     subindex                subindex of the requested object.
\param    dataSize                received data size of the SDO Download
\param    pData                    Pointer to the buffer where the written data can be copied from
\param    bCompleteAccess    Indicates if a complete write of all subindices of the
object shall be done or not

\return    result of the write operation (0 (success) or an abort code (ABORTIDX_.... defined in
sdosrv.h))

\brief    This function reads the object 0x10F8
*/
UINT8 Read0xFBF3(UINT16 index, UINT8 subindex, UINT32 dataSize,
                 UINT16 MBXMEM *pData, UINT8 bCompleteAccess)
{

    if (index != 0xFBF3)
    {
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
    }

    if (bCompleteAccess)
    {
        UINT8 *pData_lcl = (UINT8 *)pData;
        MEMCPY(pData_lcl, &CalcChecksum0xFBF3.u16SubIndex0,
               sizeof(CalcChecksum0xFBF3.u16SubIndex0));
        pData_lcl += sizeof(CalcChecksum0xFBF3.u16SubIndex0);
        MEMCPY(pData_lcl, &CalcChecksum0xFBF3.Command,
               sizeof(CalcChecksum0xFBF3.Command));
        pData_lcl += sizeof(CalcChecksum0xFBF3.Command);
        MEMCPY(pData_lcl, &CalcChecksum0xFBF3.Status,
               sizeof(CalcChecksum0xFBF3.Status));
        pData_lcl += sizeof(CalcChecksum0xFBF3.Status);
        MEMCPY(pData_lcl, &CalcChecksum0xFBF3.Response,
               sizeof(CalcChecksum0xFBF3.Response));
        return 0;
    }

    if (subindex > 3)
    {
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
    }

    if (dataSize > 9)
    {
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
    }

    switch (subindex)
    {
        case 0:
            MEMCPY(pData, &CalcChecksum0xFBF3.u16SubIndex0, dataSize);
            break;
        case 1:
            MEMCPY(pData, &CalcChecksum0xFBF3.Command, dataSize);
            break;
        case 2:
            MEMCPY(pData, &CalcChecksum0xFBF3.Status, dataSize);
            break;
        case 3:
            MEMCPY(pData, &CalcChecksum0xFBF3.Response, dataSize);
            break;
        default:
            return ABORTIDX_UNSUPPORTED_ACCESS;
            break;
    };
    return 0;
}

/**
\param     index                    index of the requested object.
\param     subindex                subindex of the requested object.
\param    dataSize                received data size of the SDO Download
\param    pData                    Pointer to the buffer where the written data can be copied from
\param    bCompleteAccess    Indicates if a complete write of all subindices of the
object shall be done or not

\return    result of the write operation (0 (success) or an abort code (ABORTIDX_.... defined in
sdosrv.h))

\brief    This function reads the object 0x10F8
*/
UINT8 Write0xFBF3(UINT16 index, UINT8 subindex, UINT32 dataSize,
                  UINT16 MBXMEM  *pData, UINT8 bCompleteAccess)
{

    if (index != 0xFBF3)
    {
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
    }

    if (bCompleteAccess)
    {
        // cannot do complete access with writes to FBF3 as parts of it are RO
        return ABORTIDX_UNSUPPORTED_ACCESS;
    }

    if (subindex > 3)
    {
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
    }

    if (dataSize > 9)
    {
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
    }

    switch (subindex)
    {
        case 1:
            MEMCPY(CalcChecksum0xFBF3.Command, pData, dataSize);
            if (CalcChecksum0xFBF3.Command[0] & 0x80)
            {
                // calcualte checksum and store in results
            }
            break;
        default:
            return ABORTIDX_UNSUPPORTED_ACCESS;
            break;
    };
    return 0;
}

/**
\param     index                    index of the requested object.
\param     subindex                subindex of the requested object.
\param    dataSize                received data size of the SDO Download
\param    pData                    Pointer to the buffer where the written data can be copied from
\param    bCompleteAccess    Indicates if a complete write of all subindices of the
object shall be done or not

\return    result of the write operation (0 (success) or an abort code (ABORTIDX_.... defined in
sdosrv.h))

\brief    This function reads the object 0x10F8
*/
UINT8 Read0xFBF4(UINT16 index, UINT8 subindex, UINT32 dataSize,
                 UINT16 MBXMEM *pData, UINT8 bCompleteAccess)
{

    if (index != 0xFBF4)
    {
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
    }

    if (bCompleteAccess)
    {
        UINT8 *pData_lcl = (UINT8 *)pData;
        MEMCPY(pData_lcl, &LoadParam0xFBF4.u16SubIndex0,
               sizeof(LoadParam0xFBF4.u16SubIndex0));
        pData_lcl += sizeof(LoadParam0xFBF4.u16SubIndex0);
        MEMCPY(pData_lcl, &LoadParam0xFBF4.Command, sizeof(LoadParam0xFBF4.Command));
        pData_lcl += sizeof(LoadParam0xFBF4.Command);
        MEMCPY(pData_lcl, &LoadParam0xFBF4.Status, sizeof(LoadParam0xFBF4.Status));
        pData_lcl += sizeof(LoadParam0xFBF4.Status);
        MEMCPY(pData_lcl, &LoadParam0xFBF4.Response, sizeof(LoadParam0xFBF4.Response));
        return 0;
    }

    if (subindex > 3)
    {
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
    }

    if (dataSize > 9)
    {
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
    }

    switch (subindex)
    {
        case 0:
            MEMCPY(pData, &LoadParam0xFBF4.u16SubIndex0, dataSize);
            break;
        case 1:
            MEMCPY(pData, &LoadParam0xFBF4.Command, dataSize);
            break;
        case 2:
            MEMCPY(pData, &LoadParam0xFBF4.Status, dataSize);
            break;
        case 3:
            MEMCPY(pData, &LoadParam0xFBF4.Response, dataSize);
            break;
        default:
            return ABORTIDX_UNSUPPORTED_ACCESS;
            break;
    };
    return 0;
}

/**
\param     index                    index of the requested object.
\param     subindex                subindex of the requested object.
\param    dataSize                received data size of the SDO Download
\param    pData                    Pointer to the buffer where the written data can be copied from
\param    bCompleteAccess    Indicates if a complete write of all subindices of the
object shall be done or not

\return    result of the write operation (0 (success) or an abort code (ABORTIDX_.... defined in
sdosrv.h))

\brief    This function reads the object 0x10F8
*/
UINT8 Write0xFBF4(UINT16 index, UINT8 subindex, UINT32 dataSize,
                  UINT16 MBXMEM  *pData, UINT8 bCompleteAccess)
{

    if (index != 0xFBF4)
    {
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
    }

    if (bCompleteAccess)
    {
        // cannot do complete access with writes to FBF4 as parts of it are RO
        return ABORTIDX_UNSUPPORTED_ACCESS;
    }

    if (subindex > 3)
    {
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
    }

    if (dataSize > 9)
    {
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
    }

    switch (subindex)
    {
        case 1:
            MEMCPY(LoadParam0xFBF4.Command, pData, dataSize);
            if (strncmp(LoadParam0xFBF4.Command, "daol", 4) == 0)
            {
                // initiate NV load in here
            }
            break;
        default:
            return ABORTIDX_UNSUPPORTED_ACCESS;
            break;
    };
    return 0;
}

#define STATION_ALIAS_REGISTER  0x0012
/************************************************************************/
/*                                                                      */
/************************************************************************/
void UpdateAliasRegister(void)
{
    static bool configComplete = false;
    static UINT16 culMacId = 0;

    if (!configComplete)
    {
#if VER_485_ECAT == 1
        ulMacId = getSwitch();
        if (ulMacId != 0)
        {
            HW_EscWriteWord(ulMacId, STATION_ALIAS_REGISTER);
        }
        else
        {
            HW_EscReadWord(ulMacId, STATION_ALIAS_REGISTER);
            culMacId = ulMacId; // latch current MacID
        }
#endif
        configComplete = true;
    }
    else
    {
#if VER_485_ECAT == 1
        if (checkAddressInt())
        {

            ulMacId = getSwitch();
            if (ulMacId != 0)
            {
                HW_EscWriteWord(ulMacId, STATION_ALIAS_REGISTER);
            }
            else
            {
                ulMacId = culMacId;
                HW_EscWriteWord(ulMacId, STATION_ALIAS_REGISTER);
            }
        }
#endif
    }
}

#if USE_DEFAULT_MAIN
/////////////////////////////////////////////////////////////////////////////////////////
/**

 \brief    This is the main function

*////////////////////////////////////////////////////////////////////////////////////////
#if _PIC24
int main(void)
#else
void main(void)
#endif
{
    /* initialize the Hardware and the EtherCAT Slave Controller */
#if FC1100_HW
    if (HW_Init())
    {
        HW_Release();
        return;
    }
#else
    HW_Init();
#endif
    MainInit();

    bRunApplication = TRUE;
    do
    {
        MainLoop();

    }
    while (bRunApplication == TRUE);

    HW_Release();
#if _PIC24
    return 0;
#endif
}
#endif //#if USE_DEFAULT_MAIN
/** @} */

#endif          // ifdef ECAT
