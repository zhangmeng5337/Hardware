; generated by ARM C/C++ Compiler, 4.1 [Build 713]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\main.o --asm_dir=.\output\ --list_dir=.\output\ --depend=.\output\main.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\ -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\INC\ST\STM32F10x --omf_browse=.\output\main.crf main.c]
                          THUMB

                          AREA ||i.Delay||, CODE, READONLY, ALIGN=2

                  Delay PROC
;;;352    *******************************************************************************/
;;;353    void Delay(u32 nTime)
000000  b510              PUSH     {r4,lr}
;;;354    {
000002  4604              MOV      r4,r0
;;;355      /* Enable the SysTick Counter */
;;;356      SysTick_CounterCmd(SysTick_Counter_Enable);
000004  f04f0001          MOV      r0,#1
000008  f7fffffe          BL       SysTick_CounterCmd
;;;357      
;;;358      TimingDelay = nTime;
00000c  4806              LDR      r0,|L1.40|
00000e  6004              STR      r4,[r0,#0]  ; TimingDelay
;;;359    
;;;360      while(TimingDelay != 0);
000010  bf00              NOP      
                  |L1.18|
000012  4805              LDR      r0,|L1.40|
000014  6800              LDR      r0,[r0,#0]  ; TimingDelay
000016  2800              CMP      r0,#0
000018  d1fb              BNE      |L1.18|
;;;361    
;;;362      /* Disable the SysTick Counter */
;;;363      SysTick_CounterCmd(SysTick_Counter_Disable);
00001a  1e80              SUBS     r0,r0,#2
00001c  f7fffffe          BL       SysTick_CounterCmd
;;;364      /* Clear the SysTick Counter */
;;;365      SysTick_CounterCmd(SysTick_Counter_Clear);
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       SysTick_CounterCmd
;;;366    }
000026  bd10              POP      {r4,pc}
;;;367    
                          ENDP

                  |L1.40|
                          DCD      TimingDelay

                          AREA ||i.EXTI_Configuration||, CODE, READONLY, ALIGN=1

                  EXTI_Configuration PROC
;;;229    *******************************************************************************/
;;;230    void EXTI_Configuration(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;231    {
;;;232      EXTI_InitTypeDef EXTI_InitStructure;
;;;233    
;;;234      /* Connect EXTI Line8 to PC.08 */
;;;235      GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource8);
000002  2108              MOVS     r1,#8
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       GPIO_EXTILineConfig
;;;236    
;;;237      /* Configure EXTI Line9 to generate an interrupt on falling edge */
;;;238      EXTI_ClearITPendingBit(EXTI_Line8);
00000a  f44f7080          MOV      r0,#0x100
00000e  f7fffffe          BL       EXTI_ClearITPendingBit
;;;239      EXTI_InitStructure.EXTI_Line = EXTI_Line8;
000012  f44f7080          MOV      r0,#0x100
000016  9000              STR      r0,[sp,#0]
;;;240      EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
000018  f04f0000          MOV      r0,#0
00001c  f88d0004          STRB     r0,[sp,#4]
;;;241      EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
000020  f04f000c          MOV      r0,#0xc
000024  f88d0005          STRB     r0,[sp,#5]
;;;242      EXTI_InitStructure.EXTI_LineCmd = ENABLE;
000028  f04f0001          MOV      r0,#1
00002c  f88d0006          STRB     r0,[sp,#6]
;;;243      EXTI_Init(&EXTI_InitStructure);
000030  4668              MOV      r0,sp
000032  f7fffffe          BL       EXTI_Init
;;;244    
;;;245      /* Configure EXTI Line17(RTC Alarm) to generate an interrupt on rising edge */
;;;246      EXTI_ClearITPendingBit(EXTI_Line17);
000036  f44f3000          MOV      r0,#0x20000
00003a  f7fffffe          BL       EXTI_ClearITPendingBit
;;;247      EXTI_InitStructure.EXTI_Line = EXTI_Line17;
00003e  f44f3000          MOV      r0,#0x20000
000042  9000              STR      r0,[sp,#0]
;;;248      EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
000044  f04f0008          MOV      r0,#8
000048  f88d0005          STRB     r0,[sp,#5]
;;;249      EXTI_Init(&EXTI_InitStructure);    
00004c  4668              MOV      r0,sp
00004e  f7fffffe          BL       EXTI_Init
;;;250    }
000052  bd1c              POP      {r2-r4,pc}
;;;251    
                          ENDP


                          AREA ||i.GPIO_Configuration||, CODE, READONLY, ALIGN=2

                  GPIO_Configuration PROC
;;;202    *******************************************************************************/
;;;203    void GPIO_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;204    {
;;;205      GPIO_InitTypeDef GPIO_InitStructure;
;;;206    
;;;207      /* Enable GPIOC, GPIOB and AFIO clock */
;;;208      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC |RCC_APB2Periph_GPIOD |RCC_APB2Periph_GPIOE |
000002  2101              MOVS     r1,#1
000004  2079              MOVS     r0,#0x79
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;209                             RCC_APB2Periph_AFIO, ENABLE);
;;;210    
;;;211      /* Configure PD.10, PD.11, PD.12 and PD.13 as Output push-pull */
;;;212      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13;
00000a  f44f5070          MOV      r0,#0x3c00
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;213      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000012  f04f0003          MOV      r0,#3
000016  f88d0002          STRB     r0,[sp,#2]
;;;214      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00001a  f04f0010          MOV      r0,#0x10
00001e  f88d0003          STRB     r0,[sp,#3]
;;;215      GPIO_Init(GPIOD, &GPIO_InitStructure);
000022  4669              MOV      r1,sp
000024  4807              LDR      r0,|L3.68|
000026  f7fffffe          BL       GPIO_Init
;;;216    
;;;217      /* Configure PC8 as input floating (EXTI Line8) */
;;;218      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
00002a  f44f7080          MOV      r0,#0x100
00002e  f8ad0000          STRH     r0,[sp,#0]
;;;219      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
000032  f04f0048          MOV      r0,#0x48
000036  f88d0003          STRB     r0,[sp,#3]
;;;220      GPIO_Init(GPIOC, &GPIO_InitStructure);
00003a  4669              MOV      r1,sp
00003c  4802              LDR      r0,|L3.72|
00003e  f7fffffe          BL       GPIO_Init
;;;221    }
000042  bd08              POP      {r3,pc}
;;;222    
                          ENDP

                  |L3.68|
                          DCD      0x40011400
                  |L3.72|
                          DCD      0x40011000

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;302    *******************************************************************************/
;;;303    void NVIC_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;304    {
;;;305      NVIC_InitTypeDef NVIC_InitStructure;
;;;306    
;;;307      /* Set the Vector Table base location at 0x08000000 */ 
;;;308      NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);   
000002  2100              MOVS     r1,#0
000004  f04f6000          MOV      r0,#0x8000000
000008  f7fffffe          BL       NVIC_SetVectorTable
;;;309    
;;;310      /* 2 bits for Preemption Priority and 2 bits for Sub Priority */
;;;311      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
00000c  f44f60a0          MOV      r0,#0x500
000010  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;312    
;;;313      NVIC_InitStructure.NVIC_IRQChannel = RTCAlarm_IRQChannel;
000014  f04f0029          MOV      r0,#0x29
000018  f88d0000          STRB     r0,[sp,#0]
;;;314      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00001c  f04f0000          MOV      r0,#0
000020  f88d0001          STRB     r0,[sp,#1]
;;;315      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000024  f88d0002          STRB     r0,[sp,#2]
;;;316      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000028  f04f0001          MOV      r0,#1
00002c  f88d0003          STRB     r0,[sp,#3]
;;;317      NVIC_Init(&NVIC_InitStructure);
000030  4668              MOV      r0,sp
000032  f7fffffe          BL       NVIC_Init
;;;318    
;;;319      NVIC_InitStructure.NVIC_IRQChannel = EXTI9_5_IRQChannel;
000036  f04f0017          MOV      r0,#0x17
00003a  f88d0000          STRB     r0,[sp,#0]
;;;320      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
00003e  f04f0001          MOV      r0,#1
000042  f88d0001          STRB     r0,[sp,#1]
;;;321      NVIC_Init(&NVIC_InitStructure);
000046  4668              MOV      r0,sp
000048  f7fffffe          BL       NVIC_Init
;;;322    }
00004c  bd08              POP      {r3,pc}
;;;323    
                          ENDP


                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=2

                  RCC_Configuration PROC
;;;110    *******************************************************************************/
;;;111    void RCC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;112    {
;;;113      /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration -----------------------------*/   
;;;114      /* RCC system reset(for debug purpose) */
;;;115      RCC_DeInit();
000002  f7fffffe          BL       RCC_DeInit
;;;116    
;;;117      /* Enable HSE */
;;;118      RCC_HSEConfig(RCC_HSE_ON);
000006  f44f3080          MOV      r0,#0x10000
00000a  f7fffffe          BL       RCC_HSEConfig
;;;119    
;;;120      /* Wait till HSE is ready */
;;;121      HSEStartUpStatus = RCC_WaitForHSEStartUp();
00000e  f7fffffe          BL       RCC_WaitForHSEStartUp
000012  4917              LDR      r1,|L5.112|
000014  7008              STRB     r0,[r1,#0]
;;;122    
;;;123      if(HSEStartUpStatus == SUCCESS)
000016  4608              MOV      r0,r1
000018  7800              LDRB     r0,[r0,#0]  ; HSEStartUpStatus
00001a  2801              CMP      r0,#1
00001c  d126              BNE      |L5.108|
;;;124      {
;;;125        /* HCLK = SYSCLK */
;;;126        RCC_HCLKConfig(RCC_SYSCLK_Div1); 
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       RCC_HCLKConfig
;;;127      
;;;128        /* PCLK2 = HCLK */
;;;129        RCC_PCLK2Config(RCC_HCLK_Div1); 
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       RCC_PCLK2Config
;;;130    
;;;131        /* PCLK1 = HCLK/2 */
;;;132        RCC_PCLK1Config(RCC_HCLK_Div2);
00002a  f44f6080          MOV      r0,#0x400
00002e  f7fffffe          BL       RCC_PCLK1Config
;;;133    
;;;134        /* Flash 2 wait state */
;;;135        FLASH_SetLatency(FLASH_Latency_2);
000032  2002              MOVS     r0,#2
000034  f7fffffe          BL       FLASH_SetLatency
;;;136        /* Enable Prefetch Buffer */
;;;137        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
000038  2010              MOVS     r0,#0x10
00003a  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;138    
;;;139        /* PLLCLK = 8MHz * 9 = 72 MHz */
;;;140        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
00003e  f44f11e0          MOV      r1,#0x1c0000
000042  f44f3080          MOV      r0,#0x10000
000046  f7fffffe          BL       RCC_PLLConfig
;;;141    
;;;142        /* Enable PLL */ 
;;;143        RCC_PLLCmd(ENABLE);
00004a  2001              MOVS     r0,#1
00004c  f7fffffe          BL       RCC_PLLCmd
;;;144    
;;;145        /* Wait till PLL is ready */
;;;146        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
000050  bf00              NOP      
                  |L5.82|
000052  2039              MOVS     r0,#0x39
000054  f7fffffe          BL       RCC_GetFlagStatus
000058  2800              CMP      r0,#0
00005a  d0fa              BEQ      |L5.82|
;;;147        {
;;;148        }
;;;149    
;;;150        /* Select PLL as system clock source */
;;;151        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
00005c  2002              MOVS     r0,#2
00005e  f7fffffe          BL       RCC_SYSCLKConfig
;;;152    
;;;153        /* Wait till PLL is used as system clock source */
;;;154        while(RCC_GetSYSCLKSource() != 0x08)
000062  bf00              NOP      
                  |L5.100|
000064  f7fffffe          BL       RCC_GetSYSCLKSource
000068  2808              CMP      r0,#8
00006a  d1fb              BNE      |L5.100|
                  |L5.108|
;;;155        {
;;;156        }
;;;157      }
;;;158    }
00006c  bd10              POP      {r4,pc}
;;;159    
                          ENDP

00006e  0000              DCW      0x0000
                  |L5.112|
                          DCD      HSEStartUpStatus

                          AREA ||i.RTC_Configuration||, CODE, READONLY, ALIGN=1

                  RTC_Configuration PROC
;;;258    *******************************************************************************/
;;;259    void RTC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;260    {
;;;261      /* RTC clock source configuration ------------------------------------------*/
;;;262      /* Allow access to BKP Domain */
;;;263      PWR_BackupAccessCmd(ENABLE);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       PWR_BackupAccessCmd
;;;264    
;;;265      /* Reset Backup Domain */
;;;266      BKP_DeInit();
000008  f7fffffe          BL       BKP_DeInit
;;;267      
;;;268      /* Enable the LSE OSC */
;;;269      RCC_LSEConfig(RCC_LSE_ON);
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       RCC_LSEConfig
;;;270      /* Wait till LSE is ready */
;;;271      while(RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET)
000012  bf00              NOP      
                  |L6.20|
000014  2041              MOVS     r0,#0x41
000016  f7fffffe          BL       RCC_GetFlagStatus
00001a  2800              CMP      r0,#0
00001c  d0fa              BEQ      |L6.20|
;;;272      {
;;;273      }
;;;274    
;;;275      /* Select the RTC Clock Source */
;;;276      RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);
00001e  f44f7080          MOV      r0,#0x100
000022  f7fffffe          BL       RCC_RTCCLKConfig
;;;277    
;;;278      /* Enable the RTC Clock */
;;;279      RCC_RTCCLKCmd(ENABLE);
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       RCC_RTCCLKCmd
;;;280    
;;;281      /* RTC configuration -------------------------------------------------------*/
;;;282      /* Wait for RTC APB registers synchronisation */
;;;283      RTC_WaitForSynchro();
00002c  f7fffffe          BL       RTC_WaitForSynchro
;;;284    
;;;285      /* Set the RTC time base to 1s */
;;;286      RTC_SetPrescaler(32767);  
000030  f64770ff          MOV      r0,#0x7fff
000034  f7fffffe          BL       RTC_SetPrescaler
;;;287      /* Wait until last write operation on RTC registers has finished */
;;;288      RTC_WaitForLastTask();
000038  f7fffffe          BL       RTC_WaitForLastTask
;;;289    
;;;290      /* Enable the RTC Alarm interrupt */
;;;291      RTC_ITConfig(RTC_IT_ALR, ENABLE);
00003c  2101              MOVS     r1,#1
00003e  2002              MOVS     r0,#2
000040  f7fffffe          BL       RTC_ITConfig
;;;292      /* Wait until last write operation on RTC registers has finished */
;;;293      RTC_WaitForLastTask();
000044  f7fffffe          BL       RTC_WaitForLastTask
;;;294    }
000048  bd10              POP      {r4,pc}
;;;295    
                          ENDP


                          AREA ||i.SYSCLKConfig_STOP||, CODE, READONLY, ALIGN=2

                  SYSCLKConfig_STOP PROC
;;;167    *******************************************************************************/
;;;168    void SYSCLKConfig_STOP(void)
000000  b510              PUSH     {r4,lr}
;;;169    {
;;;170      /* Enable HSE */
;;;171      RCC_HSEConfig(RCC_HSE_ON);
000002  f44f3080          MOV      r0,#0x10000
000006  f7fffffe          BL       RCC_HSEConfig
;;;172    
;;;173      /* Wait till HSE is ready */
;;;174      HSEStartUpStatus = RCC_WaitForHSEStartUp();
00000a  f7fffffe          BL       RCC_WaitForHSEStartUp
00000e  490b              LDR      r1,|L7.60|
000010  7008              STRB     r0,[r1,#0]
;;;175    
;;;176      if(HSEStartUpStatus == SUCCESS)
000012  4608              MOV      r0,r1
000014  7800              LDRB     r0,[r0,#0]  ; HSEStartUpStatus
000016  2801              CMP      r0,#1
000018  d10f              BNE      |L7.58|
;;;177      {
;;;178        /* Enable PLL */ 
;;;179        RCC_PLLCmd(ENABLE);
00001a  f7fffffe          BL       RCC_PLLCmd
;;;180    
;;;181        /* Wait till PLL is ready */
;;;182        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
00001e  bf00              NOP      
                  |L7.32|
000020  2039              MOVS     r0,#0x39
000022  f7fffffe          BL       RCC_GetFlagStatus
000026  2800              CMP      r0,#0
000028  d0fa              BEQ      |L7.32|
;;;183        {
;;;184        }
;;;185    
;;;186        /* Select PLL as system clock source */
;;;187        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
00002a  2002              MOVS     r0,#2
00002c  f7fffffe          BL       RCC_SYSCLKConfig
;;;188    
;;;189        /* Wait till PLL is used as system clock source */
;;;190        while(RCC_GetSYSCLKSource() != 0x08)
000030  bf00              NOP      
                  |L7.50|
000032  f7fffffe          BL       RCC_GetSYSCLKSource
000036  2808              CMP      r0,#8
000038  d1fb              BNE      |L7.50|
                  |L7.58|
;;;191        {
;;;192        }
;;;193      }
;;;194    }
00003a  bd10              POP      {r4,pc}
;;;195    
                          ENDP

                  |L7.60|
                          DCD      HSEStartUpStatus

                          AREA ||i.SysTick_Configuration||, CODE, READONLY, ALIGN=2

                  SysTick_Configuration PROC
;;;330    *******************************************************************************/
;;;331    void SysTick_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;332    {
;;;333      /* Select AHB clock(HCLK) as SysTick clock source */
;;;334      SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK);
000002  2004              MOVS     r0,#4
000004  f7fffffe          BL       SysTick_CLKSourceConfig
;;;335    
;;;336      /* Set SysTick Priority to 3 */
;;;337      NVIC_SystemHandlerPriorityConfig(SystemHandler_SysTick, 3, 0);
000008  2200              MOVS     r2,#0
00000a  2103              MOVS     r1,#3
00000c  4804              LDR      r0,|L8.32|
00000e  f7fffffe          BL       NVIC_SystemHandlerPriorityConfig
;;;338       
;;;339      /* SysTick interrupt each 1ms with HCLK equal to 72MHz */
;;;340      SysTick_SetReload(72000);
000012  4804              LDR      r0,|L8.36|
000014  f7fffffe          BL       SysTick_SetReload
;;;341    
;;;342      /* Enable the SysTick Interrupt */
;;;343      SysTick_ITConfig(ENABLE);
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       SysTick_ITConfig
;;;344    }
00001e  bd10              POP      {r4,pc}
;;;345    
                          ENDP

                  |L8.32|
                          DCD      0x0002c39a
                  |L8.36|
                          DCD      0x00011940

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;35     *******************************************************************************/
;;;36     int main(void)
000000  f7fffffe          BL       RCC_Configuration
;;;37     {
;;;38     #ifdef DEBUG
;;;39       debug();
;;;40     #endif
;;;41        
;;;42       /* Clock configuration */
;;;43       RCC_Configuration();
;;;44     
;;;45       /* Enable PWR and BKP clock */
;;;46       RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
000004  2101              MOVS     r1,#1
000006  f04f50c0          MOV      r0,#0x18000000
00000a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;47     
;;;48       /* GPIO configuration */
;;;49       GPIO_Configuration();
00000e  f7fffffe          BL       GPIO_Configuration
;;;50     
;;;51       /* Configure EXTI Line9 to generate an interrupt on falling edge */
;;;52       EXTI_Configuration();
000012  f7fffffe          BL       EXTI_Configuration
;;;53     
;;;54       /* Configure RTC clock source and prescaler */
;;;55       RTC_Configuration();
000016  f7fffffe          BL       RTC_Configuration
;;;56     
;;;57       /* NVIC configuration */
;;;58       NVIC_Configuration();
00001a  f7fffffe          BL       NVIC_Configuration
;;;59     
;;;60       /* Configure the SysTick to generate an interrupt each 1 millisecond */
;;;61       SysTick_Configuration();
00001e  f7fffffe          BL       SysTick_Configuration
;;;62     
;;;63       /* Turn on led connected to PD.10 */
;;;64       GPIO_SetBits(GPIOD, GPIO_Pin_10); 
000022  f44f6180          MOV      r1,#0x400
000026  481c              LDR      r0,|L9.152|
000028  f7fffffe          BL       GPIO_SetBits
;;;65       /* Turn off led connected to PD.13 */
;;;66       GPIO_ResetBits(GPIOD, GPIO_Pin_13);
00002c  f44f5100          MOV      r1,#0x2000
000030  4819              LDR      r0,|L9.152|
000032  f7fffffe          BL       GPIO_ResetBits
;;;67       
;;;68       while(1)
000036  e02e              B        |L9.150|
                  |L9.56|
;;;69       {
;;;70         /* Insert 2 second delay */
;;;71         Delay(2000);
000038  f44f60fa          MOV      r0,#0x7d0
00003c  f7fffffe          BL       Delay
;;;72     
;;;73         /* Wait till RTC Second event occurs */
;;;74         RTC_ClearFlag(RTC_FLAG_SEC);
000040  2001              MOVS     r0,#1
000042  f7fffffe          BL       RTC_ClearFlag
;;;75         while(RTC_GetFlagStatus(RTC_FLAG_SEC) == RESET);
000046  bf00              NOP      
                  |L9.72|
000048  2001              MOVS     r0,#1
00004a  f7fffffe          BL       RTC_GetFlagStatus
00004e  2800              CMP      r0,#0
000050  d0fa              BEQ      |L9.72|
;;;76     
;;;77         /* Alarm in 3 second */
;;;78         RTC_SetAlarm(RTC_GetCounter()+ 3);
000052  f7fffffe          BL       RTC_GetCounter
000056  1cc4              ADDS     r4,r0,#3
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       RTC_SetAlarm
;;;79     
;;;80         /* Wait until last write operation on RTC registers has finished */
;;;81         RTC_WaitForLastTask();
00005e  f7fffffe          BL       RTC_WaitForLastTask
;;;82     
;;;83         /* Turn on led connected to PD.13 */
;;;84         GPIO_SetBits(GPIOD, GPIO_Pin_13); 
000062  f44f5100          MOV      r1,#0x2000
000066  480c              LDR      r0,|L9.152|
000068  f7fffffe          BL       GPIO_SetBits
;;;85         /* Turn off led connected to PD.10 */
;;;86         GPIO_ResetBits(GPIOD, GPIO_Pin_10); 
00006c  f44f6180          MOV      r1,#0x400
000070  4809              LDR      r0,|L9.152|
000072  f7fffffe          BL       GPIO_ResetBits
;;;87     
;;;88         /* Request to enter STOP mode with regulator ON */
;;;89         PWR_EnterSTOPMode(PWR_Regulator_ON, PWR_STOPEntry_WFI);
000076  2101              MOVS     r1,#1
000078  2000              MOVS     r0,#0
00007a  f7fffffe          BL       PWR_EnterSTOPMode
;;;90         
;;;91         /* At this stage the system has resumed from STOP mode -------------------*/
;;;92         /* Turn on led connected to PC.06 */
;;;93         GPIO_SetBits(GPIOD, GPIO_Pin_10); 
00007e  f44f6180          MOV      r1,#0x400
000082  4805              LDR      r0,|L9.152|
000084  f7fffffe          BL       GPIO_SetBits
;;;94     
;;;95         /* Configures system clock after wake-up from STOP: enable HSE, PLL and select PLL
;;;96            as system clock source (HSE and PLL are disabled in STOP mode) */
;;;97         SYSCLKConfig_STOP();
000088  f7fffffe          BL       SYSCLKConfig_STOP
;;;98     
;;;99         /* Turn off led connected to PD.13 */
;;;100        GPIO_ResetBits(GPIOD, GPIO_Pin_13);
00008c  f44f5100          MOV      r1,#0x2000
000090  4801              LDR      r0,|L9.152|
000092  f7fffffe          BL       GPIO_ResetBits
                  |L9.150|
000096  e7cf              B        |L9.56|
;;;101      }
;;;102    }
;;;103    
                          ENDP

                  |L9.152|
                          DCD      0x40011400

                          AREA ||.data||, DATA, ALIGN=0

                  HSEStartUpStatus
000000  00                DCB      0x00

                  __ARM_use_no_argv EQU 0
